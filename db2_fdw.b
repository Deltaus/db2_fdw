# 1 "db2_fdw.c"
# 1 "/home/postgres1/contrib/db2_fdw//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "db2_fdw.c"







# 1 "/products1/postgres/PG12.1/include/server/postgres.h" 1
# 46 "/products1/postgres/PG12.1/include/server/postgres.h"
# 1 "/products1/postgres/PG12.1/include/server/c.h" 1
# 49 "/products1/postgres/PG12.1/include/server/c.h"
# 1 "/products1/postgres/PG12.1/include/server/postgres_ext.h" 1
# 26 "/products1/postgres/PG12.1/include/server/postgres_ext.h"
# 1 "/products1/postgres/PG12.1/include/server/pg_config_ext.h" 1
# 27 "/products1/postgres/PG12.1/include/server/postgres_ext.h" 2




typedef unsigned int Oid;
# 47 "/products1/postgres/PG12.1/include/server/postgres_ext.h"
typedef long int pg_int64;
# 50 "/products1/postgres/PG12.1/include/server/c.h" 2




# 1 "/products1/postgres/PG12.1/include/server/pg_config.h" 1
# 55 "/products1/postgres/PG12.1/include/server/c.h" 2
# 1 "/products1/postgres/PG12.1/include/server/pg_config_manual.h" 1
# 56 "/products1/postgres/PG12.1/include/server/c.h" 2
# 1 "/products1/postgres/PG12.1/include/server/pg_config_os.h" 1
# 57 "/products1/postgres/PG12.1/include/server/c.h" 2


# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 375 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 392 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 393 "/usr/include/sys/cdefs.h" 2 3 4
# 376 "/usr/include/features.h" 2 3 4
# 399 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 400 "/usr/include/features.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 212 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 130 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 131 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 36 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 33 "/usr/include/libio.h" 2 3 4
# 50 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 51 "/usr/include/libio.h" 2 3 4
# 145 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 155 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 178 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 246 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 294 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 303 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 339 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 435 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 465 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 90 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 640 "/usr/include/stdio.h" 3 4

# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 934 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio.h" 1 3 4
# 35 "/usr/include/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 935 "/usr/include/stdio.h" 2 3 4
# 943 "/usr/include/stdio.h" 3 4

# 60 "/products1/postgres/PG12.1/include/server/c.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 324 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 3 4
typedef int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 64 "/usr/include/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4






# 1 "/usr/include/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/bits/byteswap.h" 2 3 4
# 44 "/usr/include/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 65 "/usr/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 67 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 235 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 236 "/usr/include/stdlib.h" 2 3 4



extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ , __leaf__)) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}

# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 98 "/usr/include/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 115 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 147 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 22 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/select.h" 2 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 44 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 30 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/sys/select.h" 2 3 4
# 54 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 64 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/sys/select.h" 3 4

# 106 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/sys/select.h" 3 4

# 220 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 29 "/usr/include/sys/sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_major (unsigned long long int __dev)
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_minor (unsigned long long int __dev)
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned long long int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}


# 223 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 125 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 212 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/sys/types.h" 2 3 4



# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 492 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__, __alloc_size__ (2)));




extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));







extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 605 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 619 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 629 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 641 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 651 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 662 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 673 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 683 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 693 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 705 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 733 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 807 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__)) ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 895 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/bits/stdlib-float.h" 3 4

extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ , __leaf__)) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}

# 952 "/usr/include/stdlib.h" 2 3 4
# 964 "/usr/include/stdlib.h" 3 4

# 61 "/products1/postgres/PG12.1/include/server/c.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 92 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 106 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 117 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 162 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 207 "/usr/include/string.h" 3 4

# 232 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 259 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 273 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 311 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 338 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 369 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 434 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 485 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 513 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 602 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 630 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/string.h" 1 3 4
# 631 "/usr/include/string.h" 2 3 4


# 1 "/usr/include/bits/string2.h" 1 3 4
# 393 "/usr/include/bits/string2.h" 3 4
extern void *__rawmemchr (const void *__s, int __c);
# 968 "/usr/include/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) size_t __strcspn_c1 (const char *__s, int __reject);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strcspn_c1 (const char *__s, int __reject)
{
  size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strcspn_c2 (const char *__s, int __reject1,
         int __reject2);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strcspn_c2 (const char *__s, int __reject1, int __reject2)
{
  size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strcspn_c3 (const char *__s, int __reject1,
         int __reject2, int __reject3);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strcspn_c3 (const char *__s, int __reject1, int __reject2,
       int __reject3)
{
  size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2 && __s[__result] != __reject3)
    ++__result;
  return __result;
}
# 1044 "/usr/include/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) size_t __strspn_c1 (const char *__s, int __accept);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strspn_c1 (const char *__s, int __accept)
{
  size_t __result = 0;

  while (__s[__result] == __accept)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strspn_c2 (const char *__s, int __accept1,
        int __accept2);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strspn_c2 (const char *__s, int __accept1, int __accept2)
{
  size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strspn_c3 (const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strspn_c3 (const char *__s, int __accept1, int __accept2, int __accept3)
{
  size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2
  || __s[__result] == __accept3)
    ++__result;
  return __result;
}
# 1120 "/usr/include/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) char *__strpbrk_c2 (const char *__s, int __accept1,
        int __accept2);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strpbrk_c2 (const char *__s, int __accept1, int __accept2)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}

extern __inline __attribute__ ((__gnu_inline__)) char *__strpbrk_c3 (const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strpbrk_c3 (const char *__s, int __accept1, int __accept2, int __accept3)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
  && *__s != __accept3)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}
# 1170 "/usr/include/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strtok_r_1c (char *__s, char __sep, char **__nextp)
{
  char *__result;
  if (__s == ((void *)0))
    __s = *__nextp;
  while (*__s == __sep)
    ++__s;
  __result = ((void *)0);
  if (*__s != '\0')
    {
      __result = __s++;
      while (*__s != '\0')
 if (*__s++ == __sep)
   {
     __s[-1] = '\0';
     break;
   }
    }
  *__nextp = __s;
  return __result;
}
# 1202 "/usr/include/bits/string2.h" 3 4
extern char *__strsep_g (char **__stringp, const char *__delim);
# 1220 "/usr/include/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_1c (char **__s, char __reject);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_1c (char **__s, char __reject)
{
  char *__retval = *__s;
  if (__retval != ((void *)0) && (*__s = (__extension__ (__builtin_constant_p (__reject) && !__builtin_constant_p (__retval) && (__reject) == '\0' ? (char *) __rawmemchr (__retval, __reject) : __builtin_strchr (__retval, __reject)))) != ((void *)0))
    *(*__s)++ = '\0';
  return __retval;
}

extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_2c (char **__s, char __reject1, char __reject2);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_2c (char **__s, char __reject1, char __reject2)
{
  char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}

extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_3c (char **__s, char __reject1, char __reject2,
       char __reject3);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
{
  char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}
# 1301 "/usr/include/bits/string2.h" 3 4
extern char *__strdup (const char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));
# 1320 "/usr/include/bits/string2.h" 3 4
extern char *__strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));
# 634 "/usr/include/string.h" 2 3 4
# 642 "/usr/include/string.h" 3 4

# 62 "/products1/postgres/PG12.1/include/server/c.h" 2
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 147 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 63 "/products1/postgres/PG12.1/include/server/c.h" 2
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdarg.h" 1 3 4
# 64 "/products1/postgres/PG12.1/include/server/c.h" 2

# 1 "/usr/include/strings.h" 1 3 4
# 66 "/products1/postgres/PG12.1/include/server/c.h" 2


# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
# 22 "/usr/include/bits/wchar.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/wchar.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 10 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdint.h" 2 3 4
# 69 "/products1/postgres/PG12.1/include/server/c.h" 2


# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4




# 1 "/usr/include/bits/errno.h" 1 3 4
# 24 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/bits/errno.h" 2 3 4
# 50 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 54 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;




# 68 "/usr/include/errno.h" 3 4
typedef int error_t;
# 72 "/products1/postgres/PG12.1/include/server/c.h" 2



# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 31 "/usr/include/locale.h" 2 3 4


# 51 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));


# 152 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) __attribute__ ((__nothrow__ , __leaf__));
# 187 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));



extern void freelocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));






extern __locale_t uselocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));








# 76 "/products1/postgres/PG12.1/include/server/c.h" 2
# 303 "/products1/postgres/PG12.1/include/server/c.h"
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stdbool.h" 1 3 4
# 304 "/products1/postgres/PG12.1/include/server/c.h" 2
# 335 "/products1/postgres/PG12.1/include/server/c.h"
typedef char *Pointer;
# 344 "/products1/postgres/PG12.1/include/server/c.h"
typedef signed char int8;
typedef signed short int16;
typedef signed int int32;
# 356 "/products1/postgres/PG12.1/include/server/c.h"
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;






typedef uint8 bits8;
typedef uint16 bits16;
typedef uint32 bits32;
# 376 "/products1/postgres/PG12.1/include/server/c.h"
typedef long int int64;


typedef unsigned long int uint64;
# 415 "/products1/postgres/PG12.1/include/server/c.h"
typedef __int128 int128

   __attribute__((aligned(8)))

     ;

typedef unsigned __int128 uint128

   __attribute__((aligned(8)))

     ;
# 466 "/products1/postgres/PG12.1/include/server/c.h"
typedef size_t Size;
# 475 "/products1/postgres/PG12.1/include/server/c.h"
typedef unsigned int Index;
# 485 "/products1/postgres/PG12.1/include/server/c.h"
typedef signed int Offset;




typedef float float4;
typedef double float8;
# 504 "/products1/postgres/PG12.1/include/server/c.h"
typedef Oid regproc;
typedef regproc RegProcedure;

typedef uint32 TransactionId;

typedef uint32 LocalTransactionId;

typedef uint32 SubTransactionId;





typedef TransactionId MultiXactId;

typedef uint32 MultiXactOffset;

typedef uint32 CommandId;
# 530 "/products1/postgres/PG12.1/include/server/c.h"
typedef struct
{
 int indx[6];
} IntArray;
# 549 "/products1/postgres/PG12.1/include/server/c.h"
struct varlena
{
 char vl_len_[4];
 char vl_dat[];
};
# 562 "/products1/postgres/PG12.1/include/server/c.h"
typedef struct varlena bytea;
typedef struct varlena text;
typedef struct varlena BpChar;
typedef struct varlena VarChar;
# 577 "/products1/postgres/PG12.1/include/server/c.h"
typedef struct
{
 int32 vl_len_;
 int ndim;
 int32 dataoffset;
 Oid elemtype;
 int dim1;
 int lbound1;
 int16 values[];
} int2vector;

typedef struct
{
 int32 vl_len_;
 int ndim;
 int32 dataoffset;
 Oid elemtype;
 int dim1;
 int lbound1;
 Oid values[];
} oidvector;





typedef struct nameData
{
 char data[64];
} NameData;
typedef NameData *Name;
# 802 "/products1/postgres/PG12.1/include/server/c.h"
extern void ExceptionalCondition(const char *conditionName,
         const char *errorType,
         const char *fileName, int lineNumber) __attribute__((noreturn));
# 1068 "/products1/postgres/PG12.1/include/server/c.h"
typedef union PGAlignedBlock
{
 char data[8192];
 double force_align_d;
 int64 force_align_i64;
} PGAlignedBlock;


typedef union PGAlignedXLogBlock
{
 char data[8192];
 double force_align_d;
 int64 force_align_i64;
} PGAlignedXLogBlock;
# 1291 "/products1/postgres/PG12.1/include/server/c.h"
# 1 "/products1/postgres/PG12.1/include/server/port.h" 1
# 16 "/products1/postgres/PG12.1/include/server/port.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 29 "/usr/include/ctype.h" 3 4

# 47 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 80 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 105 "/usr/include/ctype.h" 3 4






extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));








extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));






extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));






extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 215 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 272 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 348 "/usr/include/ctype.h" 3 4

# 17 "/products1/postgres/PG12.1/include/server/port.h" 2
# 1 "/usr/include/netdb.h" 1 3 4
# 27 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/netinet/in.h" 1 3 4
# 24 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/sys/socket.h" 1 3 4
# 25 "/usr/include/sys/socket.h" 3 4


# 1 "/usr/include/sys/uio.h" 1 3 4
# 26 "/usr/include/sys/uio.h" 3 4



# 1 "/usr/include/bits/uio.h" 1 3 4
# 43 "/usr/include/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 56 "/usr/include/bits/uio.h" 3 4



extern ssize_t process_vm_readv (pid_t __pid, const struct iovec *__lvec,
     unsigned long int __liovcnt,
     const struct iovec *__rvec,
     unsigned long int __riovcnt,
     unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));


extern ssize_t process_vm_writev (pid_t __pid, const struct iovec *__lvec,
      unsigned long int __liovcnt,
      const struct iovec *__rvec,
      unsigned long int __riovcnt,
      unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));


# 30 "/usr/include/sys/uio.h" 2 3 4
# 40 "/usr/include/sys/uio.h" 3 4
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  ;
# 51 "/usr/include/sys/uio.h" 3 4
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  ;
# 66 "/usr/include/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
         __off_t __offset) ;
# 78 "/usr/include/sys/uio.h" 3 4
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
   __off_t __offset) ;
# 104 "/usr/include/sys/uio.h" 3 4
extern ssize_t preadv64 (int __fd, const struct iovec *__iovec, int __count,
    __off64_t __offset) ;
# 116 "/usr/include/sys/uio.h" 3 4
extern ssize_t pwritev64 (int __fd, const struct iovec *__iovec, int __count,
     __off64_t __offset) ;




# 28 "/usr/include/sys/socket.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 30 "/usr/include/sys/socket.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 33 "/usr/include/sys/socket.h" 2 3 4






# 1 "/usr/include/bits/socket.h" 1 3 4
# 28 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 29 "/usr/include/bits/socket.h" 2 3 4





typedef __socklen_t socklen_t;




# 1 "/usr/include/bits/socket_type.h" 1 3 4
# 24 "/usr/include/bits/socket_type.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};
# 40 "/usr/include/bits/socket.h" 2 3 4
# 147 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/bits/sockaddr.h" 1 3 4
# 28 "/usr/include/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 148 "/usr/include/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 163 "/usr/include/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    char __ss_padding[(128 - (sizeof (unsigned short int)) - sizeof (unsigned long int))];
    unsigned long int __ss_align;
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,



    MSG_TRYHARD = MSG_DONTROUTE,


    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,

    MSG_FASTOPEN = 0x20000000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 273 "/usr/include/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__ , __leaf__));




extern __inline __attribute__ ((__gnu_inline__)) struct cmsghdr *
__attribute__ ((__nothrow__ , __leaf__)) __cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg)
{
  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))

    return (struct cmsghdr *) 0;

  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
          + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1)));
  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
     + __mhdr->msg_controllen)
      || ((unsigned char *) __cmsg + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
   > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))

    return (struct cmsghdr *) 0;
  return __cmsg;
}




enum
  {
    SCM_RIGHTS = 0x01


    , SCM_CREDENTIALS = 0x02


  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};
# 346 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4



# 1 "/usr/include/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 1 "/usr/include/asm/sockios.h" 2 3 4
# 5 "/usr/include/asm-generic/socket.h" 2 3 4
# 1 "/usr/include/asm/socket.h" 2 3 4
# 347 "/usr/include/bits/socket.h" 2 3 4
# 380 "/usr/include/bits/socket.h" 3 4
struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 40 "/usr/include/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 91 "/usr/include/sys/socket.h" 3 4
typedef union { struct sockaddr *__restrict __sockaddr__; struct sockaddr_at *__restrict __sockaddr_at__; struct sockaddr_ax25 *__restrict __sockaddr_ax25__; struct sockaddr_dl *__restrict __sockaddr_dl__; struct sockaddr_eon *__restrict __sockaddr_eon__; struct sockaddr_in *__restrict __sockaddr_in__; struct sockaddr_in6 *__restrict __sockaddr_in6__; struct sockaddr_inarp *__restrict __sockaddr_inarp__; struct sockaddr_ipx *__restrict __sockaddr_ipx__; struct sockaddr_iso *__restrict __sockaddr_iso__; struct sockaddr_ns *__restrict __sockaddr_ns__; struct sockaddr_un *__restrict __sockaddr_un__; struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __SOCKADDR_ARG __attribute__ ((__transparent_union__));


typedef union { const struct sockaddr *__restrict __sockaddr__; const struct sockaddr_at *__restrict __sockaddr_at__; const struct sockaddr_ax25 *__restrict __sockaddr_ax25__; const struct sockaddr_dl *__restrict __sockaddr_dl__; const struct sockaddr_eon *__restrict __sockaddr_eon__; const struct sockaddr_in *__restrict __sockaddr_in__; const struct sockaddr_in6 *__restrict __sockaddr_in6__; const struct sockaddr_inarp *__restrict __sockaddr_inarp__; const struct sockaddr_ipx *__restrict __sockaddr_ipx__; const struct sockaddr_iso *__restrict __sockaddr_iso__; const struct sockaddr_ns *__restrict __sockaddr_ns__; const struct sockaddr_un *__restrict __sockaddr_un__; const struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __CONST_SOCKADDR_ARG __attribute__ ((__transparent_union__));





struct mmsghdr
  {
    struct msghdr msg_hdr;
    unsigned int msg_len;

  };






extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__ , __leaf__));





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__ , __leaf__));


extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));


extern int getsockname (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));
# 138 "/usr/include/sys/socket.h" 3 4
extern int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);



extern int getpeername (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));






extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, __CONST_SOCKADDR_ARG __addr,
         socklen_t __addr_len);
# 175 "/usr/include/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, __SOCKADDR_ARG __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);







extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags);







extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);







extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags,
       const struct timespec *__tmo);






extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__ , __leaf__));




extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__ , __leaf__));





extern int listen (int __fd, int __n) __attribute__ ((__nothrow__ , __leaf__));
# 244 "/usr/include/sys/socket.h" 3 4
extern int accept (int __fd, __SOCKADDR_ARG __addr,
     socklen_t *__restrict __addr_len);






extern int accept4 (int __fd, __SOCKADDR_ARG __addr,
      socklen_t *__restrict __addr_len, int __flags);
# 262 "/usr/include/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__ , __leaf__));




extern int sockatmark (int __fd) __attribute__ ((__nothrow__ , __leaf__));







extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__ , __leaf__));
# 284 "/usr/include/sys/socket.h" 3 4

# 25 "/usr/include/netinet/in.h" 2 3 4






typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };


# 1 "/usr/include/bits/in.h" 1 3 4
# 146 "/usr/include/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 39 "/usr/include/netinet/in.h" 2 3 4


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_MTP = 92,

    IPPROTO_BEETPH = 94,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };





enum
  {
    IPPROTO_HOPOPTS = 0,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MH = 135

  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };
# 210 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];

 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];

      } __in6_u;





  };


extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 238 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };



struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 375 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 387 "/usr/include/netinet/in.h" 2 3 4
# 502 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__ , __leaf__));


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__ , __leaf__));
# 532 "/usr/include/netinet/in.h" 3 4
struct cmsghdr;



struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };


struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr;
    uint32_t ip6m_mtu;
  };



extern int inet6_option_space (int __nbytes)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    const uint8_t *__typep, int __multx,
    int __plusy) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_next (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_find (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));



extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));



extern socklen_t inet6_rth_space (int __type, int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_add (void *__bp, const struct in6_addr *__addr) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_reverse (const void *__in, void *__out) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_segments (const void *__bp) __attribute__ ((__nothrow__ , __leaf__));
extern struct in6_addr *inet6_rth_getaddr (const void *__bp, int __index)
     __attribute__ ((__nothrow__ , __leaf__));





extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));


extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    const struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));


extern int setsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       const struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));



# 28 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/rpc/netdb.h" 1 3 4
# 42 "/usr/include/rpc/netdb.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 43 "/usr/include/rpc/netdb.h" 2 3 4



struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) __attribute__ ((__nothrow__ , __leaf__));
extern void endrpcent (void) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbyname (const char *__name) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbynumber (int __number) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcent (void) __attribute__ ((__nothrow__ , __leaf__));


extern int getrpcbyname_r (const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));



# 33 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 24 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 301 "/usr/include/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 38 "/usr/include/netdb.h" 2 3 4

# 1 "/usr/include/time.h" 1 3 4
# 40 "/usr/include/netdb.h" 2 3 4


# 1 "/usr/include/bits/netdb.h" 1 3 4
# 26 "/usr/include/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
# 43 "/usr/include/netdb.h" 2 3 4
# 53 "/usr/include/netdb.h" 3 4








extern int *__h_errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 92 "/usr/include/netdb.h" 3 4
extern void herror (const char *__str) __attribute__ ((__nothrow__ , __leaf__));


extern const char *hstrerror (int __err_num) __attribute__ ((__nothrow__ , __leaf__));




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;



};






extern void sethostent (int __stay_open);





extern void endhostent (void);






extern struct hostent *gethostent (void);






extern struct hostent *gethostbyaddr (const void *__addr, __socklen_t __len,
          int __type);





extern struct hostent *gethostbyname (const char *__name);
# 155 "/usr/include/netdb.h" 3 4
extern struct hostent *gethostbyname2 (const char *__name, int __af);
# 167 "/usr/include/netdb.h" 3 4
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);
# 198 "/usr/include/netdb.h" 3 4
extern void setnetent (int __stay_open);





extern void endnetent (void);






extern struct netent *getnetent (void);






extern struct netent *getnetbyaddr (uint32_t __net, int __type);





extern struct netent *getnetbyname (const char *__name);
# 237 "/usr/include/netdb.h" 3 4
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};






extern void setservent (int __stay_open);





extern void endservent (void);






extern struct servent *getservent (void);






extern struct servent *getservbyname (const char *__name, const char *__proto);






extern struct servent *getservbyport (int __port, const char *__proto);
# 308 "/usr/include/netdb.h" 3 4
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (const char *__restrict __name,
       const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};






extern void setprotoent (int __stay_open);





extern void endprotoent (void);






extern struct protoent *getprotoent (void);





extern struct protoent *getprotobyname (const char *__name);





extern struct protoent *getprotobynumber (int __proto);
# 374 "/usr/include/netdb.h" 3 4
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);
# 395 "/usr/include/netdb.h" 3 4
extern int setnetgrent (const char *__netgroup);







extern void endnetgrent (void);
# 412 "/usr/include/netdb.h" 3 4
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);
# 423 "/usr/include/netdb.h" 3 4
extern int innetgr (const char *__netgroup, const char *__host,
      const char *__user, const char *__domain);







extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);
# 451 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   const char *__restrict __locuser,
   const char *__restrict __remuser,
   const char *__restrict __cmd, int *__restrict __fd2p);
# 463 "/usr/include/netdb.h" 3 4
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      const char *__restrict __locuser,
      const char *__restrict __remuser,
      const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);
# 479 "/usr/include/netdb.h" 3 4
extern int rexec (char **__restrict __ahost, int __rport,
    const char *__restrict __name,
    const char *__restrict __pass,
    const char *__restrict __cmd, int *__restrict __fd2p);
# 491 "/usr/include/netdb.h" 3 4
extern int rexec_af (char **__restrict __ahost, int __rport,
       const char *__restrict __name,
       const char *__restrict __pass,
       const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);
# 505 "/usr/include/netdb.h" 3 4
extern int ruserok (const char *__rhost, int __suser,
      const char *__remuser, const char *__locuser);
# 515 "/usr/include/netdb.h" 3 4
extern int ruserok_af (const char *__rhost, int __suser,
         const char *__remuser, const char *__locuser,
         sa_family_t __af);
# 528 "/usr/include/netdb.h" 3 4
extern int iruserok (uint32_t __raddr, int __suser,
       const char *__remuser, const char *__locuser);
# 539 "/usr/include/netdb.h" 3 4
extern int iruserok_af (const void *__raddr, int __suser,
   const char *__remuser, const char *__locuser,
   sa_family_t __af);
# 551 "/usr/include/netdb.h" 3 4
extern int rresvport (int *__alport);
# 560 "/usr/include/netdb.h" 3 4
extern int rresvport_af (int *__alport, sa_family_t __af);






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};



struct gaicb
{
  const char *ar_name;
  const char *ar_service;
  const struct addrinfo *ar_request;
  struct addrinfo *ar_result;

  int __return;
  int __unused[5];
};
# 662 "/usr/include/netdb.h" 3 4
extern int getaddrinfo (const char *__restrict __name,
   const char *__restrict __service,
   const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);


extern void freeaddrinfo (struct addrinfo *__ai) __attribute__ ((__nothrow__ , __leaf__));


extern const char *gai_strerror (int __ecode) __attribute__ ((__nothrow__ , __leaf__));





extern int getnameinfo (const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, int __flags);
# 692 "/usr/include/netdb.h" 3 4
extern int getaddrinfo_a (int __mode, struct gaicb *__list[__restrict],
     int __ent, struct sigevent *__restrict __sig);
# 703 "/usr/include/netdb.h" 3 4
extern int gai_suspend (const struct gaicb *const __list[], int __ent,
   const struct timespec *__timeout);


extern int gai_error (struct gaicb *__req) __attribute__ ((__nothrow__ , __leaf__));


extern int gai_cancel (struct gaicb *__gaicbp) __attribute__ ((__nothrow__ , __leaf__));



# 18 "/products1/postgres/PG12.1/include/server/port.h" 2
# 1 "/usr/include/pwd.h" 1 3 4
# 28 "/usr/include/pwd.h" 3 4





# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 34 "/usr/include/pwd.h" 2 3 4
# 50 "/usr/include/pwd.h" 3 4
struct passwd
{
  char *pw_name;
  char *pw_passwd;
  __uid_t pw_uid;
  __gid_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
};
# 73 "/usr/include/pwd.h" 3 4
extern void setpwent (void);





extern void endpwent (void);





extern struct passwd *getpwent (void);
# 95 "/usr/include/pwd.h" 3 4
extern struct passwd *fgetpwent (FILE *__stream);







extern int putpwent (const struct passwd *__restrict __p,
       FILE *__restrict __f);






extern struct passwd *getpwuid (__uid_t __uid);





extern struct passwd *getpwnam (const char *__name);
# 140 "/usr/include/pwd.h" 3 4
extern int getpwent_r (struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);


extern int getpwuid_r (__uid_t __uid,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);

extern int getpwnam_r (const char *__restrict __name,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);
# 164 "/usr/include/pwd.h" 3 4
extern int fgetpwent_r (FILE *__restrict __stream,
   struct passwd *__restrict __resultbuf,
   char *__restrict __buffer, size_t __buflen,
   struct passwd **__restrict __result);
# 181 "/usr/include/pwd.h" 3 4
extern int getpw (__uid_t __uid, char *__buffer);



# 19 "/products1/postgres/PG12.1/include/server/port.h" 2
# 31 "/products1/postgres/PG12.1/include/server/port.h"
typedef int pgsocket;
# 41 "/products1/postgres/PG12.1/include/server/port.h"
extern _Bool pg_set_noblock(pgsocket sock);
extern _Bool pg_set_block(pgsocket sock);



extern _Bool has_drive_prefix(const char *filename);
extern char *first_dir_separator(const char *filename);
extern char *last_dir_separator(const char *filename);
extern char *first_path_var_separator(const char *pathlist);
extern void join_path_components(char *ret_path,
         const char *head, const char *tail);
extern void canonicalize_path(char *path);
extern void make_native_path(char *path);
extern void cleanup_path(char *path);
extern _Bool path_contains_parent_reference(const char *path);
extern _Bool path_is_relative_and_below_cwd(const char *path);
extern _Bool path_is_prefix_of_path(const char *path1, const char *path2);
extern char *make_absolute_path(const char *path);
extern const char *get_progname(const char *argv0);
extern void get_share_path(const char *my_exec_path, char *ret_path);
extern void get_etc_path(const char *my_exec_path, char *ret_path);
extern void get_include_path(const char *my_exec_path, char *ret_path);
extern void get_pkginclude_path(const char *my_exec_path, char *ret_path);
extern void get_includeserver_path(const char *my_exec_path, char *ret_path);
extern void get_lib_path(const char *my_exec_path, char *ret_path);
extern void get_pkglib_path(const char *my_exec_path, char *ret_path);
extern void get_locale_path(const char *my_exec_path, char *ret_path);
extern void get_doc_path(const char *my_exec_path, char *ret_path);
extern void get_html_path(const char *my_exec_path, char *ret_path);
extern void get_man_path(const char *my_exec_path, char *ret_path);
extern _Bool get_home_path(char *ret_path);
extern void get_parent_directory(char *path);


extern char **pgfnames(const char *path);
extern void pgfnames_cleanup(char **filenames);
# 103 "/products1/postgres/PG12.1/include/server/port.h"
extern void set_pglocale_pgservice(const char *argv0, const char *app);


extern int find_my_exec(const char *argv0, char *retpath);
extern int find_other_exec(const char *argv0, const char *target,
       const char *versionstr, char *retpath);
# 127 "/products1/postgres/PG12.1/include/server/port.h"
extern void pg_usleep(long microsec);


extern int pg_strcasecmp(const char *s1, const char *s2);
extern int pg_strncasecmp(const char *s1, const char *s2, size_t n);
extern unsigned char pg_toupper(unsigned char ch);
extern unsigned char pg_tolower(unsigned char ch);
extern unsigned char pg_ascii_toupper(unsigned char ch);
extern unsigned char pg_ascii_tolower(unsigned char ch);
# 174 "/products1/postgres/PG12.1/include/server/port.h"
extern int pg_vsnprintf(char *str, size_t count, const char *fmt, va_list args);
extern int pg_snprintf(char *str, size_t count, const char *fmt,...) __attribute__((format(gnu_printf, 3, 4)));
extern int pg_vsprintf(char *str, const char *fmt, va_list args);
extern int pg_sprintf(char *str, const char *fmt,...) __attribute__((format(gnu_printf, 2, 3)));
extern int pg_vfprintf(FILE *stream, const char *fmt, va_list args);
extern int pg_fprintf(FILE *stream, const char *fmt,...) __attribute__((format(gnu_printf, 2, 3)));
extern int pg_vprintf(const char *fmt, va_list args);
extern int pg_printf(const char *fmt,...) __attribute__((format(gnu_printf, 1, 2)));
# 201 "/products1/postgres/PG12.1/include/server/port.h"
extern int pg_strfromd(char *str, size_t count, int precision, double value);


extern char *pg_strerror(int errnum);



extern char *pg_strerror_r(int errnum, char *buf, size_t buflen);




extern const char *pg_strsignal(int signum);


extern void simple_prompt(const char *prompt, char *destination, size_t destlen,
        _Bool echo);

extern int pclose_check(FILE *stream);
# 264 "/products1/postgres/PG12.1/include/server/port.h"
extern _Bool rmtree(const char *path, _Bool rmtopdir);
# 346 "/products1/postgres/PG12.1/include/server/port.h"
extern double pg_erand48(unsigned short xseed[3]);
extern long pg_lrand48(void);
extern long pg_jrand48(unsigned short xseed[3]);
extern void pg_srand48(long seed);


extern int fls(int mask);
# 361 "/products1/postgres/PG12.1/include/server/port.h"
extern int getpeereid(int sock, uid_t *uid, gid_t *gid);
# 425 "/products1/postgres/PG12.1/include/server/port.h"
extern size_t strlcat(char *dst, const char *src, size_t siz);



extern size_t strlcpy(char *dst, const char *src, size_t siz);
# 477 "/products1/postgres/PG12.1/include/server/port.h"
extern int pqGetpwuid(uid_t uid, struct passwd *resultbuf, char *buffer,
        size_t buflen, struct passwd **result);


extern int pqGethostbyname(const char *name,
       struct hostent *resultbuf,
       char *buffer, size_t buflen,
       struct hostent **result,
       int *herrno);

extern void pg_qsort(void *base, size_t nel, size_t elsize,
      int (*cmp) (const void *, const void *));
extern int pg_qsort_strcmp(const void *a, const void *b);



typedef int (*qsort_arg_comparator) (const void *a, const void *b, void *arg);

extern void qsort_arg(void *base, size_t nel, size_t elsize,
       qsort_arg_comparator cmp, void *arg);


extern int pg_get_encoding_from_locale(const char *ctype, _Bool write_message);






extern char *inet_net_ntop(int af, const void *src, int bits,
         char *dst, size_t size);


extern _Bool pg_strong_random(void *buf, size_t len);
# 519 "/products1/postgres/PG12.1/include/server/port.h"
extern int pg_check_dir(const char *dir);


extern int pg_mkdir_p(char *path, int omode);


typedef void (*pqsigfunc) (int signo);
extern pqsigfunc pqsignal(int signo, pqsigfunc func);

extern pqsigfunc pqsignal_no_restart(int signo, pqsigfunc func);





extern char *escape_single_quotes_ascii(const char *src);


extern char *wait_result_to_str(int exit_status);
extern _Bool wait_result_is_signal(int exit_status, int signum);
extern _Bool wait_result_is_any_signal(int exit_status, _Bool include_command_not_found);
# 1292 "/products1/postgres/PG12.1/include/server/c.h" 2
# 47 "/products1/postgres/PG12.1/include/server/postgres.h" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/elog.h" 1
# 17 "/products1/postgres/PG12.1/include/server/utils/elog.h"
# 1 "/usr/include/setjmp.h" 1 3 4
# 27 "/usr/include/setjmp.h" 3 4


# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 26 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 30 "/usr/include/setjmp.h" 2 3 4
# 1 "/usr/include/bits/sigset.h" 1 3 4
# 31 "/usr/include/setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };




typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));






extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));




extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));
# 77 "/usr/include/setjmp.h" 3 4




extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 109 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 119 "/usr/include/setjmp.h" 3 4

# 18 "/products1/postgres/PG12.1/include/server/utils/elog.h" 2
# 71 "/products1/postgres/PG12.1/include/server/utils/elog.h"
# 1 "/products1/postgres/PG12.1/include/server/utils/errcodes.h" 1
# 72 "/products1/postgres/PG12.1/include/server/utils/elog.h" 2
# 146 "/products1/postgres/PG12.1/include/server/utils/elog.h"
extern _Bool errstart(int elevel, const char *filename, int lineno,
      const char *funcname, const char *domain);
extern void errfinish(int dummy,...);

extern int errcode(int sqlerrcode);

extern int errcode_for_file_access(void);
extern int errcode_for_socket_access(void);

extern int errmsg(const char *fmt,...) __attribute__((format(gnu_printf, 1, 2)));
extern int errmsg_internal(const char *fmt,...) __attribute__((format(gnu_printf, 1, 2)));

extern int errmsg_plural(const char *fmt_singular, const char *fmt_plural,
        unsigned long n,...) __attribute__((format(gnu_printf, 1, 4))) __attribute__((format(gnu_printf, 2, 4)));

extern int errdetail(const char *fmt,...) __attribute__((format(gnu_printf, 1, 2)));
extern int errdetail_internal(const char *fmt,...) __attribute__((format(gnu_printf, 1, 2)));

extern int errdetail_log(const char *fmt,...) __attribute__((format(gnu_printf, 1, 2)));

extern int errdetail_log_plural(const char *fmt_singular,
         const char *fmt_plural,
         unsigned long n,...) __attribute__((format(gnu_printf, 1, 4))) __attribute__((format(gnu_printf, 2, 4)));

extern int errdetail_plural(const char *fmt_singular, const char *fmt_plural,
        unsigned long n,...) __attribute__((format(gnu_printf, 1, 4))) __attribute__((format(gnu_printf, 2, 4)));

extern int errhint(const char *fmt,...) __attribute__((format(gnu_printf, 1, 2)));
# 185 "/products1/postgres/PG12.1/include/server/utils/elog.h"
extern int set_errcontext_domain(const char *domain);

extern int errcontext_msg(const char *fmt,...) __attribute__((format(gnu_printf, 1, 2)));

extern int errhidestmt(_Bool hide_stmt);
extern int errhidecontext(_Bool hide_ctx);

extern int errfunction(const char *funcname);
extern int errposition(int cursorpos);

extern int internalerrposition(int cursorpos);
extern int internalerrquery(const char *query);

extern int err_generic_string(int field, const char *str);

extern int geterrcode(void);
extern int geterrposition(void);
extern int getinternalerrposition(void);
# 239 "/products1/postgres/PG12.1/include/server/utils/elog.h"
extern void elog_start(const char *filename, int lineno, const char *funcname);
extern void elog_finish(int elevel, const char *fmt,...) __attribute__((format(gnu_printf, 2, 3)));




extern void pre_format_elog_string(int errnumber, const char *domain);
extern char *format_elog_string(const char *fmt,...) __attribute__((format(gnu_printf, 1, 2)));




typedef struct ErrorContextCallback
{
 struct ErrorContextCallback *previous;
 void (*callback) (void *arg);
 void *arg;
} ErrorContextCallback;

extern ErrorContextCallback *error_context_stack;
# 335 "/products1/postgres/PG12.1/include/server/utils/elog.h"
extern sigjmp_buf *PG_exception_stack;
# 346 "/products1/postgres/PG12.1/include/server/utils/elog.h"
typedef struct ErrorData
{
 int elevel;
 _Bool output_to_server;
 _Bool output_to_client;
 _Bool show_funcname;
 _Bool hide_stmt;
 _Bool hide_ctx;
 const char *filename;
 int lineno;
 const char *funcname;
 const char *domain;
 const char *context_domain;
 int sqlerrcode;
 char *message;
 char *detail;
 char *detail_log;
 char *hint;
 char *context;
 const char *message_id;
 char *schema_name;
 char *table_name;
 char *column_name;
 char *datatype_name;
 char *constraint_name;
 int cursorpos;
 int internalpos;
 char *internalquery;
 int saved_errno;


 struct MemoryContextData *assoc_context;
} ErrorData;

extern void EmitErrorReport(void);
extern ErrorData *CopyErrorData(void);
extern void FreeErrorData(ErrorData *edata);
extern void FlushErrorState(void);
extern void ReThrowError(ErrorData *edata) __attribute__((noreturn));
extern void ThrowErrorData(ErrorData *edata);
extern void pg_re_throw(void) __attribute__((noreturn));

extern char *GetErrorContextStack(void);


typedef void (*emit_log_hook_type) (ErrorData *edata);
extern emit_log_hook_type emit_log_hook;




typedef enum
{
 PGERROR_TERSE,
 PGERROR_DEFAULT,
 PGERROR_VERBOSE
} PGErrorVerbosity;

extern int Log_error_verbosity;
extern char *Log_line_prefix;
extern int Log_destination;
extern char *Log_destination_string;
extern _Bool syslog_sequence_numbers;
extern _Bool syslog_split_messages;
# 418 "/products1/postgres/PG12.1/include/server/utils/elog.h"
extern void DebugFileOpen(void);
extern char *unpack_sql_state(int sql_state);
extern _Bool in_error_recursion_trouble(void);


extern void set_syslog_parameters(const char *ident, int facility);







extern void write_stderr(const char *fmt,...) __attribute__((format(gnu_printf, 1, 2)));
# 48 "/products1/postgres/PG12.1/include/server/postgres.h" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/palloc.h" 1
# 36 "/products1/postgres/PG12.1/include/server/utils/palloc.h"
typedef struct MemoryContextData *MemoryContext;
# 45 "/products1/postgres/PG12.1/include/server/utils/palloc.h"
typedef void (*MemoryContextCallbackFunction) (void *arg);

typedef struct MemoryContextCallback
{
 MemoryContextCallbackFunction func;
 void *arg;
 struct MemoryContextCallback *next;
} MemoryContextCallback;






extern MemoryContext CurrentMemoryContext;
# 71 "/products1/postgres/PG12.1/include/server/utils/palloc.h"
extern void *MemoryContextAlloc(MemoryContext context, Size size);
extern void *MemoryContextAllocZero(MemoryContext context, Size size);
extern void *MemoryContextAllocZeroAligned(MemoryContext context, Size size);
extern void *MemoryContextAllocExtended(MemoryContext context,
          Size size, int flags);

extern void *palloc(Size size);
extern void *palloc0(Size size);
extern void *palloc_extended(Size size, int flags);
extern void *repalloc(void *pointer, Size size);
extern void pfree(void *pointer);
# 97 "/products1/postgres/PG12.1/include/server/utils/palloc.h"
extern void *MemoryContextAllocHuge(MemoryContext context, Size size);
extern void *repalloc_huge(void *pointer, Size size);
# 108 "/products1/postgres/PG12.1/include/server/utils/palloc.h"
static inline MemoryContext
MemoryContextSwitchTo(MemoryContext context)
{
 MemoryContext old = CurrentMemoryContext;

 CurrentMemoryContext = context;
 return old;
}



extern void MemoryContextRegisterResetCallback(MemoryContext context,
              MemoryContextCallback *cb);





extern char *MemoryContextStrdup(MemoryContext context, const char *string);
extern char *pstrdup(const char *in);
extern char *pnstrdup(const char *in, Size len);

extern char *pchomp(const char *in);


extern char *psprintf(const char *fmt,...) __attribute__((format(gnu_printf, 1, 2)));
extern size_t pvsnprintf(char *buf, size_t len, const char *fmt, va_list args) __attribute__((format(gnu_printf, 3, 0)));
# 49 "/products1/postgres/PG12.1/include/server/postgres.h" 2
# 67 "/products1/postgres/PG12.1/include/server/postgres.h"
typedef struct varatt_external
{
 int32 va_rawsize;
 int32 va_extsize;
 Oid va_valueid;
 Oid va_toastrelid;
} varatt_external;
# 84 "/products1/postgres/PG12.1/include/server/postgres.h"
typedef struct varatt_indirect
{
 struct varlena *pointer;
} varatt_indirect;
# 99 "/products1/postgres/PG12.1/include/server/postgres.h"
typedef struct ExpandedObjectHeader ExpandedObjectHeader;

typedef struct varatt_expanded
{
 ExpandedObjectHeader *eohptr;
} varatt_expanded;






typedef enum vartag_external
{
 VARTAG_INDIRECT = 1,
 VARTAG_EXPANDED_RO = 2,
 VARTAG_EXPANDED_RW = 3,
 VARTAG_ONDISK = 18
} vartag_external;
# 138 "/products1/postgres/PG12.1/include/server/postgres.h"
typedef union
{
 struct
 {
  uint32 va_header;
  char va_data[];
 } va_4byte;
 struct
 {
  uint32 va_header;
  uint32 va_rawsize;
  char va_data[];
 } va_compressed;
} varattrib_4b;

typedef struct
{
 uint8 va_header;
 char va_data[];
} varattrib_1b;


typedef struct
{
 uint8 va_header;
 uint8 va_tag;
 char va_data[];
} varattrib_1b_e;
# 367 "/products1/postgres/PG12.1/include/server/postgres.h"
typedef uintptr_t Datum;







typedef struct NullableDatum
{

 Datum value;

 _Bool isnull;

} NullableDatum;
# 667 "/products1/postgres/PG12.1/include/server/postgres.h"
static inline float4
DatumGetFloat4(Datum X)
{
 union
 {
  int32 value;
  float4 retval;
 } myunion;

 myunion.value = ((int32) (X));
 return myunion.retval;
}
# 691 "/products1/postgres/PG12.1/include/server/postgres.h"
static inline Datum
Float4GetDatum(float4 X)
{
 union
 {
  float4 value;
  int32 retval;
 } myunion;

 myunion.value = X;
 return ((Datum) (myunion.retval));
}
# 715 "/products1/postgres/PG12.1/include/server/postgres.h"
static inline float8
DatumGetFloat8(Datum X)
{
 union
 {
  int64 value;
  float8 retval;
 } myunion;

 myunion.value = ((int64) (X));
 return myunion.retval;
}
# 740 "/products1/postgres/PG12.1/include/server/postgres.h"
static inline Datum
Float8GetDatum(float8 X)
{
 union
 {
  float8 value;
  int64 retval;
 } myunion;

 myunion.value = X;
 return ((Datum) (myunion.retval));
}
# 9 "db2_fdw.c" 2

# 1 "/products1/postgres/PG12.1/include/server/fmgr.h" 1
# 22 "/products1/postgres/PG12.1/include/server/fmgr.h"
typedef struct Node *fmNodePtr;
typedef struct Aggref *fmAggrefPtr;


typedef void (*fmExprContextCallbackFunction) (Datum arg);


typedef struct StringInfoData *fmStringInfo;
# 38 "/products1/postgres/PG12.1/include/server/fmgr.h"
typedef struct FunctionCallInfoBaseData *FunctionCallInfo;

typedef Datum (*PGFunction) (FunctionCallInfo fcinfo);
# 56 "/products1/postgres/PG12.1/include/server/fmgr.h"
typedef struct FmgrInfo
{
 PGFunction fn_addr;
 Oid fn_oid;
 short fn_nargs;
 _Bool fn_strict;
 _Bool fn_retset;
 unsigned char fn_stats;
 void *fn_extra;
 MemoryContext fn_mcxt;
 fmNodePtr fn_expr;
} FmgrInfo;
# 85 "/products1/postgres/PG12.1/include/server/fmgr.h"
typedef struct FunctionCallInfoBaseData
{
 FmgrInfo *flinfo;
 fmNodePtr context;
 fmNodePtr resultinfo;
 Oid fncollation;

 _Bool isnull;
 short nargs;

 NullableDatum args[];
} FunctionCallInfoBaseData;
# 124 "/products1/postgres/PG12.1/include/server/fmgr.h"
extern void fmgr_info(Oid functionId, FmgrInfo *finfo);






extern void fmgr_info_cxt(Oid functionId, FmgrInfo *finfo,
        MemoryContext mcxt);
# 141 "/products1/postgres/PG12.1/include/server/fmgr.h"
extern void fmgr_info_copy(FmgrInfo *dstinfo, FmgrInfo *srcinfo,
         MemoryContext destcxt);

extern void fmgr_symbol(Oid functionId, char **mod, char **fn);
# 229 "/products1/postgres/PG12.1/include/server/fmgr.h"
extern struct varlena *pg_detoast_datum(struct varlena *datum);
extern struct varlena *pg_detoast_datum_copy(struct varlena *datum);
extern struct varlena *pg_detoast_datum_slice(struct varlena *datum,
             int32 first, int32 count);
extern struct varlena *pg_detoast_datum_packed(struct varlena *datum);
# 383 "/products1/postgres/PG12.1/include/server/fmgr.h"
typedef struct
{
 int api_version;

} Pg_finfo_record;


typedef const Pg_finfo_record *(*PGFInfoFunction) (void);
# 442 "/products1/postgres/PG12.1/include/server/fmgr.h"
typedef struct
{
 int len;
 int version;
 int funcmaxargs;
 int indexmaxkeys;
 int namedatalen;
 int float4byval;
 int float8byval;
} Pg_magic_struct;
# 469 "/products1/postgres/PG12.1/include/server/fmgr.h"
typedef const Pg_magic_struct *(*PGModuleMagicFunction) (void);
# 494 "/products1/postgres/PG12.1/include/server/fmgr.h"
extern Datum DirectFunctionCall1Coll(PGFunction func, Oid collation,
          Datum arg1);
extern Datum DirectFunctionCall2Coll(PGFunction func, Oid collation,
          Datum arg1, Datum arg2);
extern Datum DirectFunctionCall3Coll(PGFunction func, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3);
extern Datum DirectFunctionCall4Coll(PGFunction func, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4);
extern Datum DirectFunctionCall5Coll(PGFunction func, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5);
extern Datum DirectFunctionCall6Coll(PGFunction func, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6);
extern Datum DirectFunctionCall7Coll(PGFunction func, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6, Datum arg7);
extern Datum DirectFunctionCall8Coll(PGFunction func, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6, Datum arg7, Datum arg8);
extern Datum DirectFunctionCall9Coll(PGFunction func, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6, Datum arg7, Datum arg8,
          Datum arg9);
# 533 "/products1/postgres/PG12.1/include/server/fmgr.h"
extern Datum CallerFInfoFunctionCall1(PGFunction func, FmgrInfo *flinfo,
           Oid collation, Datum arg1);
extern Datum CallerFInfoFunctionCall2(PGFunction func, FmgrInfo *flinfo,
           Oid collation, Datum arg1, Datum arg2);





extern Datum FunctionCall0Coll(FmgrInfo *flinfo, Oid collation);
extern Datum FunctionCall1Coll(FmgrInfo *flinfo, Oid collation,
          Datum arg1);
extern Datum FunctionCall2Coll(FmgrInfo *flinfo, Oid collation,
          Datum arg1, Datum arg2);
extern Datum FunctionCall3Coll(FmgrInfo *flinfo, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3);
extern Datum FunctionCall4Coll(FmgrInfo *flinfo, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4);
extern Datum FunctionCall5Coll(FmgrInfo *flinfo, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5);
extern Datum FunctionCall6Coll(FmgrInfo *flinfo, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6);
extern Datum FunctionCall7Coll(FmgrInfo *flinfo, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6, Datum arg7);
extern Datum FunctionCall8Coll(FmgrInfo *flinfo, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6, Datum arg7, Datum arg8);
extern Datum FunctionCall9Coll(FmgrInfo *flinfo, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6, Datum arg7, Datum arg8,
          Datum arg9);







extern Datum OidFunctionCall0Coll(Oid functionId, Oid collation);
extern Datum OidFunctionCall1Coll(Oid functionId, Oid collation,
          Datum arg1);
extern Datum OidFunctionCall2Coll(Oid functionId, Oid collation,
          Datum arg1, Datum arg2);
extern Datum OidFunctionCall3Coll(Oid functionId, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3);
extern Datum OidFunctionCall4Coll(Oid functionId, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4);
extern Datum OidFunctionCall5Coll(Oid functionId, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5);
extern Datum OidFunctionCall6Coll(Oid functionId, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6);
extern Datum OidFunctionCall7Coll(Oid functionId, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6, Datum arg7);
extern Datum OidFunctionCall8Coll(Oid functionId, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6, Datum arg7, Datum arg8);
extern Datum OidFunctionCall9Coll(Oid functionId, Oid collation,
          Datum arg1, Datum arg2,
          Datum arg3, Datum arg4, Datum arg5,
          Datum arg6, Datum arg7, Datum arg8,
          Datum arg9);
# 675 "/products1/postgres/PG12.1/include/server/fmgr.h"
extern Datum InputFunctionCall(FmgrInfo *flinfo, char *str,
          Oid typioparam, int32 typmod);
extern Datum OidInputFunctionCall(Oid functionId, char *str,
          Oid typioparam, int32 typmod);
extern char *OutputFunctionCall(FmgrInfo *flinfo, Datum val);
extern char *OidOutputFunctionCall(Oid functionId, Datum val);
extern Datum ReceiveFunctionCall(FmgrInfo *flinfo, fmStringInfo buf,
         Oid typioparam, int32 typmod);
extern Datum OidReceiveFunctionCall(Oid functionId, fmStringInfo buf,
         Oid typioparam, int32 typmod);
extern bytea *SendFunctionCall(FmgrInfo *flinfo, Datum val);
extern bytea *OidSendFunctionCall(Oid functionId, Datum val);





extern const Pg_finfo_record *fetch_finfo_record(void *filehandle, const char *funcname);
extern void clear_external_function_hash(void *filehandle);
extern Oid fmgr_internal_function(const char *proname);
extern Oid get_fn_expr_rettype(FmgrInfo *flinfo);
extern Oid get_fn_expr_argtype(FmgrInfo *flinfo, int argnum);
extern Oid get_call_expr_argtype(fmNodePtr expr, int argnum);
extern _Bool get_fn_expr_arg_stable(FmgrInfo *flinfo, int argnum);
extern _Bool get_call_expr_arg_stable(fmNodePtr expr, int argnum);
extern _Bool get_fn_expr_variadic(FmgrInfo *flinfo);
extern _Bool CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid);




extern char *Dynamic_library_path;

extern PGFunction load_external_function(const char *filename, const char *funcname,
           _Bool signalNotFound, void **filehandle);
extern PGFunction lookup_external_function(void *filehandle, const char *funcname);
extern void load_file(const char *filename, _Bool restricted);
extern void **find_rendezvous_variable(const char *varName);
extern Size EstimateLibraryStateSpace(void);
extern void SerializeLibraryState(Size maxsize, char *start_address);
extern void RestoreLibraryState(char *start_address);
# 728 "/products1/postgres/PG12.1/include/server/fmgr.h"
extern int AggCheckCallContext(FunctionCallInfo fcinfo,
        MemoryContext *aggcontext);
extern fmAggrefPtr AggGetAggref(FunctionCallInfo fcinfo);
extern MemoryContext AggGetTempMemoryContext(FunctionCallInfo fcinfo);
extern _Bool AggStateIsShared(FunctionCallInfo fcinfo);
extern void AggRegisterCallback(FunctionCallInfo fcinfo,
        fmExprContextCallbackFunction func,
        Datum arg);
# 746 "/products1/postgres/PG12.1/include/server/fmgr.h"
typedef enum FmgrHookEventType
{
 FHET_START,
 FHET_END,
 FHET_ABORT
} FmgrHookEventType;

typedef _Bool (*needs_fmgr_hook_type) (Oid fn_oid);

typedef void (*fmgr_hook_type) (FmgrHookEventType event,
        FmgrInfo *flinfo, Datum *arg);

extern needs_fmgr_hook_type needs_fmgr_hook;
extern fmgr_hook_type fmgr_hook;
# 11 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/access/htup_details.h" 1
# 17 "/products1/postgres/PG12.1/include/server/access/htup_details.h"
# 1 "/products1/postgres/PG12.1/include/server/access/htup.h" 1
# 17 "/products1/postgres/PG12.1/include/server/access/htup.h"
# 1 "/products1/postgres/PG12.1/include/server/storage/itemptr.h" 1
# 17 "/products1/postgres/PG12.1/include/server/storage/itemptr.h"
# 1 "/products1/postgres/PG12.1/include/server/storage/block.h" 1
# 31 "/products1/postgres/PG12.1/include/server/storage/block.h"
typedef uint32 BlockNumber;
# 53 "/products1/postgres/PG12.1/include/server/storage/block.h"
typedef struct BlockIdData
{
 uint16 bi_hi;
 uint16 bi_lo;
} BlockIdData;

typedef BlockIdData *BlockId;
# 18 "/products1/postgres/PG12.1/include/server/storage/itemptr.h" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/off.h" 1
# 17 "/products1/postgres/PG12.1/include/server/storage/off.h"
# 1 "/products1/postgres/PG12.1/include/server/storage/itemid.h" 1
# 25 "/products1/postgres/PG12.1/include/server/storage/itemid.h"
typedef struct ItemIdData
{
 unsigned lp_off:15,
    lp_flags:2,
    lp_len:15;
} ItemIdData;

typedef ItemIdData *ItemId;
# 47 "/products1/postgres/PG12.1/include/server/storage/itemid.h"
typedef uint16 ItemOffset;
typedef uint16 ItemLength;
# 18 "/products1/postgres/PG12.1/include/server/storage/off.h" 2






typedef uint16 OffsetNumber;
# 19 "/products1/postgres/PG12.1/include/server/storage/itemptr.h" 2
# 36 "/products1/postgres/PG12.1/include/server/storage/itemptr.h"
typedef struct ItemPointerData
{
 BlockIdData ip_blkid;
 OffsetNumber ip_posid;
}



   __attribute__((packed))
   __attribute__((aligned(2)))

ItemPointerData;

typedef ItemPointerData *ItemPointer;
# 203 "/products1/postgres/PG12.1/include/server/storage/itemptr.h"
extern _Bool ItemPointerEquals(ItemPointer pointer1, ItemPointer pointer2);
extern int32 ItemPointerCompare(ItemPointer arg1, ItemPointer arg2);
# 18 "/products1/postgres/PG12.1/include/server/access/htup.h" 2



typedef struct HeapTupleHeaderData HeapTupleHeaderData;

typedef HeapTupleHeaderData *HeapTupleHeader;

typedef struct MinimalTupleData MinimalTupleData;

typedef MinimalTupleData *MinimalTuple;
# 62 "/products1/postgres/PG12.1/include/server/access/htup.h"
typedef struct HeapTupleData
{
 uint32 t_len;
 ItemPointerData t_self;
 Oid t_tableOid;

 HeapTupleHeader t_data;
} HeapTupleData;

typedef HeapTupleData *HeapTuple;
# 81 "/products1/postgres/PG12.1/include/server/access/htup.h"
extern CommandId HeapTupleHeaderGetCmin(HeapTupleHeader tup);
extern CommandId HeapTupleHeaderGetCmax(HeapTupleHeader tup);
extern void HeapTupleHeaderAdjustCmax(HeapTupleHeader tup,
           CommandId *cmax, _Bool *iscombo);


extern TransactionId HeapTupleGetUpdateXid(HeapTupleHeader tuple);
# 18 "/products1/postgres/PG12.1/include/server/access/htup_details.h" 2
# 1 "/products1/postgres/PG12.1/include/server/access/tupdesc.h" 1
# 17 "/products1/postgres/PG12.1/include/server/access/tupdesc.h"
# 1 "/products1/postgres/PG12.1/include/server/access/attnum.h" 1
# 21 "/products1/postgres/PG12.1/include/server/access/attnum.h"
typedef int16 AttrNumber;
# 18 "/products1/postgres/PG12.1/include/server/access/tupdesc.h" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h" 1
# 25 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/genbki.h" 1
# 26 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute_d.h" 1
# 27 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h" 2
# 37 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h"
typedef struct FormData_pg_attribute
{
 Oid attrelid;
 NameData attname;
# 49 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h"
 Oid atttypid;
# 58 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h"
 int32 attstattarget ;





 int16 attlen;
# 79 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h"
 int16 attnum;





 int32 attndims;
# 94 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h"
 int32 attcacheoff ;







 int32 atttypmod ;





 _Bool attbyval;
# 123 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h"
 char attstorage;





 char attalign;


 _Bool attnotnull;


 _Bool atthasdef ;


 _Bool atthasmissing ;


 char attidentity ;


 char attgenerated ;


 _Bool attisdropped ;
# 158 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h"
 _Bool attislocal ;


 int32 attinhcount ;


 Oid attcollation;
# 184 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h"
} FormData_pg_attribute;
# 200 "/products1/postgres/PG12.1/include/server/catalog/pg_attribute.h"
typedef FormData_pg_attribute *Form_pg_attribute;
# 19 "/products1/postgres/PG12.1/include/server/access/tupdesc.h" 2
# 1 "/products1/postgres/PG12.1/include/server/nodes/pg_list.h" 1
# 40 "/products1/postgres/PG12.1/include/server/nodes/pg_list.h"
# 1 "/products1/postgres/PG12.1/include/server/nodes/nodes.h" 1
# 26 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
typedef enum NodeTag
{
 T_Invalid = 0,




 T_IndexInfo,
 T_ExprContext,
 T_ProjectionInfo,
 T_JunkFilter,
 T_OnConflictSetState,
 T_ResultRelInfo,
 T_EState,
 T_TupleTableSlot,




 T_Plan,
 T_Result,
 T_ProjectSet,
 T_ModifyTable,
 T_Append,
 T_MergeAppend,
 T_RecursiveUnion,
 T_BitmapAnd,
 T_BitmapOr,
 T_Scan,
 T_SeqScan,
 T_SampleScan,
 T_IndexScan,
 T_IndexOnlyScan,
 T_BitmapIndexScan,
 T_BitmapHeapScan,
 T_TidScan,
 T_SubqueryScan,
 T_FunctionScan,
 T_ValuesScan,
 T_TableFuncScan,
 T_CteScan,
 T_NamedTuplestoreScan,
 T_WorkTableScan,
 T_ForeignScan,
 T_CustomScan,
 T_Join,
 T_NestLoop,
 T_MergeJoin,
 T_HashJoin,
 T_Material,
 T_Sort,
 T_Group,
 T_Agg,
 T_WindowAgg,
 T_Unique,
 T_Gather,
 T_GatherMerge,
 T_Hash,
 T_SetOp,
 T_LockRows,
 T_Limit,

 T_NestLoopParam,
 T_PlanRowMark,
 T_PartitionPruneInfo,
 T_PartitionedRelPruneInfo,
 T_PartitionPruneStepOp,
 T_PartitionPruneStepCombine,
 T_PlanInvalItem,






 T_PlanState,
 T_ResultState,
 T_ProjectSetState,
 T_ModifyTableState,
 T_AppendState,
 T_MergeAppendState,
 T_RecursiveUnionState,
 T_BitmapAndState,
 T_BitmapOrState,
 T_ScanState,
 T_SeqScanState,
 T_SampleScanState,
 T_IndexScanState,
 T_IndexOnlyScanState,
 T_BitmapIndexScanState,
 T_BitmapHeapScanState,
 T_TidScanState,
 T_SubqueryScanState,
 T_FunctionScanState,
 T_TableFuncScanState,
 T_ValuesScanState,
 T_CteScanState,
 T_NamedTuplestoreScanState,
 T_WorkTableScanState,
 T_ForeignScanState,
 T_CustomScanState,
 T_JoinState,
 T_NestLoopState,
 T_MergeJoinState,
 T_HashJoinState,
 T_MaterialState,
 T_SortState,
 T_GroupState,
 T_AggState,
 T_WindowAggState,
 T_UniqueState,
 T_GatherState,
 T_GatherMergeState,
 T_HashState,
 T_SetOpState,
 T_LockRowsState,
 T_LimitState,




 T_Alias,
 T_RangeVar,
 T_TableFunc,
 T_Expr,
 T_Var,
 T_Const,
 T_Param,
 T_Aggref,
 T_GroupingFunc,
 T_WindowFunc,
 T_SubscriptingRef,
 T_FuncExpr,
 T_NamedArgExpr,
 T_OpExpr,
 T_DistinctExpr,
 T_NullIfExpr,
 T_ScalarArrayOpExpr,
 T_BoolExpr,
 T_SubLink,
 T_SubPlan,
 T_AlternativeSubPlan,
 T_FieldSelect,
 T_FieldStore,
 T_RelabelType,
 T_CoerceViaIO,
 T_ArrayCoerceExpr,
 T_ConvertRowtypeExpr,
 T_CollateExpr,
 T_CaseExpr,
 T_CaseWhen,
 T_CaseTestExpr,
 T_ArrayExpr,
 T_RowExpr,
 T_RowCompareExpr,
 T_CoalesceExpr,
 T_MinMaxExpr,
 T_SQLValueFunction,
 T_XmlExpr,
 T_NullTest,
 T_BooleanTest,
 T_CoerceToDomain,
 T_CoerceToDomainValue,
 T_SetToDefault,
 T_CurrentOfExpr,
 T_NextValueExpr,
 T_InferenceElem,
 T_TargetEntry,
 T_RangeTblRef,
 T_JoinExpr,
 T_FromExpr,
 T_OnConflictExpr,
 T_IntoClause,
# 209 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
 T_ExprState,
 T_AggrefExprState,
 T_WindowFuncExprState,
 T_SetExprState,
 T_SubPlanState,
 T_AlternativeSubPlanState,
 T_DomainConstraintState,




 T_PlannerInfo,
 T_PlannerGlobal,
 T_RelOptInfo,
 T_IndexOptInfo,
 T_ForeignKeyOptInfo,
 T_ParamPathInfo,
 T_Path,
 T_IndexPath,
 T_BitmapHeapPath,
 T_BitmapAndPath,
 T_BitmapOrPath,
 T_TidPath,
 T_SubqueryScanPath,
 T_ForeignPath,
 T_CustomPath,
 T_NestPath,
 T_MergePath,
 T_HashPath,
 T_AppendPath,
 T_MergeAppendPath,
 T_GroupResultPath,
 T_MaterialPath,
 T_UniquePath,
 T_GatherPath,
 T_GatherMergePath,
 T_ProjectionPath,
 T_ProjectSetPath,
 T_SortPath,
 T_GroupPath,
 T_UpperUniquePath,
 T_AggPath,
 T_GroupingSetsPath,
 T_MinMaxAggPath,
 T_WindowAggPath,
 T_SetOpPath,
 T_RecursiveUnionPath,
 T_LockRowsPath,
 T_ModifyTablePath,
 T_LimitPath,

 T_EquivalenceClass,
 T_EquivalenceMember,
 T_PathKey,
 T_PathTarget,
 T_RestrictInfo,
 T_IndexClause,
 T_PlaceHolderVar,
 T_SpecialJoinInfo,
 T_AppendRelInfo,
 T_PlaceHolderInfo,
 T_MinMaxAggInfo,
 T_PlannerParamItem,
 T_RollupData,
 T_GroupingSetData,
 T_StatisticExtInfo,




 T_MemoryContext,
 T_AllocSetContext,
 T_SlabContext,
 T_GenerationContext,




 T_Value,
 T_Integer,
 T_Float,
 T_String,
 T_BitString,
 T_Null,




 T_List,
 T_IntList,
 T_OidList,




 T_ExtensibleNode,




 T_RawStmt,
 T_Query,
 T_PlannedStmt,
 T_InsertStmt,
 T_DeleteStmt,
 T_UpdateStmt,
 T_SelectStmt,
 T_AlterTableStmt,
 T_AlterTableCmd,
 T_AlterDomainStmt,
 T_SetOperationStmt,
 T_GrantStmt,
 T_GrantRoleStmt,
 T_AlterDefaultPrivilegesStmt,
 T_ClosePortalStmt,
 T_ClusterStmt,
 T_CopyStmt,
 T_CreateStmt,
 T_DefineStmt,
 T_DropStmt,
 T_TruncateStmt,
 T_CommentStmt,
 T_FetchStmt,
 T_IndexStmt,
 T_CreateFunctionStmt,
 T_AlterFunctionStmt,
 T_DoStmt,
 T_RenameStmt,
 T_RuleStmt,
 T_NotifyStmt,
 T_ListenStmt,
 T_UnlistenStmt,
 T_TransactionStmt,
 T_ViewStmt,
 T_LoadStmt,
 T_CreateDomainStmt,
 T_CreatedbStmt,
 T_DropdbStmt,
 T_VacuumStmt,
 T_ExplainStmt,
 T_CreateTableAsStmt,
 T_CreateSeqStmt,
 T_AlterSeqStmt,
 T_VariableSetStmt,
 T_VariableShowStmt,
 T_DiscardStmt,
 T_CreateTrigStmt,
 T_CreatePLangStmt,
 T_CreateRoleStmt,
 T_AlterRoleStmt,
 T_DropRoleStmt,
 T_LockStmt,
 T_ConstraintsSetStmt,
 T_ReindexStmt,
 T_CheckPointStmt,
 T_CreateSchemaStmt,
 T_AlterDatabaseStmt,
 T_AlterDatabaseSetStmt,
 T_AlterRoleSetStmt,
 T_CreateConversionStmt,
 T_CreateCastStmt,
 T_CreateOpClassStmt,
 T_CreateOpFamilyStmt,
 T_AlterOpFamilyStmt,
 T_PrepareStmt,
 T_ExecuteStmt,
 T_DeallocateStmt,
 T_DeclareCursorStmt,
 T_CreateTableSpaceStmt,
 T_DropTableSpaceStmt,
 T_AlterObjectDependsStmt,
 T_AlterObjectSchemaStmt,
 T_AlterOwnerStmt,
 T_AlterOperatorStmt,
 T_DropOwnedStmt,
 T_ReassignOwnedStmt,
 T_CompositeTypeStmt,
 T_CreateEnumStmt,
 T_CreateRangeStmt,
 T_AlterEnumStmt,
 T_AlterTSDictionaryStmt,
 T_AlterTSConfigurationStmt,
 T_CreateFdwStmt,
 T_AlterFdwStmt,
 T_CreateForeignServerStmt,
 T_AlterForeignServerStmt,
 T_CreateUserMappingStmt,
 T_AlterUserMappingStmt,
 T_DropUserMappingStmt,
 T_AlterTableSpaceOptionsStmt,
 T_AlterTableMoveAllStmt,
 T_SecLabelStmt,
 T_CreateForeignTableStmt,
 T_ImportForeignSchemaStmt,
 T_CreateExtensionStmt,
 T_AlterExtensionStmt,
 T_AlterExtensionContentsStmt,
 T_CreateEventTrigStmt,
 T_AlterEventTrigStmt,
 T_RefreshMatViewStmt,
 T_ReplicaIdentityStmt,
 T_AlterSystemStmt,
 T_CreatePolicyStmt,
 T_AlterPolicyStmt,
 T_CreateTransformStmt,
 T_CreateAmStmt,
 T_CreatePublicationStmt,
 T_AlterPublicationStmt,
 T_CreateSubscriptionStmt,
 T_AlterSubscriptionStmt,
 T_DropSubscriptionStmt,
 T_CreateStatsStmt,
 T_AlterCollationStmt,
 T_CallStmt,




 T_A_Expr,
 T_ColumnRef,
 T_ParamRef,
 T_A_Const,
 T_FuncCall,
 T_A_Star,
 T_A_Indices,
 T_A_Indirection,
 T_A_ArrayExpr,
 T_ResTarget,
 T_MultiAssignRef,
 T_TypeCast,
 T_CollateClause,
 T_SortBy,
 T_WindowDef,
 T_RangeSubselect,
 T_RangeFunction,
 T_RangeTableSample,
 T_RangeTableFunc,
 T_RangeTableFuncCol,
 T_TypeName,
 T_ColumnDef,
 T_IndexElem,
 T_Constraint,
 T_DefElem,
 T_RangeTblEntry,
 T_RangeTblFunction,
 T_TableSampleClause,
 T_WithCheckOption,
 T_SortGroupClause,
 T_GroupingSet,
 T_WindowClause,
 T_ObjectWithArgs,
 T_AccessPriv,
 T_CreateOpClassItem,
 T_TableLikeClause,
 T_FunctionParameter,
 T_LockingClause,
 T_RowMarkClause,
 T_XmlSerialize,
 T_WithClause,
 T_InferClause,
 T_OnConflictClause,
 T_CommonTableExpr,
 T_RoleSpec,
 T_TriggerTransition,
 T_PartitionElem,
 T_PartitionSpec,
 T_PartitionBoundSpec,
 T_PartitionRangeDatum,
 T_PartitionCmd,
 T_VacuumRelation,




 T_IdentifySystemCmd,
 T_BaseBackupCmd,
 T_CreateReplicationSlotCmd,
 T_DropReplicationSlotCmd,
 T_StartReplicationCmd,
 T_TimeLineHistoryCmd,
 T_SQLCmd,
# 499 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
 T_TriggerData,
 T_EventTriggerData,
 T_ReturnSetInfo,
 T_WindowObjectData,
 T_TIDBitmap,
 T_InlineCodeBlock,
 T_FdwRoutine,
 T_IndexAmRoutine,
 T_TableAmRoutine,
 T_TsmRoutine,
 T_ForeignKeyCacheInfo,
 T_CallContext,
 T_SupportRequestSimplify,
 T_SupportRequestSelectivity,
 T_SupportRequestCost,
 T_SupportRequestRows,
 T_SupportRequestIndexCondition
} NodeTag;







typedef struct Node
{
 NodeTag type;
} Node;
# 605 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
struct Bitmapset;
struct StringInfoData;

extern void outNode(struct StringInfoData *str, const void *obj);
extern void outToken(struct StringInfoData *str, const char *s);
extern void outBitmapset(struct StringInfoData *str,
       const struct Bitmapset *bms);
extern void outDatum(struct StringInfoData *str, uintptr_t value,
      int typlen, _Bool typbyval);
extern char *nodeToString(const void *obj);
extern char *bmsToString(const struct Bitmapset *bms);




extern void *stringToNode(const char *str);



extern struct Bitmapset *readBitmapset(void);
extern uintptr_t readDatum(_Bool typbyval);
extern _Bool *readBoolCols(int numCols);
extern int *readIntCols(int numCols);
extern Oid *readOidCols(int numCols);
extern int16 *readAttrNumberCols(int numCols);




extern void *copyObjectImpl(const void *obj);
# 646 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
extern _Bool equal(const void *a, const void *b);
# 657 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
typedef double Selectivity;
typedef double Cost;
# 667 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
typedef enum CmdType
{
 CMD_UNKNOWN,
 CMD_SELECT,
 CMD_UPDATE,
 CMD_INSERT,
 CMD_DELETE,
 CMD_UTILITY,

 CMD_NOTHING

} CmdType;
# 691 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
typedef enum JoinType
{




 JOIN_INNER,
 JOIN_LEFT,
 JOIN_FULL,
 JOIN_RIGHT,
# 711 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
 JOIN_SEMI,
 JOIN_ANTI,





 JOIN_UNIQUE_OUTER,
 JOIN_UNIQUE_INNER




} JoinType;
# 753 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
typedef enum AggStrategy
{
 AGG_PLAIN,
 AGG_SORTED,
 AGG_HASHED,
 AGG_MIXED
} AggStrategy;
# 775 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
typedef enum AggSplit
{

 AGGSPLIT_SIMPLE = 0,

 AGGSPLIT_INITIAL_SERIAL = 0x02 | 0x04,

 AGGSPLIT_FINAL_DESERIAL = 0x01 | 0x08
} AggSplit;
# 797 "/products1/postgres/PG12.1/include/server/nodes/nodes.h"
typedef enum SetOpCmd
{
 SETOPCMD_INTERSECT,
 SETOPCMD_INTERSECT_ALL,
 SETOPCMD_EXCEPT,
 SETOPCMD_EXCEPT_ALL
} SetOpCmd;

typedef enum SetOpStrategy
{
 SETOP_SORTED,
 SETOP_HASHED
} SetOpStrategy;







typedef enum OnConflictAction
{
 ONCONFLICT_NONE,
 ONCONFLICT_NOTHING,
 ONCONFLICT_UPDATE
} OnConflictAction;
# 41 "/products1/postgres/PG12.1/include/server/nodes/pg_list.h" 2


typedef struct ListCell ListCell;

typedef struct List
{
 NodeTag type;
 int length;
 ListCell *head;
 ListCell *tail;
} List;

struct ListCell
{
 union
 {
  void *ptr_value;
  int int_value;
  Oid oid_value;
 } data;
 ListCell *next;
};
# 76 "/products1/postgres/PG12.1/include/server/nodes/pg_list.h"
static inline ListCell *
list_head(const List *l)
{
 return l ? l->head : ((void *)0);
}

static inline ListCell *
list_tail(List *l)
{
 return l ? l->tail : ((void *)0);
}

static inline int
list_length(const List *l)
{
 return l ? l->length : 0;
}
# 234 "/products1/postgres/PG12.1/include/server/nodes/pg_list.h"
extern List *lappend(List *list, void *datum);
extern List *lappend_int(List *list, int datum);
extern List *lappend_oid(List *list, Oid datum);

extern ListCell *lappend_cell(List *list, ListCell *prev, void *datum);
extern ListCell *lappend_cell_int(List *list, ListCell *prev, int datum);
extern ListCell *lappend_cell_oid(List *list, ListCell *prev, Oid datum);

extern List *lcons(void *datum, List *list);
extern List *lcons_int(int datum, List *list);
extern List *lcons_oid(Oid datum, List *list);

extern List *list_concat(List *list1, List *list2);
extern List *list_truncate(List *list, int new_size);

extern ListCell *list_nth_cell(const List *list, int n);
extern void *list_nth(const List *list, int n);
extern int list_nth_int(const List *list, int n);
extern Oid list_nth_oid(const List *list, int n);


extern _Bool list_member(const List *list, const void *datum);
extern _Bool list_member_ptr(const List *list, const void *datum);
extern _Bool list_member_int(const List *list, int datum);
extern _Bool list_member_oid(const List *list, Oid datum);

extern List *list_delete(List *list, void *datum);
extern List *list_delete_ptr(List *list, void *datum);
extern List *list_delete_int(List *list, int datum);
extern List *list_delete_oid(List *list, Oid datum);
extern List *list_delete_first(List *list);
extern List *list_delete_cell(List *list, ListCell *cell, ListCell *prev);

extern List *list_union(const List *list1, const List *list2);
extern List *list_union_ptr(const List *list1, const List *list2);
extern List *list_union_int(const List *list1, const List *list2);
extern List *list_union_oid(const List *list1, const List *list2);

extern List *list_intersection(const List *list1, const List *list2);
extern List *list_intersection_int(const List *list1, const List *list2);



extern List *list_difference(const List *list1, const List *list2);
extern List *list_difference_ptr(const List *list1, const List *list2);
extern List *list_difference_int(const List *list1, const List *list2);
extern List *list_difference_oid(const List *list1, const List *list2);

extern List *list_append_unique(List *list, void *datum);
extern List *list_append_unique_ptr(List *list, void *datum);
extern List *list_append_unique_int(List *list, int datum);
extern List *list_append_unique_oid(List *list, Oid datum);

extern List *list_concat_unique(List *list1, List *list2);
extern List *list_concat_unique_ptr(List *list1, List *list2);
extern List *list_concat_unique_int(List *list1, List *list2);
extern List *list_concat_unique_oid(List *list1, List *list2);

extern void list_free(List *list);
extern void list_free_deep(List *list);

extern List *list_copy(const List *list);
extern List *list_copy_tail(const List *list, int nskip);

typedef int (*list_qsort_comparator) (const void *a, const void *b);
extern List *list_qsort(const List *list, list_qsort_comparator cmp);
# 20 "/products1/postgres/PG12.1/include/server/access/tupdesc.h" 2


typedef struct AttrDefault
{
 AttrNumber adnum;
 char *adbin;
} AttrDefault;

typedef struct ConstrCheck
{
 char *ccname;
 char *ccbin;
 _Bool ccvalid;
 _Bool ccnoinherit;
} ConstrCheck;


typedef struct TupleConstr
{
 AttrDefault *defval;
 ConstrCheck *check;
 struct AttrMissing *missing;
 uint16 num_defval;
 uint16 num_check;
 _Bool has_not_null;
 _Bool has_generated_stored;
} TupleConstr;
# 79 "/products1/postgres/PG12.1/include/server/access/tupdesc.h"
typedef struct TupleDescData
{
 int natts;
 Oid tdtypeid;
 int32 tdtypmod;
 int tdrefcount;
 TupleConstr *constr;

 FormData_pg_attribute attrs[];
} TupleDescData;
typedef struct TupleDescData *TupleDesc;




extern TupleDesc CreateTemplateTupleDesc(int natts);

extern TupleDesc CreateTupleDesc(int natts, Form_pg_attribute *attrs);

extern TupleDesc CreateTupleDescCopy(TupleDesc tupdesc);

extern TupleDesc CreateTupleDescCopyConstr(TupleDesc tupdesc);





extern void TupleDescCopy(TupleDesc dst, TupleDesc src);

extern void TupleDescCopyEntry(TupleDesc dst, AttrNumber dstAttno,
          TupleDesc src, AttrNumber srcAttno);

extern void FreeTupleDesc(TupleDesc tupdesc);

extern void IncrTupleDescRefCount(TupleDesc tupdesc);
extern void DecrTupleDescRefCount(TupleDesc tupdesc);
# 128 "/products1/postgres/PG12.1/include/server/access/tupdesc.h"
extern _Bool equalTupleDescs(TupleDesc tupdesc1, TupleDesc tupdesc2);

extern uint32 hashTupleDesc(TupleDesc tupdesc);

extern void TupleDescInitEntry(TupleDesc desc,
          AttrNumber attributeNumber,
          const char *attributeName,
          Oid oidtypeid,
          int32 typmod,
          int attdim);

extern void TupleDescInitBuiltinEntry(TupleDesc desc,
           AttrNumber attributeNumber,
           const char *attributeName,
           Oid oidtypeid,
           int32 typmod,
           int attdim);

extern void TupleDescInitEntryCollation(TupleDesc desc,
          AttrNumber attributeNumber,
          Oid collationid);

extern TupleDesc BuildDescForRelation(List *schema);

extern TupleDesc BuildDescFromLists(List *names, List *types, List *typmods, List *collations);
# 19 "/products1/postgres/PG12.1/include/server/access/htup_details.h" 2
# 1 "/products1/postgres/PG12.1/include/server/access/tupmacs.h" 1
# 20 "/products1/postgres/PG12.1/include/server/access/htup_details.h" 2
# 1 "/products1/postgres/PG12.1/include/server/access/transam.h" 1
# 17 "/products1/postgres/PG12.1/include/server/access/transam.h"
# 1 "/products1/postgres/PG12.1/include/server/access/xlogdefs.h" 1
# 15 "/products1/postgres/PG12.1/include/server/access/xlogdefs.h"
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/bits/fcntl.h" 1 3 4
# 35 "/usr/include/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/bits/uio.h" 1 3 4
# 39 "/usr/include/bits/fcntl-linux.h" 2 3 4
# 260 "/usr/include/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 323 "/usr/include/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 324 "/usr/include/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};










extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
    size_t __count, unsigned int __flags);





extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
         __off64_t *__offout, size_t __len,
         unsigned int __flags);





extern ssize_t tee (int __fdin, int __fdout, size_t __len,
      unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 394 "/usr/include/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 61 "/usr/include/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 76 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 77 "/usr/include/fcntl.h" 2 3 4
# 1 "/usr/include/bits/stat.h" 1 3 4
# 46 "/usr/include/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/bits/stat.h" 3 4
    __syscall_slong_t __unused[3];
# 115 "/usr/include/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/bits/stat.h" 3 4
    __syscall_slong_t __unused[3];



  };
# 78 "/usr/include/fcntl.h" 2 3 4
# 163 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 173 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 183 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 197 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 208 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 219 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 229 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 248 "/usr/include/fcntl.h" 3 4
extern int lockf (int __fd, int __cmd, off_t __len);
# 257 "/usr/include/fcntl.h" 3 4
extern int lockf64 (int __fd, int __cmd, off64_t __len);







extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 277 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 287 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 298 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 309 "/usr/include/fcntl.h" 3 4

# 16 "/products1/postgres/PG12.1/include/server/access/xlogdefs.h" 2





typedef uint64 XLogRecPtr;
# 41 "/products1/postgres/PG12.1/include/server/access/xlogdefs.h"
typedef uint64 XLogSegNo;
# 52 "/products1/postgres/PG12.1/include/server/access/xlogdefs.h"
typedef uint32 TimeLineID;





typedef uint16 RepOriginId;
# 18 "/products1/postgres/PG12.1/include/server/access/transam.h" 2
# 59 "/products1/postgres/PG12.1/include/server/access/transam.h"
typedef struct FullTransactionId
{
 uint64 value;
} FullTransactionId;

static inline FullTransactionId
FullTransactionIdFromEpochAndXid(uint32 epoch, TransactionId xid)
{
 FullTransactionId result;

 result.value = ((uint64) epoch) << 32 | xid;

 return result;
}
# 83 "/products1/postgres/PG12.1/include/server/access/transam.h"
static inline void
FullTransactionIdAdvance(FullTransactionId *dest)
{
 dest->value++;
 while (((uint32) (*dest).value) < ((TransactionId) 3))
  dest->value++;
}
# 153 "/products1/postgres/PG12.1/include/server/access/transam.h"
typedef struct VariableCacheData
{



 Oid nextOid;
 uint32 oidCount;




 FullTransactionId nextFullXid;

 TransactionId oldestXid;
 TransactionId xidVacLimit;
 TransactionId xidWarnLimit;
 TransactionId xidStopLimit;
 TransactionId xidWrapLimit;
 Oid oldestXidDB;




 TransactionId oldestCommitTsXid;
 TransactionId newestCommitTsXid;




 TransactionId latestCompletedXid;





 TransactionId oldestClogXid;

} VariableCacheData;

typedef VariableCacheData *VariableCache;
# 201 "/products1/postgres/PG12.1/include/server/access/transam.h"
extern _Bool TransactionStartedDuringRecovery(void);


extern VariableCache ShmemVariableCache;




extern _Bool TransactionIdDidCommit(TransactionId transactionId);
extern _Bool TransactionIdDidAbort(TransactionId transactionId);
extern _Bool TransactionIdIsKnownCompleted(TransactionId transactionId);
extern void TransactionIdAbort(TransactionId transactionId);
extern void TransactionIdCommitTree(TransactionId xid, int nxids, TransactionId *xids);
extern void TransactionIdAsyncCommitTree(TransactionId xid, int nxids, TransactionId *xids, XLogRecPtr lsn);
extern void TransactionIdAbortTree(TransactionId xid, int nxids, TransactionId *xids);
extern _Bool TransactionIdPrecedes(TransactionId id1, TransactionId id2);
extern _Bool TransactionIdPrecedesOrEquals(TransactionId id1, TransactionId id2);
extern _Bool TransactionIdFollows(TransactionId id1, TransactionId id2);
extern _Bool TransactionIdFollowsOrEquals(TransactionId id1, TransactionId id2);
extern TransactionId TransactionIdLatest(TransactionId mainxid,
           int nxids, const TransactionId *xids);
extern XLogRecPtr TransactionIdGetCommitLSN(TransactionId xid);


extern FullTransactionId GetNewTransactionId(_Bool isSubXact);
extern void AdvanceNextFullTransactionIdPastXid(TransactionId xid);
extern FullTransactionId ReadNextFullTransactionId(void);
extern void SetTransactionIdLimit(TransactionId oldest_datfrozenxid,
          Oid oldest_datoid);
extern void AdvanceOldestClogXid(TransactionId oldest_datfrozenxid);
extern _Bool ForceTransactionIdLimitUpdate(void);
extern Oid GetNewObjectId(void);
# 244 "/products1/postgres/PG12.1/include/server/access/transam.h"
static inline TransactionId
ReadNewTransactionId(void)
{
 return ((uint32) (ReadNextFullTransactionId()).value);
}
# 21 "/products1/postgres/PG12.1/include/server/access/htup_details.h" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/bufpage.h" 1
# 19 "/products1/postgres/PG12.1/include/server/storage/bufpage.h"
# 1 "/products1/postgres/PG12.1/include/server/storage/item.h" 1
# 17 "/products1/postgres/PG12.1/include/server/storage/item.h"
typedef Pointer Item;
# 20 "/products1/postgres/PG12.1/include/server/storage/bufpage.h" 2
# 78 "/products1/postgres/PG12.1/include/server/storage/bufpage.h"
typedef Pointer Page;
# 87 "/products1/postgres/PG12.1/include/server/storage/bufpage.h"
typedef uint16 LocationIndex;






typedef struct
{
 uint32 xlogid;
 uint32 xrecoff;
} PageXLogRecPtr;
# 151 "/products1/postgres/PG12.1/include/server/storage/bufpage.h"
typedef struct PageHeaderData
{

 PageXLogRecPtr pd_lsn;

 uint16 pd_checksum;
 uint16 pd_flags;
 LocationIndex pd_lower;
 LocationIndex pd_upper;
 LocationIndex pd_special;
 uint16 pd_pagesize_version;
 TransactionId pd_prune_xid;
 ItemIdData pd_linp[];
} PageHeaderData;

typedef PageHeaderData *PageHeader;
# 312 "/products1/postgres/PG12.1/include/server/storage/bufpage.h"
static inline _Bool
PageValidateSpecialPointer(Page page)
{
 ((void)1);
 ((void)1);
 ((void)1);

 return 1;
}
# 421 "/products1/postgres/PG12.1/include/server/storage/bufpage.h"
extern void PageInit(Page page, Size pageSize, Size specialSize);
extern _Bool PageIsVerified(Page page, BlockNumber blkno);
extern OffsetNumber PageAddItemExtended(Page page, Item item, Size size,
          OffsetNumber offsetNumber, int flags);
extern Page PageGetTempPage(Page page);
extern Page PageGetTempPageCopy(Page page);
extern Page PageGetTempPageCopySpecial(Page page);
extern void PageRestoreTempPage(Page tempPage, Page oldPage);
extern void PageRepairFragmentation(Page page);
extern Size PageGetFreeSpace(Page page);
extern Size PageGetFreeSpaceForMultipleTuples(Page page, int ntups);
extern Size PageGetExactFreeSpace(Page page);
extern Size PageGetHeapFreeSpace(Page page);
extern void PageIndexTupleDelete(Page page, OffsetNumber offset);
extern void PageIndexMultiDelete(Page page, OffsetNumber *itemnos, int nitems);
extern void PageIndexTupleDeleteNoCompact(Page page, OffsetNumber offset);
extern _Bool PageIndexTupleOverwrite(Page page, OffsetNumber offnum,
         Item newtup, Size newsize);
extern char *PageSetChecksumCopy(Page page, BlockNumber blkno);
extern void PageSetChecksumInplace(Page page, BlockNumber blkno);
# 22 "/products1/postgres/PG12.1/include/server/access/htup_details.h" 2
# 121 "/products1/postgres/PG12.1/include/server/access/htup_details.h"
typedef struct HeapTupleFields
{
 TransactionId t_xmin;
 TransactionId t_xmax;

 union
 {
  CommandId t_cid;
  TransactionId t_xvac;
 } t_field3;
} HeapTupleFields;

typedef struct DatumTupleFields
{
 int32 datum_len_;

 int32 datum_typmod;

 Oid datum_typeid;
# 150 "/products1/postgres/PG12.1/include/server/access/htup_details.h"
} DatumTupleFields;

struct HeapTupleHeaderData
{
 union
 {
  HeapTupleFields t_heap;
  DatumTupleFields t_datum;
 } t_choice;

 ItemPointerData t_ctid;





 uint16 t_infomask2;


 uint16 t_infomask;


 uint8 t_hoff;




 bits8 t_bits[];


};
# 626 "/products1/postgres/PG12.1/include/server/access/htup_details.h"
struct MinimalTupleData
{
 uint32 t_len;

 char mt_padding[((__builtin_offsetof (HeapTupleHeaderData, t_infomask2) - sizeof(uint32)) % 8)];



 uint16 t_infomask2;

 uint16 t_infomask;

 uint8 t_hoff;



 bits8 t_bits[];


};
# 777 "/products1/postgres/PG12.1/include/server/access/htup_details.h"
extern Size heap_compute_data_size(TupleDesc tupleDesc,
           Datum *values, _Bool *isnull);
extern void heap_fill_tuple(TupleDesc tupleDesc,
       Datum *values, _Bool *isnull,
       char *data, Size data_size,
       uint16 *infomask, bits8 *bit);
extern _Bool heap_attisnull(HeapTuple tup, int attnum, TupleDesc tupleDesc);
extern Datum nocachegetattr(HeapTuple tup, int attnum,
       TupleDesc att);
extern Datum heap_getsysattr(HeapTuple tup, int attnum, TupleDesc tupleDesc,
        _Bool *isnull);
extern Datum getmissingattr(TupleDesc tupleDesc,
       int attnum, _Bool *isnull);
extern HeapTuple heap_copytuple(HeapTuple tuple);
extern void heap_copytuple_with_tuple(HeapTuple src, HeapTuple dest);
extern Datum heap_copy_tuple_as_datum(HeapTuple tuple, TupleDesc tupleDesc);
extern HeapTuple heap_form_tuple(TupleDesc tupleDescriptor,
         Datum *values, _Bool *isnull);
extern HeapTuple heap_modify_tuple(HeapTuple tuple,
           TupleDesc tupleDesc,
           Datum *replValues,
           _Bool *replIsnull,
           _Bool *doReplace);
extern HeapTuple heap_modify_tuple_by_cols(HeapTuple tuple,
             TupleDesc tupleDesc,
             int nCols,
             int *replCols,
             Datum *replValues,
             _Bool *replIsnull);
extern void heap_deform_tuple(HeapTuple tuple, TupleDesc tupleDesc,
         Datum *values, _Bool *isnull);
extern void heap_freetuple(HeapTuple htup);
extern MinimalTuple heap_form_minimal_tuple(TupleDesc tupleDescriptor,
           Datum *values, _Bool *isnull);
extern void heap_free_minimal_tuple(MinimalTuple mtup);
extern MinimalTuple heap_copy_minimal_tuple(MinimalTuple mtup);
extern HeapTuple heap_tuple_from_minimal_tuple(MinimalTuple mtup);
extern MinimalTuple minimal_tuple_from_heap_tuple(HeapTuple htup);
extern size_t varsize_any(void *p);
extern HeapTuple heap_expand_tuple(HeapTuple sourceTuple, TupleDesc tupleDesc);
extern MinimalTuple minimal_expand_tuple(HeapTuple sourceTuple, TupleDesc tupleDesc);
# 12 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/access/reloptions.h" 1
# 22 "/products1/postgres/PG12.1/include/server/access/reloptions.h"
# 1 "/products1/postgres/PG12.1/include/server/access/amapi.h" 1
# 15 "/products1/postgres/PG12.1/include/server/access/amapi.h"
# 1 "/products1/postgres/PG12.1/include/server/access/genam.h" 1
# 17 "/products1/postgres/PG12.1/include/server/access/genam.h"
# 1 "/products1/postgres/PG12.1/include/server/access/sdir.h" 1
# 22 "/products1/postgres/PG12.1/include/server/access/sdir.h"
typedef enum ScanDirection
{
 BackwardScanDirection = -1,
 NoMovementScanDirection = 0,
 ForwardScanDirection = 1
} ScanDirection;
# 18 "/products1/postgres/PG12.1/include/server/access/genam.h" 2
# 1 "/products1/postgres/PG12.1/include/server/access/skey.h" 1
# 18 "/products1/postgres/PG12.1/include/server/access/skey.h"
# 1 "/products1/postgres/PG12.1/include/server/access/stratnum.h" 1
# 22 "/products1/postgres/PG12.1/include/server/access/stratnum.h"
typedef uint16 StrategyNumber;
# 19 "/products1/postgres/PG12.1/include/server/access/skey.h" 2
# 64 "/products1/postgres/PG12.1/include/server/access/skey.h"
typedef struct ScanKeyData
{
 int sk_flags;
 AttrNumber sk_attno;
 StrategyNumber sk_strategy;
 Oid sk_subtype;
 Oid sk_collation;
 FmgrInfo sk_func;
 Datum sk_argument;
} ScanKeyData;

typedef ScanKeyData *ScanKey;
# 129 "/products1/postgres/PG12.1/include/server/access/skey.h"
extern void ScanKeyInit(ScanKey entry,
      AttrNumber attributeNumber,
      StrategyNumber strategy,
      RegProcedure procedure,
      Datum argument);
extern void ScanKeyEntryInitialize(ScanKey entry,
           int flags,
           AttrNumber attributeNumber,
           StrategyNumber strategy,
           Oid subtype,
           Oid collation,
           RegProcedure procedure,
           Datum argument);
extern void ScanKeyEntryInitializeWithInfo(ScanKey entry,
             int flags,
             AttrNumber attributeNumber,
             StrategyNumber strategy,
             Oid subtype,
             Oid collation,
             FmgrInfo *finfo,
             Datum argument);
# 19 "/products1/postgres/PG12.1/include/server/access/genam.h" 2
# 1 "/products1/postgres/PG12.1/include/server/nodes/tidbitmap.h" 1
# 26 "/products1/postgres/PG12.1/include/server/nodes/tidbitmap.h"
# 1 "/products1/postgres/PG12.1/include/server/utils/dsa.h" 1
# 17 "/products1/postgres/PG12.1/include/server/utils/dsa.h"
# 1 "/products1/postgres/PG12.1/include/server/port/atomics.h" 1
# 47 "/products1/postgres/PG12.1/include/server/port/atomics.h"
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/limits.h" 1 3 4
# 168 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 144 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 38 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 2 3 4
# 161 "/usr/include/bits/posix1_lim.h" 2 3 4
# 145 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 149 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 33 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 2 3 4
# 153 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/limits.h" 2 3 4
# 48 "/products1/postgres/PG12.1/include/server/port/atomics.h" 2
# 70 "/products1/postgres/PG12.1/include/server/port/atomics.h"
# 1 "/products1/postgres/PG12.1/include/server/port/atomics/arch-x86.h" 1
# 57 "/products1/postgres/PG12.1/include/server/port/atomics/arch-x86.h"
typedef struct pg_atomic_flag
{
 volatile char value;
} pg_atomic_flag;


typedef struct pg_atomic_uint32
{
 volatile uint32 value;
} pg_atomic_uint32;







typedef struct pg_atomic_uint64
{

 volatile uint64 value;
} pg_atomic_uint64;
# 111 "/products1/postgres/PG12.1/include/server/port/atomics/arch-x86.h"
static __inline__ void
pg_spin_delay_impl(void)
{
 __asm__ __volatile__(" rep; nop			\n");
}
# 140 "/products1/postgres/PG12.1/include/server/port/atomics/arch-x86.h"
static inline _Bool
pg_atomic_test_set_flag_impl(volatile pg_atomic_flag *ptr)
{
 register char _res = 1;

 __asm__ __volatile__(
  "	lock			\n"
  "	xchgb	%0,%1	\n"
: "+q"(_res), "+m"(ptr->value)
:
: "memory");
 return _res == 0;
}


static inline void
pg_atomic_clear_flag_impl(volatile pg_atomic_flag *ptr)
{




 __asm__ __volatile__("" ::: "memory");
 ptr->value = 0;
}


static inline _Bool
pg_atomic_compare_exchange_u32_impl(volatile pg_atomic_uint32 *ptr,
         uint32 *expected, uint32 newval)
{
 char ret;





 __asm__ __volatile__(
  "	lock				\n"
  "	cmpxchgl	%4,%5	\n"
  "   setz		%2		\n"
: "=a" (*expected), "=m"(ptr->value), "=q" (ret)
: "a" (*expected), "r" (newval), "m"(ptr->value)
: "memory", "cc");
 return (_Bool) ret;
}


static inline uint32
pg_atomic_fetch_add_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
{
 uint32 res;
 __asm__ __volatile__(
  "	lock				\n"
  "	xaddl	%0,%1		\n"
: "=q"(res), "=m"(ptr->value)
: "0" (add_), "m"(ptr->value)
: "memory", "cc");
 return res;
}




static inline _Bool
pg_atomic_compare_exchange_u64_impl(volatile pg_atomic_uint64 *ptr,
         uint64 *expected, uint64 newval)
{
 char ret;





 __asm__ __volatile__(
  "	lock				\n"
  "	cmpxchgq	%4,%5	\n"
  "   setz		%2		\n"
: "=a" (*expected), "=m"(ptr->value), "=q" (ret)
: "a" (*expected), "r" (newval), "m"(ptr->value)
: "memory", "cc");
 return (_Bool) ret;
}


static inline uint64
pg_atomic_fetch_add_u64_impl(volatile pg_atomic_uint64 *ptr, int64 add_)
{
 uint64 res;
 __asm__ __volatile__(
  "	lock				\n"
  "	xaddq	%0,%1		\n"
: "=q"(res), "=m"(ptr->value)
: "0" (add_), "m"(ptr->value)
: "memory", "cc");
 return res;
}
# 71 "/products1/postgres/PG12.1/include/server/port/atomics.h" 2
# 98 "/products1/postgres/PG12.1/include/server/port/atomics.h"
# 1 "/products1/postgres/PG12.1/include/server/port/atomics/generic-gcc.h" 1
# 124 "/products1/postgres/PG12.1/include/server/port/atomics/generic-gcc.h"
static inline _Bool
pg_atomic_unlocked_test_flag_impl(volatile pg_atomic_flag *ptr)
{
 return ptr->value == 0;
}
# 142 "/products1/postgres/PG12.1/include/server/port/atomics/generic-gcc.h"
static inline void
pg_atomic_init_flag_impl(volatile pg_atomic_flag *ptr)
{
 pg_atomic_clear_flag_impl(ptr);
}
# 192 "/products1/postgres/PG12.1/include/server/port/atomics/generic-gcc.h"
static inline uint32
pg_atomic_fetch_sub_u32_impl(volatile pg_atomic_uint32 *ptr, int32 sub_)
{
 return __sync_fetch_and_sub(&ptr->value, sub_);
}




static inline uint32
pg_atomic_fetch_and_u32_impl(volatile pg_atomic_uint32 *ptr, uint32 and_)
{
 return __sync_fetch_and_and(&ptr->value, and_);
}




static inline uint32
pg_atomic_fetch_or_u32_impl(volatile pg_atomic_uint32 *ptr, uint32 or_)
{
 return __sync_fetch_and_or(&ptr->value, or_);
}
# 259 "/products1/postgres/PG12.1/include/server/port/atomics/generic-gcc.h"
static inline uint64
pg_atomic_fetch_sub_u64_impl(volatile pg_atomic_uint64 *ptr, int64 sub_)
{
 return __sync_fetch_and_sub(&ptr->value, sub_);
}




static inline uint64
pg_atomic_fetch_and_u64_impl(volatile pg_atomic_uint64 *ptr, uint64 and_)
{
 return __sync_fetch_and_and(&ptr->value, and_);
}




static inline uint64
pg_atomic_fetch_or_u64_impl(volatile pg_atomic_uint64 *ptr, uint64 or_)
{
 return __sync_fetch_and_or(&ptr->value, or_);
}
# 99 "/products1/postgres/PG12.1/include/server/port/atomics.h" 2
# 118 "/products1/postgres/PG12.1/include/server/port/atomics.h"
# 1 "/products1/postgres/PG12.1/include/server/port/atomics/fallback.h" 1
# 119 "/products1/postgres/PG12.1/include/server/port/atomics.h" 2





# 1 "/products1/postgres/PG12.1/include/server/port/atomics/generic.h" 1
# 45 "/products1/postgres/PG12.1/include/server/port/atomics/generic.h"
static inline uint32
pg_atomic_read_u32_impl(volatile pg_atomic_uint32 *ptr)
{
 return ptr->value;
}




static inline void
pg_atomic_write_u32_impl(volatile pg_atomic_uint32 *ptr, uint32 val)
{
 ptr->value = val;
}




static inline void
pg_atomic_unlocked_write_u32_impl(volatile pg_atomic_uint32 *ptr, uint32 val)
{
 ptr->value = val;
}
# 160 "/products1/postgres/PG12.1/include/server/port/atomics/generic.h"
static inline void
pg_atomic_init_u32_impl(volatile pg_atomic_uint32 *ptr, uint32 val_)
{
 pg_atomic_write_u32_impl(ptr, val_);
}




static inline uint32
pg_atomic_exchange_u32_impl(volatile pg_atomic_uint32 *ptr, uint32 xchg_)
{
 uint32 old;
 old = ptr->value;
 while (!pg_atomic_compare_exchange_u32_impl(ptr, &old, xchg_))
            ;
 return old;
}
# 230 "/products1/postgres/PG12.1/include/server/port/atomics/generic.h"
static inline uint32
pg_atomic_add_fetch_u32_impl(volatile pg_atomic_uint32 *ptr, int32 add_)
{
 return pg_atomic_fetch_add_u32_impl(ptr, add_) + add_;
}




static inline uint32
pg_atomic_sub_fetch_u32_impl(volatile pg_atomic_uint32 *ptr, int32 sub_)
{
 return pg_atomic_fetch_sub_u32_impl(ptr, sub_) - sub_;
}




static inline uint64
pg_atomic_exchange_u64_impl(volatile pg_atomic_uint64 *ptr, uint64 xchg_)
{
 uint64 old;
 old = ptr->value;
 while (!pg_atomic_compare_exchange_u64_impl(ptr, &old, xchg_))
            ;
 return old;
}
# 265 "/products1/postgres/PG12.1/include/server/port/atomics/generic.h"
static inline void
pg_atomic_write_u64_impl(volatile pg_atomic_uint64 *ptr, uint64 val)
{





 ((void)1);
 ptr->value = val;
}
# 298 "/products1/postgres/PG12.1/include/server/port/atomics/generic.h"
static inline uint64
pg_atomic_read_u64_impl(volatile pg_atomic_uint64 *ptr)
{



 ((void)1);
 return ptr->value;
}
# 330 "/products1/postgres/PG12.1/include/server/port/atomics/generic.h"
static inline void
pg_atomic_init_u64_impl(volatile pg_atomic_uint64 *ptr, uint64 val_)
{
 pg_atomic_write_u64_impl(ptr, val_);
}
# 387 "/products1/postgres/PG12.1/include/server/port/atomics/generic.h"
static inline uint64
pg_atomic_add_fetch_u64_impl(volatile pg_atomic_uint64 *ptr, int64 add_)
{
 return pg_atomic_fetch_add_u64_impl(ptr, add_) + add_;
}




static inline uint64
pg_atomic_sub_fetch_u64_impl(volatile pg_atomic_uint64 *ptr, int64 sub_)
{
 return pg_atomic_fetch_sub_u64_impl(ptr, sub_) - sub_;
}
# 125 "/products1/postgres/PG12.1/include/server/port/atomics.h" 2
# 174 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline void
pg_atomic_init_flag(volatile pg_atomic_flag *ptr)
{
 pg_atomic_init_flag_impl(ptr);
}
# 187 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline _Bool
pg_atomic_test_set_flag(volatile pg_atomic_flag *ptr)
{
 return pg_atomic_test_set_flag_impl(ptr);
}
# 200 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline _Bool
pg_atomic_unlocked_test_flag(volatile pg_atomic_flag *ptr)
{
 return pg_atomic_unlocked_test_flag_impl(ptr);
}






static inline void
pg_atomic_clear_flag(volatile pg_atomic_flag *ptr)
{
 pg_atomic_clear_flag_impl(ptr);
}
# 225 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline void
pg_atomic_init_u32(volatile pg_atomic_uint32 *ptr, uint32 val)
{
 ((void)1);

 pg_atomic_init_u32_impl(ptr, val);
}
# 243 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline uint32
pg_atomic_read_u32(volatile pg_atomic_uint32 *ptr)
{
 ((void)1);
 return pg_atomic_read_u32_impl(ptr);
}
# 260 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline void
pg_atomic_write_u32(volatile pg_atomic_uint32 *ptr, uint32 val)
{
 ((void)1);

 pg_atomic_write_u32_impl(ptr, val);
}
# 279 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline void
pg_atomic_unlocked_write_u32(volatile pg_atomic_uint32 *ptr, uint32 val)
{
 ((void)1);

 pg_atomic_unlocked_write_u32_impl(ptr, val);
}
# 294 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline uint32
pg_atomic_exchange_u32(volatile pg_atomic_uint32 *ptr, uint32 newval)
{
 ((void)1);

 return pg_atomic_exchange_u32_impl(ptr, newval);
}
# 313 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline _Bool
pg_atomic_compare_exchange_u32(volatile pg_atomic_uint32 *ptr,
          uint32 *expected, uint32 newval)
{
 ((void)1);
 ((void)1);

 return pg_atomic_compare_exchange_u32_impl(ptr, expected, newval);
}
# 330 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline uint32
pg_atomic_fetch_add_u32(volatile pg_atomic_uint32 *ptr, int32 add_)
{
 ((void)1);
 return pg_atomic_fetch_add_u32_impl(ptr, add_);
}
# 345 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline uint32
pg_atomic_fetch_sub_u32(volatile pg_atomic_uint32 *ptr, int32 sub_)
{
 ((void)1);
 ((void)1);
 return pg_atomic_fetch_sub_u32_impl(ptr, sub_);
}
# 360 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline uint32
pg_atomic_fetch_and_u32(volatile pg_atomic_uint32 *ptr, uint32 and_)
{
 ((void)1);
 return pg_atomic_fetch_and_u32_impl(ptr, and_);
}
# 374 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline uint32
pg_atomic_fetch_or_u32(volatile pg_atomic_uint32 *ptr, uint32 or_)
{
 ((void)1);
 return pg_atomic_fetch_or_u32_impl(ptr, or_);
}
# 388 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline uint32
pg_atomic_add_fetch_u32(volatile pg_atomic_uint32 *ptr, int32 add_)
{
 ((void)1);
 return pg_atomic_add_fetch_u32_impl(ptr, add_);
}
# 403 "/products1/postgres/PG12.1/include/server/port/atomics.h"
static inline uint32
pg_atomic_sub_fetch_u32(volatile pg_atomic_uint32 *ptr, int32 sub_)
{
 ((void)1);
 ((void)1);
 return pg_atomic_sub_fetch_u32_impl(ptr, sub_);
}







static inline void
pg_atomic_init_u64(volatile pg_atomic_uint64 *ptr, uint64 val)
{






 ((void)1);

 pg_atomic_init_u64_impl(ptr, val);
}

static inline uint64
pg_atomic_read_u64(volatile pg_atomic_uint64 *ptr)
{

 ((void)1);

 return pg_atomic_read_u64_impl(ptr);
}

static inline void
pg_atomic_write_u64(volatile pg_atomic_uint64 *ptr, uint64 val)
{

 ((void)1);

 pg_atomic_write_u64_impl(ptr, val);
}

static inline uint64
pg_atomic_exchange_u64(volatile pg_atomic_uint64 *ptr, uint64 newval)
{

 ((void)1);

 return pg_atomic_exchange_u64_impl(ptr, newval);
}

static inline _Bool
pg_atomic_compare_exchange_u64(volatile pg_atomic_uint64 *ptr,
          uint64 *expected, uint64 newval)
{

 ((void)1);
 ((void)1);

 return pg_atomic_compare_exchange_u64_impl(ptr, expected, newval);
}

static inline uint64
pg_atomic_fetch_add_u64(volatile pg_atomic_uint64 *ptr, int64 add_)
{

 ((void)1);

 return pg_atomic_fetch_add_u64_impl(ptr, add_);
}

static inline uint64
pg_atomic_fetch_sub_u64(volatile pg_atomic_uint64 *ptr, int64 sub_)
{

 ((void)1);

 ((void)1);
 return pg_atomic_fetch_sub_u64_impl(ptr, sub_);
}

static inline uint64
pg_atomic_fetch_and_u64(volatile pg_atomic_uint64 *ptr, uint64 and_)
{

 ((void)1);

 return pg_atomic_fetch_and_u64_impl(ptr, and_);
}

static inline uint64
pg_atomic_fetch_or_u64(volatile pg_atomic_uint64 *ptr, uint64 or_)
{

 ((void)1);

 return pg_atomic_fetch_or_u64_impl(ptr, or_);
}

static inline uint64
pg_atomic_add_fetch_u64(volatile pg_atomic_uint64 *ptr, int64 add_)
{

 ((void)1);

 return pg_atomic_add_fetch_u64_impl(ptr, add_);
}

static inline uint64
pg_atomic_sub_fetch_u64(volatile pg_atomic_uint64 *ptr, int64 sub_)
{

 ((void)1);

 ((void)1);
 return pg_atomic_sub_fetch_u64_impl(ptr, sub_);
}
# 18 "/products1/postgres/PG12.1/include/server/utils/dsa.h" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/dsm.h" 1
# 16 "/products1/postgres/PG12.1/include/server/storage/dsm.h"
# 1 "/products1/postgres/PG12.1/include/server/storage/dsm_impl.h" 1
# 42 "/products1/postgres/PG12.1/include/server/storage/dsm_impl.h"
extern int dynamic_shared_memory_type;
# 54 "/products1/postgres/PG12.1/include/server/storage/dsm_impl.h"
typedef uint32 dsm_handle;


typedef enum
{
 DSM_OP_CREATE,
 DSM_OP_ATTACH,
 DSM_OP_DETACH,
 DSM_OP_DESTROY
} dsm_op;


extern _Bool dsm_impl_op(dsm_op op, dsm_handle handle, Size request_size,
      void **impl_private, void **mapped_address, Size *mapped_size,
      int elevel);


extern void dsm_impl_pin_segment(dsm_handle handle, void *impl_private,
         void **impl_private_pm_handle);
extern void dsm_impl_unpin_segment(dsm_handle handle, void **impl_private);
# 17 "/products1/postgres/PG12.1/include/server/storage/dsm.h" 2

typedef struct dsm_segment dsm_segment;







struct PGShmemHeader;
extern void dsm_cleanup_using_control_segment(dsm_handle old_control_handle);
extern void dsm_postmaster_startup(struct PGShmemHeader *);
extern void dsm_backend_shutdown(void);
extern void dsm_detach_all(void);






extern dsm_segment *dsm_create(Size size, int flags);
extern dsm_segment *dsm_attach(dsm_handle h);
extern void dsm_detach(dsm_segment *seg);


extern void dsm_pin_mapping(dsm_segment *seg);
extern void dsm_unpin_mapping(dsm_segment *seg);
extern void dsm_pin_segment(dsm_segment *seg);
extern void dsm_unpin_segment(dsm_handle h);
extern dsm_segment *dsm_find_mapping(dsm_handle h);


extern void *dsm_segment_address(dsm_segment *seg);
extern Size dsm_segment_map_length(dsm_segment *seg);
extern dsm_handle dsm_segment_handle(dsm_segment *seg);


typedef void (*on_dsm_detach_callback) (dsm_segment *, Datum arg);
extern void on_dsm_detach(dsm_segment *seg,
        on_dsm_detach_callback function, Datum arg);
extern void cancel_on_dsm_detach(dsm_segment *seg,
         on_dsm_detach_callback function, Datum arg);
extern void reset_on_dsm_detach(void);
# 19 "/products1/postgres/PG12.1/include/server/utils/dsa.h" 2


struct dsa_area;
typedef struct dsa_area dsa_area;
# 62 "/products1/postgres/PG12.1/include/server/utils/dsa.h"
typedef uint64 dsa_pointer;
typedef pg_atomic_uint64 dsa_pointer_atomic;
# 100 "/products1/postgres/PG12.1/include/server/utils/dsa.h"
typedef dsm_handle dsa_handle;

extern void dsa_startup(void);

extern dsa_area *dsa_create(int tranche_id);
extern dsa_area *dsa_create_in_place(void *place, size_t size,
          int tranche_id, dsm_segment *segment);
extern dsa_area *dsa_attach(dsa_handle handle);
extern dsa_area *dsa_attach_in_place(void *place, dsm_segment *segment);
extern void dsa_release_in_place(void *place);
extern void dsa_on_dsm_detach_release_in_place(dsm_segment *, Datum);
extern void dsa_on_shmem_exit_release_in_place(int, Datum);
extern void dsa_pin_mapping(dsa_area *area);
extern void dsa_detach(dsa_area *area);
extern void dsa_pin(dsa_area *area);
extern void dsa_unpin(dsa_area *area);
extern void dsa_set_size_limit(dsa_area *area, size_t limit);
extern size_t dsa_minimum_size(void);
extern dsa_handle dsa_get_handle(dsa_area *area);
extern dsa_pointer dsa_allocate_extended(dsa_area *area, size_t size, int flags);
extern void dsa_free(dsa_area *area, dsa_pointer dp);
extern void *dsa_get_address(dsa_area *area, dsa_pointer dp);
extern void dsa_trim(dsa_area *area);
extern void dsa_dump(dsa_area *area);
# 27 "/products1/postgres/PG12.1/include/server/nodes/tidbitmap.h" 2






typedef struct TIDBitmap TIDBitmap;


typedef struct TBMIterator TBMIterator;
typedef struct TBMSharedIterator TBMSharedIterator;


typedef struct TBMIterateResult
{
 BlockNumber blockno;
 int ntuples;
 _Bool recheck;

 OffsetNumber offsets[];
} TBMIterateResult;



extern TIDBitmap *tbm_create(long maxbytes, dsa_area *dsa);
extern void tbm_free(TIDBitmap *tbm);
extern void tbm_free_shared_area(dsa_area *dsa, dsa_pointer dp);

extern void tbm_add_tuples(TIDBitmap *tbm,
         const ItemPointer tids, int ntids,
         _Bool recheck);
extern void tbm_add_page(TIDBitmap *tbm, BlockNumber pageno);

extern void tbm_union(TIDBitmap *a, const TIDBitmap *b);
extern void tbm_intersect(TIDBitmap *a, const TIDBitmap *b);

extern _Bool tbm_is_empty(const TIDBitmap *tbm);

extern TBMIterator *tbm_begin_iterate(TIDBitmap *tbm);
extern dsa_pointer tbm_prepare_shared_iterate(TIDBitmap *tbm);
extern TBMIterateResult *tbm_iterate(TBMIterator *iterator);
extern TBMIterateResult *tbm_shared_iterate(TBMSharedIterator *iterator);
extern void tbm_end_iterate(TBMIterator *iterator);
extern void tbm_end_shared_iterate(TBMSharedIterator *iterator);
extern TBMSharedIterator *tbm_attach_shared_iterate(dsa_area *dsa,
             dsa_pointer dp);
extern long tbm_calculate_entries(double maxbytes);
# 20 "/products1/postgres/PG12.1/include/server/access/genam.h" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/lockdefs.h" 1
# 25 "/products1/postgres/PG12.1/include/server/storage/lockdefs.h"
typedef int LOCKMASK;
typedef int LOCKMODE;
# 52 "/products1/postgres/PG12.1/include/server/storage/lockdefs.h"
typedef struct xl_standby_lock
{
 TransactionId xid;
 Oid dbOid;
 Oid relOid;
} xl_standby_lock;
# 21 "/products1/postgres/PG12.1/include/server/access/genam.h" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/relcache.h" 1
# 18 "/products1/postgres/PG12.1/include/server/utils/relcache.h"
# 1 "/products1/postgres/PG12.1/include/server/nodes/bitmapset.h" 1
# 26 "/products1/postgres/PG12.1/include/server/nodes/bitmapset.h"
struct List;
# 38 "/products1/postgres/PG12.1/include/server/nodes/bitmapset.h"
typedef uint64 bitmapword;
typedef int64 signedbitmapword;
# 49 "/products1/postgres/PG12.1/include/server/nodes/bitmapset.h"
typedef struct Bitmapset
{
 int nwords;
 bitmapword words[];
} Bitmapset;



typedef enum
{
 BMS_EQUAL,
 BMS_SUBSET1,
 BMS_SUBSET2,
 BMS_DIFFERENT
} BMS_Comparison;


typedef enum
{
 BMS_EMPTY_SET,
 BMS_SINGLETON,
 BMS_MULTIPLE
} BMS_Membership;






extern Bitmapset *bms_copy(const Bitmapset *a);
extern _Bool bms_equal(const Bitmapset *a, const Bitmapset *b);
extern int bms_compare(const Bitmapset *a, const Bitmapset *b);
extern Bitmapset *bms_make_singleton(int x);
extern void bms_free(Bitmapset *a);

extern Bitmapset *bms_union(const Bitmapset *a, const Bitmapset *b);
extern Bitmapset *bms_intersect(const Bitmapset *a, const Bitmapset *b);
extern Bitmapset *bms_difference(const Bitmapset *a, const Bitmapset *b);
extern _Bool bms_is_subset(const Bitmapset *a, const Bitmapset *b);
extern BMS_Comparison bms_subset_compare(const Bitmapset *a, const Bitmapset *b);
extern _Bool bms_is_member(int x, const Bitmapset *a);
extern int bms_member_index(Bitmapset *a, int x);
extern _Bool bms_overlap(const Bitmapset *a, const Bitmapset *b);
extern _Bool bms_overlap_list(const Bitmapset *a, const struct List *b);
extern _Bool bms_nonempty_difference(const Bitmapset *a, const Bitmapset *b);
extern int bms_singleton_member(const Bitmapset *a);
extern _Bool bms_get_singleton_member(const Bitmapset *a, int *member);
extern int bms_num_members(const Bitmapset *a);


extern BMS_Membership bms_membership(const Bitmapset *a);
extern _Bool bms_is_empty(const Bitmapset *a);



extern Bitmapset *bms_add_member(Bitmapset *a, int x);
extern Bitmapset *bms_del_member(Bitmapset *a, int x);
extern Bitmapset *bms_add_members(Bitmapset *a, const Bitmapset *b);
extern Bitmapset *bms_add_range(Bitmapset *a, int lower, int upper);
extern Bitmapset *bms_int_members(Bitmapset *a, const Bitmapset *b);
extern Bitmapset *bms_del_members(Bitmapset *a, const Bitmapset *b);
extern Bitmapset *bms_join(Bitmapset *a, Bitmapset *b);


extern int bms_first_member(Bitmapset *a);
extern int bms_next_member(const Bitmapset *a, int prevbit);
extern int bms_prev_member(const Bitmapset *a, int prevbit);


extern uint32 bms_hash_value(const Bitmapset *a);
# 19 "/products1/postgres/PG12.1/include/server/utils/relcache.h" 2







typedef struct RelationData *Relation;







typedef Relation *RelationPtr;




extern Relation RelationIdGetRelation(Oid relationId);
extern void RelationClose(Relation relation);




extern List *RelationGetFKeyList(Relation relation);
extern List *RelationGetIndexList(Relation relation);
extern List *RelationGetStatExtList(Relation relation);
extern Oid RelationGetPrimaryKeyIndex(Relation relation);
extern Oid RelationGetReplicaIndex(Relation relation);
extern List *RelationGetIndexExpressions(Relation relation);
extern List *RelationGetIndexPredicate(Relation relation);

typedef enum IndexAttrBitmapKind
{
 INDEX_ATTR_BITMAP_ALL,
 INDEX_ATTR_BITMAP_KEY,
 INDEX_ATTR_BITMAP_PRIMARY_KEY,
 INDEX_ATTR_BITMAP_IDENTITY_KEY
} IndexAttrBitmapKind;

extern Bitmapset *RelationGetIndexAttrBitmap(Relation relation,
            IndexAttrBitmapKind keyAttrs);

extern void RelationGetExclusionInfo(Relation indexRelation,
          Oid **operators,
          Oid **procs,
          uint16 **strategies);

extern void RelationInitIndexAccessInfo(Relation relation);


struct PublicationActions;
extern struct PublicationActions *GetRelationPublicationActions(Relation relation);

extern void RelationInitTableAccessMethod(Relation relation);




extern int errtable(Relation rel);
extern int errtablecol(Relation rel, int attnum);
extern int errtablecolname(Relation rel, const char *colname);
extern int errtableconstraint(Relation rel, const char *conname);




extern void RelationCacheInitialize(void);
extern void RelationCacheInitializePhase2(void);
extern void RelationCacheInitializePhase3(void);




extern Relation RelationBuildLocalRelation(const char *relname,
             Oid relnamespace,
             TupleDesc tupDesc,
             Oid relid,
             Oid accessmtd,
             Oid relfilenode,
             Oid reltablespace,
             _Bool shared_relation,
             _Bool mapped_relation,
             char relpersistence,
             char relkind);




extern void RelationSetNewRelfilenode(Relation relation, char persistence);




extern void RelationForgetRelation(Oid rid);

extern void RelationCacheInvalidateEntry(Oid relationId);

extern void RelationCacheInvalidate(void);

extern void RelationCloseSmgrByOid(Oid relationId);

extern void AtEOXact_RelationCache(_Bool isCommit);
extern void AtEOSubXact_RelationCache(_Bool isCommit, SubTransactionId mySubid,
           SubTransactionId parentSubid);




extern _Bool RelationIdIsInInitFile(Oid relationId);
extern void RelationCacheInitFilePreInvalidate(void);
extern void RelationCacheInitFilePostInvalidate(void);
extern void RelationCacheInitFileRemove(void);


extern _Bool criticalRelcachesBuilt;


extern _Bool criticalSharedRelcachesBuilt;
# 22 "/products1/postgres/PG12.1/include/server/access/genam.h" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/snapshot.h" 1
# 18 "/products1/postgres/PG12.1/include/server/utils/snapshot.h"
# 1 "/products1/postgres/PG12.1/include/server/datatype/timestamp.h" 1
# 38 "/products1/postgres/PG12.1/include/server/datatype/timestamp.h"
typedef int64 Timestamp;
typedef int64 TimestampTz;
typedef int64 TimeOffset;
typedef int32 fsec_t;

typedef struct
{
 TimeOffset time;

 int32 day;
 int32 month;
} Interval;
# 19 "/products1/postgres/PG12.1/include/server/utils/snapshot.h" 2
# 1 "/products1/postgres/PG12.1/include/server/lib/pairingheap.h" 1
# 14 "/products1/postgres/PG12.1/include/server/lib/pairingheap.h"
# 1 "/products1/postgres/PG12.1/include/server/lib/stringinfo.h" 1
# 35 "/products1/postgres/PG12.1/include/server/lib/stringinfo.h"
typedef struct StringInfoData
{
 char *data;
 int len;
 int maxlen;
 int cursor;
} StringInfoData;

typedef StringInfoData *StringInfo;
# 72 "/products1/postgres/PG12.1/include/server/lib/stringinfo.h"
extern StringInfo makeStringInfo(void);






extern void initStringInfo(StringInfo str);






extern void resetStringInfo(StringInfo str);
# 95 "/products1/postgres/PG12.1/include/server/lib/stringinfo.h"
extern void appendStringInfo(StringInfo str, const char *fmt,...) __attribute__((format(gnu_printf, 2, 3)));
# 106 "/products1/postgres/PG12.1/include/server/lib/stringinfo.h"
extern int appendStringInfoVA(StringInfo str, const char *fmt, va_list args) __attribute__((format(gnu_printf, 2, 0)));






extern void appendStringInfoString(StringInfo str, const char *s);






extern void appendStringInfoChar(StringInfo str, char ch);
# 136 "/products1/postgres/PG12.1/include/server/lib/stringinfo.h"
extern void appendStringInfoSpaces(StringInfo str, int count);






extern void appendBinaryStringInfo(StringInfo str,
           const char *data, int datalen);






extern void appendBinaryStringInfoNT(StringInfo str,
          const char *data, int datalen);





extern void enlargeStringInfo(StringInfo str, int needed);
# 15 "/products1/postgres/PG12.1/include/server/lib/pairingheap.h" 2
# 30 "/products1/postgres/PG12.1/include/server/lib/pairingheap.h"
typedef struct pairingheap_node
{
 struct pairingheap_node *first_child;
 struct pairingheap_node *next_sibling;
 struct pairingheap_node *prev_or_parent;
} pairingheap_node;
# 60 "/products1/postgres/PG12.1/include/server/lib/pairingheap.h"
typedef int (*pairingheap_comparator) (const pairingheap_node *a,
            const pairingheap_node *b,
            void *arg);
# 71 "/products1/postgres/PG12.1/include/server/lib/pairingheap.h"
typedef struct pairingheap
{
 pairingheap_comparator ph_compare;
 void *ph_arg;
 pairingheap_node *ph_root;
} pairingheap;

extern pairingheap *pairingheap_allocate(pairingheap_comparator compare,
           void *arg);
extern void pairingheap_free(pairingheap *heap);
extern void pairingheap_add(pairingheap *heap, pairingheap_node *node);
extern pairingheap_node *pairingheap_first(pairingheap *heap);
extern pairingheap_node *pairingheap_remove_first(pairingheap *heap);
extern void pairingheap_remove(pairingheap *heap, pairingheap_node *node);
# 20 "/products1/postgres/PG12.1/include/server/utils/snapshot.h" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/buf.h" 1
# 23 "/products1/postgres/PG12.1/include/server/storage/buf.h"
typedef int Buffer;
# 44 "/products1/postgres/PG12.1/include/server/storage/buf.h"
typedef struct BufferAccessStrategyData *BufferAccessStrategy;
# 21 "/products1/postgres/PG12.1/include/server/utils/snapshot.h" 2
# 35 "/products1/postgres/PG12.1/include/server/utils/snapshot.h"
typedef enum SnapshotType
{
# 50 "/products1/postgres/PG12.1/include/server/utils/snapshot.h"
 SNAPSHOT_MVCC = 0,
# 64 "/products1/postgres/PG12.1/include/server/utils/snapshot.h"
 SNAPSHOT_SELF,




 SNAPSHOT_ANY,




 SNAPSHOT_TOAST,
# 102 "/products1/postgres/PG12.1/include/server/utils/snapshot.h"
 SNAPSHOT_DIRTY,






 SNAPSHOT_HISTORIC_MVCC,
# 118 "/products1/postgres/PG12.1/include/server/utils/snapshot.h"
 SNAPSHOT_NON_VACUUMABLE
} SnapshotType;

typedef struct SnapshotData *Snapshot;
# 142 "/products1/postgres/PG12.1/include/server/utils/snapshot.h"
typedef struct SnapshotData
{
 SnapshotType snapshot_type;
# 157 "/products1/postgres/PG12.1/include/server/utils/snapshot.h"
 TransactionId xmin;
 TransactionId xmax;
# 168 "/products1/postgres/PG12.1/include/server/utils/snapshot.h"
 TransactionId *xip;
 uint32 xcnt;
# 180 "/products1/postgres/PG12.1/include/server/utils/snapshot.h"
 TransactionId *subxip;
 int32 subxcnt;
 _Bool suboverflowed;

 _Bool takenDuringRecovery;
 _Bool copied;

 CommandId curcid;





 uint32 speculativeToken;




 uint32 active_count;
 uint32 regd_count;
 pairingheap_node ph_node;

 TimestampTz whenTaken;
 XLogRecPtr lsn;
} SnapshotData;
# 23 "/products1/postgres/PG12.1/include/server/access/genam.h" 2


struct IndexInfo;




typedef struct IndexBuildResult
{
 double heap_tuples;
 double index_tuples;
} IndexBuildResult;
# 44 "/products1/postgres/PG12.1/include/server/access/genam.h"
typedef struct IndexVacuumInfo
{
 Relation index;
 _Bool analyze_only;
 _Bool report_progress;
 _Bool estimated_count;
 int message_level;
 double num_heap_tuples;
 BufferAccessStrategy strategy;
} IndexVacuumInfo;
# 72 "/products1/postgres/PG12.1/include/server/access/genam.h"
typedef struct IndexBulkDeleteResult
{
 BlockNumber num_pages;
 BlockNumber pages_removed;
 _Bool estimated_count;
 double num_index_tuples;
 double tuples_removed;
 BlockNumber pages_deleted;
 BlockNumber pages_free;
} IndexBulkDeleteResult;


typedef _Bool (*IndexBulkDeleteCallback) (ItemPointer itemptr, void *state);


typedef struct IndexScanDescData *IndexScanDesc;
typedef struct SysScanDescData *SysScanDesc;

typedef struct ParallelIndexScanDescData *ParallelIndexScanDesc;
# 112 "/products1/postgres/PG12.1/include/server/access/genam.h"
typedef enum IndexUniqueCheck
{
 UNIQUE_CHECK_NO,
 UNIQUE_CHECK_YES,
 UNIQUE_CHECK_PARTIAL,
 UNIQUE_CHECK_EXISTING
} IndexUniqueCheck;



typedef struct IndexOrderByDistance
{
 double value;
 _Bool isnull;
} IndexOrderByDistance;
# 138 "/products1/postgres/PG12.1/include/server/access/genam.h"
extern Relation index_open(Oid relationId, LOCKMODE lockmode);
extern void index_close(Relation relation, LOCKMODE lockmode);

extern _Bool index_insert(Relation indexRelation,
       Datum *values, _Bool *isnull,
       ItemPointer heap_t_ctid,
       Relation heapRelation,
       IndexUniqueCheck checkUnique,
       struct IndexInfo *indexInfo);

extern IndexScanDesc index_beginscan(Relation heapRelation,
          Relation indexRelation,
          Snapshot snapshot,
          int nkeys, int norderbys);
extern IndexScanDesc index_beginscan_bitmap(Relation indexRelation,
           Snapshot snapshot,
           int nkeys);
extern void index_rescan(IndexScanDesc scan,
       ScanKey keys, int nkeys,
       ScanKey orderbys, int norderbys);
extern void index_endscan(IndexScanDesc scan);
extern void index_markpos(IndexScanDesc scan);
extern void index_restrpos(IndexScanDesc scan);
extern Size index_parallelscan_estimate(Relation indexrel, Snapshot snapshot);
extern void index_parallelscan_initialize(Relation heaprel, Relation indexrel,
            Snapshot snapshot, ParallelIndexScanDesc target);
extern void index_parallelrescan(IndexScanDesc scan);
extern IndexScanDesc index_beginscan_parallel(Relation heaprel,
             Relation indexrel, int nkeys, int norderbys,
             ParallelIndexScanDesc pscan);
extern ItemPointer index_getnext_tid(IndexScanDesc scan,
          ScanDirection direction);
struct TupleTableSlot;
extern _Bool index_fetch_heap(IndexScanDesc scan, struct TupleTableSlot *slot);
extern _Bool index_getnext_slot(IndexScanDesc scan, ScanDirection direction,
          struct TupleTableSlot *slot);
extern int64 index_getbitmap(IndexScanDesc scan, TIDBitmap *bitmap);

extern IndexBulkDeleteResult *index_bulk_delete(IndexVacuumInfo *info,
            IndexBulkDeleteResult *stats,
            IndexBulkDeleteCallback callback,
            void *callback_state);
extern IndexBulkDeleteResult *index_vacuum_cleanup(IndexVacuumInfo *info,
               IndexBulkDeleteResult *stats);
extern _Bool index_can_return(Relation indexRelation, int attno);
extern RegProcedure index_getprocid(Relation irel, AttrNumber attnum,
         uint16 procnum);
extern FmgrInfo *index_getprocinfo(Relation irel, AttrNumber attnum,
           uint16 procnum);
extern void index_store_float8_orderby_distances(IndexScanDesc scan,
             Oid *orderByTypes,
             IndexOrderByDistance *distances,
             _Bool recheckOrderBy);




extern IndexScanDesc RelationGetIndexScan(Relation indexRelation,
            int nkeys, int norderbys);
extern void IndexScanEnd(IndexScanDesc scan);
extern char *BuildIndexValueDescription(Relation indexRelation,
          Datum *values, _Bool *isnull);
extern TransactionId index_compute_xid_horizon_for_tuples(Relation irel,
                Relation hrel,
                Buffer ibuf,
                OffsetNumber *itemnos,
                int nitems);




extern SysScanDesc systable_beginscan(Relation heapRelation,
           Oid indexId,
           _Bool indexOK,
           Snapshot snapshot,
           int nkeys, ScanKey key);
extern HeapTuple systable_getnext(SysScanDesc sysscan);
extern _Bool systable_recheck_tuple(SysScanDesc sysscan, HeapTuple tup);
extern void systable_endscan(SysScanDesc sysscan);
extern SysScanDesc systable_beginscan_ordered(Relation heapRelation,
             Relation indexRelation,
             Snapshot snapshot,
             int nkeys, ScanKey key);
extern HeapTuple systable_getnext_ordered(SysScanDesc sysscan,
            ScanDirection direction);
extern void systable_endscan_ordered(SysScanDesc sysscan);
# 16 "/products1/postgres/PG12.1/include/server/access/amapi.h" 2






struct PlannerInfo;
struct IndexPath;


struct IndexInfo;







typedef enum IndexAMProperty
{
 AMPROP_UNKNOWN = 0,
 AMPROP_ASC,
 AMPROP_DESC,
 AMPROP_NULLS_FIRST,
 AMPROP_NULLS_LAST,
 AMPROP_ORDERABLE,
 AMPROP_DISTANCE_ORDERABLE,
 AMPROP_RETURNABLE,
 AMPROP_SEARCH_ARRAY,
 AMPROP_SEARCH_NULLS,
 AMPROP_CLUSTERABLE,
 AMPROP_INDEX_SCAN,
 AMPROP_BITMAP_SCAN,
 AMPROP_BACKWARD_SCAN,
 AMPROP_CAN_ORDER,
 AMPROP_CAN_UNIQUE,
 AMPROP_CAN_MULTI_COL,
 AMPROP_CAN_EXCLUDE,
 AMPROP_CAN_INCLUDE
} IndexAMProperty;







typedef IndexBuildResult *(*ambuild_function) (Relation heapRelation,
              Relation indexRelation,
              struct IndexInfo *indexInfo);


typedef void (*ambuildempty_function) (Relation indexRelation);


typedef _Bool (*aminsert_function) (Relation indexRelation,
           Datum *values,
           _Bool *isnull,
           ItemPointer heap_tid,
           Relation heapRelation,
           IndexUniqueCheck checkUnique,
           struct IndexInfo *indexInfo);


typedef IndexBulkDeleteResult *(*ambulkdelete_function) (IndexVacuumInfo *info,
               IndexBulkDeleteResult *stats,
               IndexBulkDeleteCallback callback,
               void *callback_state);


typedef IndexBulkDeleteResult *(*amvacuumcleanup_function) (IndexVacuumInfo *info,
               IndexBulkDeleteResult *stats);


typedef _Bool (*amcanreturn_function) (Relation indexRelation, int attno);


typedef void (*amcostestimate_function) (struct PlannerInfo *root,
           struct IndexPath *path,
           double loop_count,
           Cost *indexStartupCost,
           Cost *indexTotalCost,
           Selectivity *indexSelectivity,
           double *indexCorrelation,
           double *indexPages);


typedef bytea *(*amoptions_function) (Datum reloptions,
           _Bool validate);


typedef _Bool (*amproperty_function) (Oid index_oid, int attno,
          IndexAMProperty prop, const char *propname,
          _Bool *res, _Bool *isnull);


typedef char *(*ambuildphasename_function) (int64 phasenum);


typedef _Bool (*amvalidate_function) (Oid opclassoid);


typedef IndexScanDesc (*ambeginscan_function) (Relation indexRelation,
              int nkeys,
              int norderbys);


typedef void (*amrescan_function) (IndexScanDesc scan,
           ScanKey keys,
           int nkeys,
           ScanKey orderbys,
           int norderbys);


typedef _Bool (*amgettuple_function) (IndexScanDesc scan,
          ScanDirection direction);


typedef int64 (*amgetbitmap_function) (IndexScanDesc scan,
            TIDBitmap *tbm);


typedef void (*amendscan_function) (IndexScanDesc scan);


typedef void (*ammarkpos_function) (IndexScanDesc scan);


typedef void (*amrestrpos_function) (IndexScanDesc scan);






typedef Size (*amestimateparallelscan_function) (void);


typedef void (*aminitparallelscan_function) (void *target);


typedef void (*amparallelrescan_function) (IndexScanDesc scan);





typedef struct IndexAmRoutine
{
 NodeTag type;





 uint16 amstrategies;

 uint16 amsupport;

 _Bool amcanorder;

 _Bool amcanorderbyop;

 _Bool amcanbackward;

 _Bool amcanunique;

 _Bool amcanmulticol;

 _Bool amoptionalkey;

 _Bool amsearcharray;

 _Bool amsearchnulls;

 _Bool amstorage;

 _Bool amclusterable;

 _Bool ampredlocks;

 _Bool amcanparallel;

 _Bool amcaninclude;

 Oid amkeytype;
# 210 "/products1/postgres/PG12.1/include/server/access/amapi.h"
 ambuild_function ambuild;
 ambuildempty_function ambuildempty;
 aminsert_function aminsert;
 ambulkdelete_function ambulkdelete;
 amvacuumcleanup_function amvacuumcleanup;
 amcanreturn_function amcanreturn;
 amcostestimate_function amcostestimate;
 amoptions_function amoptions;
 amproperty_function amproperty;
 ambuildphasename_function ambuildphasename;
 amvalidate_function amvalidate;
 ambeginscan_function ambeginscan;
 amrescan_function amrescan;
 amgettuple_function amgettuple;
 amgetbitmap_function amgetbitmap;
 amendscan_function amendscan;
 ammarkpos_function ammarkpos;
 amrestrpos_function amrestrpos;


 amestimateparallelscan_function amestimateparallelscan;
 aminitparallelscan_function aminitparallelscan;
 amparallelrescan_function amparallelrescan;
} IndexAmRoutine;



extern IndexAmRoutine *GetIndexAmRoutine(Oid amhandler);
extern IndexAmRoutine *GetIndexAmRoutineByAmId(Oid amoid, _Bool noerror);
# 23 "/products1/postgres/PG12.1/include/server/access/reloptions.h" 2



# 1 "/products1/postgres/PG12.1/include/server/storage/lock.h" 1
# 22 "/products1/postgres/PG12.1/include/server/storage/lock.h"
# 1 "/products1/postgres/PG12.1/include/server/storage/backendid.h" 1
# 21 "/products1/postgres/PG12.1/include/server/storage/backendid.h"
typedef int BackendId;



extern BackendId MyBackendId;


extern BackendId ParallelMasterBackendId;
# 23 "/products1/postgres/PG12.1/include/server/storage/lock.h" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/lwlock.h" 1
# 21 "/products1/postgres/PG12.1/include/server/storage/lwlock.h"
# 1 "/products1/postgres/PG12.1/include/server/storage/proclist_types.h" 1
# 26 "/products1/postgres/PG12.1/include/server/storage/proclist_types.h"
typedef struct proclist_node
{
 int next;
 int prev;
} proclist_node;





typedef struct proclist_head
{
 int head;
 int tail;
} proclist_head;




typedef struct proclist_mutable_iter
{
 int cur;
 int next;
} proclist_mutable_iter;
# 22 "/products1/postgres/PG12.1/include/server/storage/lwlock.h" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/s_lock.h" 1
# 208 "/products1/postgres/PG12.1/include/server/storage/s_lock.h"
typedef unsigned char slock_t;
# 223 "/products1/postgres/PG12.1/include/server/storage/s_lock.h"
static __inline__ int
tas(volatile slock_t *lock)
{
 register slock_t _res = 1;

 __asm__ __volatile__(
  "	lock			\n"
  "	xchgb	%0,%1	\n"
: "+q"(_res), "+m"(*lock)
:
: "memory", "cc");
 return (int) _res;
}



static __inline__ void
spin_delay(void)
{




 __asm__ __volatile__(
  " rep; nop			\n");
}
# 1004 "/products1/postgres/PG12.1/include/server/storage/s_lock.h"
extern slock_t dummy_spinlock;




extern int s_lock(volatile slock_t *lock, const char *file, int line, const char *func);




extern void set_spins_per_delay(int shared_spins_per_delay);
extern int update_spins_per_delay(int shared_spins_per_delay);





typedef struct
{
 int spins;
 int delays;
 int cur_delay;
 const char *file;
 int line;
 const char *func;
} SpinDelayStatus;

static inline void
init_spin_delay(SpinDelayStatus *status,
    const char *file, int line, const char *func)
{
 status->spins = 0;
 status->delays = 0;
 status->cur_delay = 0;
 status->file = file;
 status->line = line;
 status->func = func;
}


void perform_spin_delay(SpinDelayStatus *status);
void finish_spin_delay(SpinDelayStatus *status);
# 23 "/products1/postgres/PG12.1/include/server/storage/lwlock.h" 2


struct PGPROC;






typedef struct LWLock
{
 uint16 tranche;
 pg_atomic_uint32 state;
 proclist_head waiters;




} LWLock;
# 77 "/products1/postgres/PG12.1/include/server/storage/lwlock.h"
typedef union LWLockPadded
{
 LWLock lock;
 char pad[128];
} LWLockPadded;


typedef union LWLockMinimallyPadded
{
 LWLock lock;
 char pad[(sizeof(LWLock) <= 32 ? 32 : 64)];
} LWLockMinimallyPadded;

extern LWLockPadded *MainLWLockArray;
extern const char *const MainLWLockNames[];


typedef struct NamedLWLockTranche
{
 int trancheId;
 char *trancheName;
} NamedLWLockTranche;

extern NamedLWLockTranche *NamedLWLockTrancheArray;
extern int NamedLWLockTrancheRequests;


# 1 "/products1/postgres/PG12.1/include/server/storage/lwlocknames.h" 1
# 105 "/products1/postgres/PG12.1/include/server/storage/lwlock.h" 2
# 132 "/products1/postgres/PG12.1/include/server/storage/lwlock.h"
typedef enum LWLockMode
{
 LW_EXCLUSIVE,
 LW_SHARED,
 LW_WAIT_UNTIL_FREE


} LWLockMode;






extern _Bool LWLockAcquire(LWLock *lock, LWLockMode mode);
extern _Bool LWLockConditionalAcquire(LWLock *lock, LWLockMode mode);
extern _Bool LWLockAcquireOrWait(LWLock *lock, LWLockMode mode);
extern void LWLockRelease(LWLock *lock);
extern void LWLockReleaseClearVar(LWLock *lock, uint64 *valptr, uint64 val);
extern void LWLockReleaseAll(void);
extern _Bool LWLockHeldByMe(LWLock *lock);
extern _Bool LWLockHeldByMeInMode(LWLock *lock, LWLockMode mode);

extern _Bool LWLockWaitForVar(LWLock *lock, uint64 *valptr, uint64 oldval, uint64 *newval);
extern void LWLockUpdateVar(LWLock *lock, uint64 *valptr, uint64 value);

extern Size LWLockShmemSize(void);
extern void CreateLWLocks(void);
extern void InitLWLockAccess(void);

extern const char *GetLWLockIdentifier(uint32 classId, uint16 eventId);







extern void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks);
extern LWLockPadded *GetNamedLWLockTranche(const char *tranche_name);
# 186 "/products1/postgres/PG12.1/include/server/storage/lwlock.h"
extern int LWLockNewTrancheId(void);
extern void LWLockRegisterTranche(int tranche_id, const char *tranche_name);
extern void LWLockInitialize(LWLock *lock, int tranche_id);







typedef enum BuiltinTrancheIds
{
 LWTRANCHE_CLOG_BUFFERS = 45,
 LWTRANCHE_COMMITTS_BUFFERS,
 LWTRANCHE_SUBTRANS_BUFFERS,
 LWTRANCHE_MXACTOFFSET_BUFFERS,
 LWTRANCHE_MXACTMEMBER_BUFFERS,
 LWTRANCHE_ASYNC_BUFFERS,
 LWTRANCHE_OLDSERXID_BUFFERS,
 LWTRANCHE_WAL_INSERT,
 LWTRANCHE_BUFFER_CONTENT,
 LWTRANCHE_BUFFER_IO_IN_PROGRESS,
 LWTRANCHE_REPLICATION_ORIGIN,
 LWTRANCHE_REPLICATION_SLOT_IO_IN_PROGRESS,
 LWTRANCHE_PROC,
 LWTRANCHE_BUFFER_MAPPING,
 LWTRANCHE_LOCK_MANAGER,
 LWTRANCHE_PREDICATE_LOCK_MANAGER,
 LWTRANCHE_PARALLEL_HASH_JOIN,
 LWTRANCHE_PARALLEL_QUERY_DSA,
 LWTRANCHE_SESSION_DSA,
 LWTRANCHE_SESSION_RECORD_TABLE,
 LWTRANCHE_SESSION_TYPMOD_TABLE,
 LWTRANCHE_SHARED_TUPLESTORE,
 LWTRANCHE_TBM,
 LWTRANCHE_PARALLEL_APPEND,
 LWTRANCHE_SXACT,
 LWTRANCHE_FIRST_USER_DEFINED
} BuiltinTrancheIds;






typedef LWLock *LWLockId;
# 24 "/products1/postgres/PG12.1/include/server/storage/lock.h" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/shmem.h" 1
# 24 "/products1/postgres/PG12.1/include/server/storage/shmem.h"
# 1 "/products1/postgres/PG12.1/include/server/utils/hsearch.h" 1
# 21 "/products1/postgres/PG12.1/include/server/utils/hsearch.h"
typedef uint32 (*HashValueFunc) (const void *key, Size keysize);







typedef int (*HashCompareFunc) (const void *key1, const void *key2,
        Size keysize);






typedef void *(*HashCopyFunc) (void *dest, const void *src, Size keysize);






typedef void *(*HashAllocFunc) (Size request);






typedef struct HASHELEMENT
{
 struct HASHELEMENT *link;
 uint32 hashvalue;
} HASHELEMENT;


typedef struct HASHHDR HASHHDR;


typedef struct HTAB HTAB;



typedef struct HASHCTL
{
 long num_partitions;
 long ssize;
 long dsize;
 long max_dsize;
 long ffactor;
 Size keysize;
 Size entrysize;
 HashValueFunc hash;
 HashCompareFunc match;
 HashCopyFunc keycopy;
 HashAllocFunc alloc;
 MemoryContext hcxt;
 HASHHDR *hctl;
} HASHCTL;
# 103 "/products1/postgres/PG12.1/include/server/utils/hsearch.h"
typedef enum
{
 HASH_FIND,
 HASH_ENTER,
 HASH_REMOVE,
 HASH_ENTER_NULL
} HASHACTION;


typedef struct
{
 HTAB *hashp;
 uint32 curBucket;
 HASHELEMENT *curEntry;
} HASH_SEQ_STATUS;




extern HTAB *hash_create(const char *tabname, long nelem,
       HASHCTL *info, int flags);
extern void hash_destroy(HTAB *hashp);
extern void hash_stats(const char *where, HTAB *hashp);
extern void *hash_search(HTAB *hashp, const void *keyPtr, HASHACTION action,
       _Bool *foundPtr);
extern uint32 get_hash_value(HTAB *hashp, const void *keyPtr);
extern void *hash_search_with_hash_value(HTAB *hashp, const void *keyPtr,
           uint32 hashvalue, HASHACTION action,
           _Bool *foundPtr);
extern _Bool hash_update_hash_key(HTAB *hashp, void *existingEntry,
         const void *newKeyPtr);
extern long hash_get_num_entries(HTAB *hashp);
extern void hash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp);
extern void *hash_seq_search(HASH_SEQ_STATUS *status);
extern void hash_seq_term(HASH_SEQ_STATUS *status);
extern void hash_freeze(HTAB *hashp);
extern Size hash_estimate_size(long num_entries, Size entrysize);
extern long hash_select_dirsize(long num_entries);
extern Size hash_get_shared_size(HASHCTL *info, int flags);
extern void AtEOXact_HashTables(_Bool isCommit);
extern void AtEOSubXact_HashTables(_Bool isCommit, int nestDepth);
# 152 "/products1/postgres/PG12.1/include/server/utils/hsearch.h"
extern uint32 string_hash(const void *key, Size keysize);
extern uint32 tag_hash(const void *key, Size keysize);
extern uint32 uint32_hash(const void *key, Size keysize);
extern uint32 bitmap_hash(const void *key, Size keysize);
extern int bitmap_match(const void *key1, const void *key2, Size keysize);
# 25 "/products1/postgres/PG12.1/include/server/storage/shmem.h" 2



typedef struct SHM_QUEUE
{
 struct SHM_QUEUE *prev;
 struct SHM_QUEUE *next;
} SHM_QUEUE;


extern void InitShmemAccess(void *seghdr);
extern void InitShmemAllocation(void);
extern void *ShmemAlloc(Size size);
extern void *ShmemAllocNoError(Size size);
extern void *ShmemAllocUnlocked(Size size);
extern _Bool ShmemAddrIsValid(const void *addr);
extern void InitShmemIndex(void);
extern HTAB *ShmemInitHash(const char *name, long init_size, long max_size,
         HASHCTL *infoP, int hash_flags);
extern void *ShmemInitStruct(const char *name, Size size, _Bool *foundPtr);
extern Size add_size(Size s1, Size s2);
extern Size mul_size(Size s1, Size s2);


extern void RequestAddinShmemSpace(Size size);
# 58 "/products1/postgres/PG12.1/include/server/storage/shmem.h"
typedef struct
{
 char key[(48)];
 void *location;
 Size size;
} ShmemIndexEnt;




extern void SHMQueueInit(SHM_QUEUE *queue);
extern void SHMQueueElemInit(SHM_QUEUE *queue);
extern void SHMQueueDelete(SHM_QUEUE *queue);
extern void SHMQueueInsertBefore(SHM_QUEUE *queue, SHM_QUEUE *elem);
extern void SHMQueueInsertAfter(SHM_QUEUE *queue, SHM_QUEUE *elem);
extern Pointer SHMQueueNext(const SHM_QUEUE *queue, const SHM_QUEUE *curElem,
       Size linkOffset);
extern Pointer SHMQueuePrev(const SHM_QUEUE *queue, const SHM_QUEUE *curElem,
       Size linkOffset);
extern _Bool SHMQueueEmpty(const SHM_QUEUE *queue);
extern _Bool SHMQueueIsDetached(const SHM_QUEUE *queue);
# 25 "/products1/postgres/PG12.1/include/server/storage/lock.h" 2



typedef struct PGPROC PGPROC;

typedef struct PROC_QUEUE
{
 SHM_QUEUE links;
 int size;
} PROC_QUEUE;


extern int max_locks_per_xact;
# 63 "/products1/postgres/PG12.1/include/server/storage/lock.h"
typedef struct
{
 BackendId backendId;
 LocalTransactionId localTransactionId;
} VirtualTransactionId;
# 111 "/products1/postgres/PG12.1/include/server/storage/lock.h"
typedef struct LockMethodData
{
 int numLockModes;
 const LOCKMASK *conflictTab;
 const char *const *lockModeNames;
 const _Bool *trace_flag;
} LockMethodData;

typedef const LockMethodData *LockMethod;





typedef uint16 LOCKMETHODID;
# 138 "/products1/postgres/PG12.1/include/server/storage/lock.h"
typedef enum LockTagType
{
 LOCKTAG_RELATION,
 LOCKTAG_RELATION_EXTEND,
 LOCKTAG_PAGE,
 LOCKTAG_TUPLE,
 LOCKTAG_TRANSACTION,
 LOCKTAG_VIRTUALTRANSACTION,
 LOCKTAG_SPECULATIVE_TOKEN,
 LOCKTAG_OBJECT,
 LOCKTAG_USERLOCK,
 LOCKTAG_ADVISORY
} LockTagType;



extern const char *const LockTagTypeNames[];
# 164 "/products1/postgres/PG12.1/include/server/storage/lock.h"
typedef struct LOCKTAG
{
 uint32 locktag_field1;
 uint32 locktag_field2;
 uint32 locktag_field3;
 uint16 locktag_field4;
 uint8 locktag_type;
 uint8 locktag_lockmethodid;
} LOCKTAG;
# 288 "/products1/postgres/PG12.1/include/server/storage/lock.h"
typedef struct LOCK
{

 LOCKTAG tag;


 LOCKMASK grantMask;
 LOCKMASK waitMask;
 SHM_QUEUE procLocks;
 PROC_QUEUE waitProcs;
 int requested[10];
 int nRequested;
 int granted[10];
 int nGranted;
} LOCK;
# 341 "/products1/postgres/PG12.1/include/server/storage/lock.h"
typedef struct PROCLOCKTAG
{

 LOCK *myLock;
 PGPROC *myProc;
} PROCLOCKTAG;

typedef struct PROCLOCK
{

 PROCLOCKTAG tag;


 PGPROC *groupLeader;
 LOCKMASK holdMask;
 LOCKMASK releaseMask;
 SHM_QUEUE lockLink;
 SHM_QUEUE procLink;
} PROCLOCK;
# 387 "/products1/postgres/PG12.1/include/server/storage/lock.h"
typedef struct LOCALLOCKTAG
{
 LOCKTAG lock;
 LOCKMODE mode;
} LOCALLOCKTAG;

typedef struct LOCALLOCKOWNER
{






 struct ResourceOwnerData *owner;
 int64 nLocks;
} LOCALLOCKOWNER;

typedef struct LOCALLOCK
{

 LOCALLOCKTAG tag;


 uint32 hashcode;
 LOCK *lock;
 PROCLOCK *proclock;
 int64 nLocks;
 int numLockOwners;
 int maxLockOwners;
 LOCALLOCKOWNER *lockOwners;
 _Bool holdsStrongLockCount;
 _Bool lockCleared;
} LOCALLOCK;
# 430 "/products1/postgres/PG12.1/include/server/storage/lock.h"
typedef struct LockInstanceData
{
 LOCKTAG locktag;
 LOCKMASK holdMask;
 LOCKMODE waitLockMode;
 BackendId backend;
 LocalTransactionId lxid;
 int pid;
 int leaderPid;
 _Bool fastpath;
} LockInstanceData;

typedef struct LockData
{
 int nelements;
 LockInstanceData *locks;
} LockData;

typedef struct BlockedProcData
{
 int pid;


 int first_lock;
 int num_locks;


 int first_waiter;
 int num_waiters;
} BlockedProcData;

typedef struct BlockedProcsData
{
 BlockedProcData *procs;
 LockInstanceData *locks;
 int *waiter_pids;
 int nprocs;
 int maxprocs;
 int nlocks;
 int maxlocks;
 int npids;
 int maxpids;
} BlockedProcsData;



typedef enum
{
 LOCKACQUIRE_NOT_AVAIL,
 LOCKACQUIRE_OK,
 LOCKACQUIRE_ALREADY_HELD,
 LOCKACQUIRE_ALREADY_CLEAR
} LockAcquireResult;


typedef enum
{
 DS_NOT_YET_CHECKED,
 DS_NO_DEADLOCK,
 DS_SOFT_DEADLOCK,
 DS_HARD_DEADLOCK,
 DS_BLOCKED_BY_AUTOVACUUM

} DeadLockState;
# 524 "/products1/postgres/PG12.1/include/server/storage/lock.h"
extern void InitLocks(void);
extern LockMethod GetLocksMethodTable(const LOCK *lock);
extern LockMethod GetLockTagsMethodTable(const LOCKTAG *locktag);
extern uint32 LockTagHashCode(const LOCKTAG *locktag);
extern _Bool DoLockModesConflict(LOCKMODE mode1, LOCKMODE mode2);
extern LockAcquireResult LockAcquire(const LOCKTAG *locktag,
          LOCKMODE lockmode,
          _Bool sessionLock,
          _Bool dontWait);
extern LockAcquireResult LockAcquireExtended(const LOCKTAG *locktag,
            LOCKMODE lockmode,
            _Bool sessionLock,
            _Bool dontWait,
            _Bool reportMemoryError,
            LOCALLOCK **locallockp);
extern void AbortStrongLockAcquire(void);
extern void MarkLockClear(LOCALLOCK *locallock);
extern _Bool LockRelease(const LOCKTAG *locktag,
      LOCKMODE lockmode, _Bool sessionLock);
extern void LockReleaseAll(LOCKMETHODID lockmethodid, _Bool allLocks);
extern void LockReleaseSession(LOCKMETHODID lockmethodid);
extern void LockReleaseCurrentOwner(LOCALLOCK **locallocks, int nlocks);
extern void LockReassignCurrentOwner(LOCALLOCK **locallocks, int nlocks);
extern _Bool LockHeldByMe(const LOCKTAG *locktag, LOCKMODE lockmode);
extern _Bool LockHasWaiters(const LOCKTAG *locktag,
         LOCKMODE lockmode, _Bool sessionLock);
extern VirtualTransactionId *GetLockConflicts(const LOCKTAG *locktag,
             LOCKMODE lockmode, int *countp);
extern void AtPrepare_Locks(void);
extern void PostPrepare_Locks(TransactionId xid);
extern int LockCheckConflicts(LockMethod lockMethodTable,
          LOCKMODE lockmode,
          LOCK *lock, PROCLOCK *proclock);
extern void GrantLock(LOCK *lock, PROCLOCK *proclock, LOCKMODE lockmode);
extern void GrantAwaitedLock(void);
extern void RemoveFromWaitQueue(PGPROC *proc, uint32 hashcode);
extern Size LockShmemSize(void);
extern LockData *GetLockStatusData(void);
extern BlockedProcsData *GetBlockerStatusData(int blocked_pid);

extern xl_standby_lock *GetRunningTransactionLocks(int *nlocks);
extern const char *GetLockmodeName(LOCKMETHODID lockmethodid, LOCKMODE mode);

extern void lock_twophase_recover(TransactionId xid, uint16 info,
          void *recdata, uint32 len);
extern void lock_twophase_postcommit(TransactionId xid, uint16 info,
          void *recdata, uint32 len);
extern void lock_twophase_postabort(TransactionId xid, uint16 info,
         void *recdata, uint32 len);
extern void lock_twophase_standby_recover(TransactionId xid, uint16 info,
            void *recdata, uint32 len);

extern DeadLockState DeadLockCheck(PGPROC *proc);
extern PGPROC *GetBlockingAutoVacuumPgproc(void);
extern void DeadLockReport(void) __attribute__((noreturn));
extern void RememberSimpleDeadLock(PGPROC *proc1,
           LOCKMODE lockmode,
           LOCK *lock,
           PGPROC *proc2);
extern void InitDeadLockChecking(void);

extern int LockWaiterCount(const LOCKTAG *locktag);







extern void VirtualXactLockTableInsert(VirtualTransactionId vxid);
extern void VirtualXactLockTableCleanup(void);
extern _Bool VirtualXactLock(VirtualTransactionId vxid, _Bool wait);
# 27 "/products1/postgres/PG12.1/include/server/access/reloptions.h" 2


typedef enum relopt_type
{
 RELOPT_TYPE_BOOL,
 RELOPT_TYPE_INT,
 RELOPT_TYPE_REAL,
 RELOPT_TYPE_STRING
} relopt_type;


typedef enum relopt_kind
{
 RELOPT_KIND_HEAP = (1 << 0),
 RELOPT_KIND_TOAST = (1 << 1),
 RELOPT_KIND_BTREE = (1 << 2),
 RELOPT_KIND_HASH = (1 << 3),
 RELOPT_KIND_GIN = (1 << 4),
 RELOPT_KIND_GIST = (1 << 5),
 RELOPT_KIND_ATTRIBUTE = (1 << 6),
 RELOPT_KIND_TABLESPACE = (1 << 7),
 RELOPT_KIND_SPGIST = (1 << 8),
 RELOPT_KIND_VIEW = (1 << 9),
 RELOPT_KIND_BRIN = (1 << 10),
 RELOPT_KIND_PARTITIONED = (1 << 11),

 RELOPT_KIND_LAST_DEFAULT = RELOPT_KIND_PARTITIONED,

 RELOPT_KIND_MAX = (1 << 30)
} relopt_kind;





typedef struct relopt_gen
{
 const char *name;

 const char *desc;
 bits32 kinds;
 LOCKMODE lockmode;
 int namelen;
 relopt_type type;
} relopt_gen;


typedef struct relopt_value
{
 relopt_gen *gen;
 _Bool isset;
 union
 {
  _Bool bool_val;
  int int_val;
  double real_val;
  char *string_val;
 } values;
} relopt_value;


typedef struct relopt_bool
{
 relopt_gen gen;
 _Bool default_val;
} relopt_bool;

typedef struct relopt_int
{
 relopt_gen gen;
 int default_val;
 int min;
 int max;
} relopt_int;

typedef struct relopt_real
{
 relopt_gen gen;
 double default_val;
 double min;
 double max;
} relopt_real;


typedef void (*validate_string_relopt) (const char *value);

typedef struct relopt_string
{
 relopt_gen gen;
 int default_len;
 _Bool default_isnull;
 validate_string_relopt validate_cb;
 char *default_val;
} relopt_string;


typedef struct
{
 const char *optname;
 relopt_type opttype;
 int offset;
} relopt_parse_elt;
# 248 "/products1/postgres/PG12.1/include/server/access/reloptions.h"
extern relopt_kind add_reloption_kind(void);
extern void add_bool_reloption(bits32 kinds, const char *name, const char *desc,
          _Bool default_val);
extern void add_int_reloption(bits32 kinds, const char *name, const char *desc,
         int default_val, int min_val, int max_val);
extern void add_real_reloption(bits32 kinds, const char *name, const char *desc,
          double default_val, double min_val, double max_val);
extern void add_string_reloption(bits32 kinds, const char *name, const char *desc,
         const char *default_val, validate_string_relopt validator);

extern Datum transformRelOptions(Datum oldOptions, List *defList,
         const char *namspace, char *validnsps[],
         _Bool acceptOidsOff, _Bool isReset);
extern List *untransformRelOptions(Datum options);
extern bytea *extractRelOptions(HeapTuple tuple, TupleDesc tupdesc,
        amoptions_function amoptions);
extern relopt_value *parseRelOptions(Datum options, _Bool validate,
          relopt_kind kind, int *numrelopts);
extern void *allocateReloptStruct(Size base, relopt_value *options,
          int numoptions);
extern void fillRelOptions(void *rdopts, Size basesize,
         relopt_value *options, int numoptions,
         _Bool validate,
         const relopt_parse_elt *elems, int nelems);

extern bytea *default_reloptions(Datum reloptions, _Bool validate,
         relopt_kind kind);
extern bytea *heap_reloptions(char relkind, Datum reloptions, _Bool validate);
extern bytea *view_reloptions(Datum reloptions, _Bool validate);
extern bytea *index_reloptions(amoptions_function amoptions, Datum reloptions,
          _Bool validate);
extern bytea *attribute_reloptions(Datum reloptions, _Bool validate);
extern bytea *tablespace_reloptions(Datum reloptions, _Bool validate);
extern LOCKMODE AlterTableGetRelOptionsLockLevel(List *defList);
# 13 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/access/sysattr.h" 1
# 14 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/access/xact.h" 1
# 18 "/products1/postgres/PG12.1/include/server/access/xact.h"
# 1 "/products1/postgres/PG12.1/include/server/access/xlogreader.h" 1
# 28 "/products1/postgres/PG12.1/include/server/access/xlogreader.h"
# 1 "/products1/postgres/PG12.1/include/server/access/xlogrecord.h" 1
# 14 "/products1/postgres/PG12.1/include/server/access/xlogrecord.h"
# 1 "/products1/postgres/PG12.1/include/server/access/rmgr.h" 1
# 11 "/products1/postgres/PG12.1/include/server/access/rmgr.h"
typedef uint8 RmgrId;
# 25 "/products1/postgres/PG12.1/include/server/access/rmgr.h"
typedef enum RmgrIds
{
# 1 "/products1/postgres/PG12.1/include/server/access/rmgrlist.h" 1
# 28 "/products1/postgres/PG12.1/include/server/access/rmgrlist.h"
RM_XLOG_ID,
RM_XACT_ID,
RM_SMGR_ID,
RM_CLOG_ID,
RM_DBASE_ID,
RM_TBLSPC_ID,
RM_MULTIXACT_ID,
RM_RELMAP_ID,
RM_STANDBY_ID,
RM_HEAP2_ID,
RM_HEAP_ID,
RM_BTREE_ID,
RM_HASH_ID,
RM_GIN_ID,
RM_GIST_ID,
RM_SEQ_ID,
RM_SPGIST_ID,
RM_BRIN_ID,
RM_COMMIT_TS_ID,
RM_REPLORIGIN_ID,
RM_GENERIC_ID,
RM_LOGICALMSG_ID,
# 28 "/products1/postgres/PG12.1/include/server/access/rmgr.h" 2
 RM_NEXT_ID
} RmgrIds;
# 15 "/products1/postgres/PG12.1/include/server/access/xlogrecord.h" 2

# 1 "/products1/postgres/PG12.1/include/server/port/pg_crc32c.h" 1
# 36 "/products1/postgres/PG12.1/include/server/port/pg_crc32c.h"
# 1 "/products1/postgres/PG12.1/include/server/port/pg_bswap.h" 1
# 37 "/products1/postgres/PG12.1/include/server/port/pg_crc32c.h" 2

typedef uint32 pg_crc32c;
# 71 "/products1/postgres/PG12.1/include/server/port/pg_crc32c.h"
extern pg_crc32c pg_comp_crc32c_sb8(pg_crc32c crc, const void *data, size_t len);
extern pg_crc32c (*pg_comp_crc32c) (pg_crc32c crc, const void *data, size_t len);


extern pg_crc32c pg_comp_crc32c_sse42(pg_crc32c crc, const void *data, size_t len);
# 17 "/products1/postgres/PG12.1/include/server/access/xlogrecord.h" 2

# 1 "/products1/postgres/PG12.1/include/server/storage/relfilenode.h" 1
# 17 "/products1/postgres/PG12.1/include/server/storage/relfilenode.h"
# 1 "/products1/postgres/PG12.1/include/server/common/relpath.h" 1
# 20 "/products1/postgres/PG12.1/include/server/common/relpath.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/catversion.h" 1
# 21 "/products1/postgres/PG12.1/include/server/common/relpath.h" 2
# 40 "/products1/postgres/PG12.1/include/server/common/relpath.h"
typedef enum ForkNumber
{
 InvalidForkNumber = -1,
 MAIN_FORKNUM = 0,
 FSM_FORKNUM,
 VISIBILITYMAP_FORKNUM,
 INIT_FORKNUM






} ForkNumber;





extern const char *const forkNames[];

extern ForkNumber forkname_to_number(const char *forkName);
extern int forkname_chars(const char *str, ForkNumber *fork);




extern char *GetDatabasePath(Oid dbNode, Oid spcNode);

extern char *GetRelationPath(Oid dbNode, Oid spcNode, Oid relNode,
        int backendId, ForkNumber forkNumber);
# 18 "/products1/postgres/PG12.1/include/server/storage/relfilenode.h" 2
# 57 "/products1/postgres/PG12.1/include/server/storage/relfilenode.h"
typedef struct RelFileNode
{
 Oid spcNode;
 Oid dbNode;
 Oid relNode;
} RelFileNode;
# 72 "/products1/postgres/PG12.1/include/server/storage/relfilenode.h"
typedef struct RelFileNodeBackend
{
 RelFileNode node;
 BackendId backend;
} RelFileNodeBackend;
# 19 "/products1/postgres/PG12.1/include/server/access/xlogrecord.h" 2
# 41 "/products1/postgres/PG12.1/include/server/access/xlogrecord.h"
typedef struct XLogRecord
{
 uint32 xl_tot_len;
 TransactionId xl_xid;
 XLogRecPtr xl_prev;
 uint8 xl_info;
 RmgrId xl_rmid;

 pg_crc32c xl_crc;



} XLogRecord;
# 92 "/products1/postgres/PG12.1/include/server/access/xlogrecord.h"
typedef struct XLogRecordBlockHeader
{
 uint8 id;
 uint8 fork_flags;
 uint16 data_length;





} XLogRecordBlockHeader;
# 130 "/products1/postgres/PG12.1/include/server/access/xlogrecord.h"
typedef struct XLogRecordBlockImageHeader
{
 uint16 length;
 uint16 hole_offset;
 uint8 bimg_info;





} XLogRecordBlockImageHeader;
# 155 "/products1/postgres/PG12.1/include/server/access/xlogrecord.h"
typedef struct XLogRecordBlockCompressHeader
{
 uint16 hole_length;
} XLogRecordBlockCompressHeader;
# 194 "/products1/postgres/PG12.1/include/server/access/xlogrecord.h"
typedef struct XLogRecordDataHeaderShort
{
 uint8 id;
 uint8 data_length;
} XLogRecordDataHeaderShort;



typedef struct XLogRecordDataHeaderLong
{
 uint8 id;

} XLogRecordDataHeaderLong;
# 29 "/products1/postgres/PG12.1/include/server/access/xlogreader.h" 2

typedef struct XLogReaderState XLogReaderState;


typedef int (*XLogPageReadCB) (XLogReaderState *xlogreader,
          XLogRecPtr targetPagePtr,
          int reqLen,
          XLogRecPtr targetRecPtr,
          char *readBuf,
          TimeLineID *pageTLI);

typedef struct
{

 _Bool in_use;


 RelFileNode rnode;
 ForkNumber forknum;
 BlockNumber blkno;


 uint8 flags;


 _Bool has_image;
 _Bool apply_image;
 char *bkp_image;
 uint16 hole_offset;
 uint16 hole_length;
 uint16 bimg_len;
 uint8 bimg_info;


 _Bool has_data;
 char *data;
 uint16 data_len;
 uint16 data_bufsz;
} DecodedBkpBlock;

struct XLogReaderState
{
# 79 "/products1/postgres/PG12.1/include/server/access/xlogreader.h"
 int wal_segment_size;
# 102 "/products1/postgres/PG12.1/include/server/access/xlogreader.h"
 XLogPageReadCB read_page;





 uint64 system_identifier;




 void *private_data;





 XLogRecPtr ReadRecPtr;
 XLogRecPtr EndRecPtr;
# 130 "/products1/postgres/PG12.1/include/server/access/xlogreader.h"
 XLogRecord *decoded_record;

 char *main_data;
 uint32 main_data_len;
 uint32 main_data_bufsz;

 RepOriginId record_origin;


 DecodedBkpBlock blocks[32 + 1];

 int max_block_id;
# 152 "/products1/postgres/PG12.1/include/server/access/xlogreader.h"
 char *readBuf;
 uint32 readLen;


 XLogSegNo readSegNo;
 uint32 readOff;
 TimeLineID readPageTLI;





 XLogRecPtr latestPagePtr;
 TimeLineID latestPageTLI;


 XLogRecPtr currRecPtr;

 TimeLineID currTLI;
# 180 "/products1/postgres/PG12.1/include/server/access/xlogreader.h"
 XLogRecPtr currTLIValidUntil;





 TimeLineID nextTLI;





 char *readRecordBuf;
 uint32 readRecordBufSize;


 char *errormsg_buf;
};


extern XLogReaderState *XLogReaderAllocate(int wal_segment_size,
             XLogPageReadCB pagereadfunc,
             void *private_data);


extern void XLogReaderFree(XLogReaderState *state);


extern struct XLogRecord *XLogReadRecord(XLogReaderState *state,
           XLogRecPtr recptr, char **errormsg);


extern _Bool XLogReaderValidatePageHeader(XLogReaderState *state,
           XLogRecPtr recptr, char *phdr);


extern void XLogReaderInvalReadState(XLogReaderState *state);







extern _Bool DecodeXLogRecord(XLogReaderState *state, XLogRecord *record,
        char **errmsg);
# 243 "/products1/postgres/PG12.1/include/server/access/xlogreader.h"
extern _Bool RestoreBlockImage(XLogReaderState *recoder, uint8 block_id, char *dst);
extern char *XLogRecGetBlockData(XLogReaderState *record, uint8 block_id, Size *len);
extern _Bool XLogRecGetBlockTag(XLogReaderState *record, uint8 block_id,
          RelFileNode *rnode, ForkNumber *forknum,
          BlockNumber *blknum);
# 19 "/products1/postgres/PG12.1/include/server/access/xact.h" 2



# 1 "/products1/postgres/PG12.1/include/server/storage/sinval.h" 1
# 17 "/products1/postgres/PG12.1/include/server/storage/sinval.h"
# 1 "/usr/include/signal.h" 1 3 4
# 30 "/usr/include/signal.h" 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 103 "/usr/include/bits/sigset.h" 3 4
extern int __sigismember (const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 117 "/usr/include/bits/sigset.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int __sigismember (const __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return (__set->__val[__word] & __mask) ? 1 : 0; }
extern __inline __attribute__ ((__gnu_inline__)) int __sigaddset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] |= __mask), 0); }
extern __inline __attribute__ ((__gnu_inline__)) int __sigdelset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] &= ~__mask), 0); }
# 33 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;

# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/signum.h" 1 3 4
# 58 "/usr/include/signal.h" 2 3 4
# 75 "/usr/include/signal.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 76 "/usr/include/signal.h" 2 3 4




# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 24 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 2 3 4
# 58 "/usr/include/bits/siginfo.h" 3 4
typedef __clock_t __sigchld_clock_t;



typedef struct
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __sigchld_clock_t si_utime;
     __sigchld_clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;


 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;
      } _sifields;
  } siginfo_t ;
# 151 "/usr/include/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 81 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));







extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 114 "/usr/include/signal.h" 3 4





extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));






extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern void psignal (int __sig, const char *__s);




extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 169 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 178 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 197 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 212 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/bits/sigaction.h" 1 3 4
# 24 "/usr/include/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 254 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));
# 311 "/usr/include/signal.h" 3 4
extern const char *const _sys_siglist[65];
extern const char *const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 335 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 29 "/usr/include/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t padding[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 121 "/usr/include/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t padding[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t reserved1[2];
  __uint64_t reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 341 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 351 "/usr/include/signal.h" 2 3 4




extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__));

# 1 "/usr/include/bits/sigstack.h" 1 3 4
# 25 "/usr/include/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 49 "/usr/include/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 358 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/sys/ucontext.h" 1 3 4
# 22 "/usr/include/sys/ucontext.h" 3 4
# 1 "/usr/include/signal.h" 1 3 4
# 23 "/usr/include/sys/ucontext.h" 2 3 4
# 31 "/usr/include/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;





typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int padding[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t padding[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 361 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));



extern int sigaltstack (const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));







extern int sighold (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern int sigignore (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 30 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__ , __leaf__));
# 397 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));




# 18 "/products1/postgres/PG12.1/include/server/storage/sinval.h" 2
# 60 "/products1/postgres/PG12.1/include/server/storage/sinval.h"
typedef struct
{
 int8 id;
 Oid dbId;
 uint32 hashValue;
} SharedInvalCatcacheMsg;



typedef struct
{
 int8 id;
 Oid dbId;
 Oid catId;
} SharedInvalCatalogMsg;



typedef struct
{
 int8 id;
 Oid dbId;
 Oid relId;
} SharedInvalRelcacheMsg;



typedef struct
{

 int8 id;
 int8 backend_hi;
 uint16 backend_lo;
 RelFileNode rnode;
} SharedInvalSmgrMsg;



typedef struct
{
 int8 id;
 Oid dbId;
} SharedInvalRelmapMsg;



typedef struct
{
 int8 id;
 Oid dbId;
 Oid relId;
} SharedInvalSnapshotMsg;

typedef union
{
 int8 id;
 SharedInvalCatcacheMsg cc;
 SharedInvalCatalogMsg cat;
 SharedInvalRelcacheMsg rc;
 SharedInvalSmgrMsg sm;
 SharedInvalRelmapMsg rm;
 SharedInvalSnapshotMsg sn;
} SharedInvalidationMessage;



extern uint64 SharedInvalidMessageCounter;

extern volatile sig_atomic_t catchupInterruptPending;

extern void SendSharedInvalidMessages(const SharedInvalidationMessage *msgs,
           int n);
extern void ReceiveSharedInvalidMessages(void (*invalFunction) (SharedInvalidationMessage *msg),
           void (*resetFunction) (void));


extern void HandleCatchupInterrupt(void);






extern void ProcessCatchupInterrupt(void);

extern int xactGetCommittedInvalidationMessages(SharedInvalidationMessage **msgs,
             _Bool *RelcacheInitFileInval);
extern void ProcessCommittedInvalidationMessages(SharedInvalidationMessage *msgs,
             int nmsgs, _Bool RelcacheInitFileInval,
             Oid dbid, Oid tsid);

extern void LocalExecuteInvalidationMessage(SharedInvalidationMessage *msg);
# 23 "/products1/postgres/PG12.1/include/server/access/xact.h" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/datetime.h" 1
# 20 "/products1/postgres/PG12.1/include/server/utils/datetime.h"
# 1 "/products1/postgres/PG12.1/include/server/utils/timestamp.h" 1
# 18 "/products1/postgres/PG12.1/include/server/utils/timestamp.h"
# 1 "/products1/postgres/PG12.1/include/server/pgtime.h" 1
# 23 "/products1/postgres/PG12.1/include/server/pgtime.h"
typedef int64 pg_time_t;

struct pg_tm
{
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long int tm_gmtoff;
 const char *tm_zone;
};

typedef struct pg_tz pg_tz;
typedef struct pg_tzenum pg_tzenum;






extern struct pg_tm *pg_localtime(const pg_time_t *timep, const pg_tz *tz);
extern struct pg_tm *pg_gmtime(const pg_time_t *timep);
extern int pg_next_dst_boundary(const pg_time_t *timep,
         long int *before_gmtoff,
         int *before_isdst,
         pg_time_t *boundary,
         long int *after_gmtoff,
         int *after_isdst,
         const pg_tz *tz);
extern _Bool pg_interpret_timezone_abbrev(const char *abbrev,
           const pg_time_t *timep,
           long int *gmtoff,
           int *isdst,
           const pg_tz *tz);
extern _Bool pg_get_timezone_offset(const pg_tz *tz, long int *gmtoff);
extern const char *pg_get_timezone_name(pg_tz *tz);
extern _Bool pg_tz_acceptable(pg_tz *tz);



extern size_t pg_strftime(char *s, size_t max, const char *format,
        const struct pg_tm *tm);



extern pg_tz *session_timezone;
extern pg_tz *log_timezone;

extern void pg_timezone_initialize(void);
extern pg_tz *pg_tzset(const char *tzname);
extern pg_tz *pg_tzset_offset(long gmtoffset);

extern pg_tzenum *pg_tzenumerate_start(void);
extern pg_tz *pg_tzenumerate_next(pg_tzenum *dir);
extern void pg_tzenumerate_end(pg_tzenum *dir);
# 19 "/products1/postgres/PG12.1/include/server/utils/timestamp.h" 2
# 60 "/products1/postgres/PG12.1/include/server/utils/timestamp.h"
extern TimestampTz PgStartTime;


extern TimestampTz PgReloadTime;




extern int32 anytimestamp_typmod_check(_Bool istz, int32 typmod);

extern TimestampTz GetCurrentTimestamp(void);
extern TimestampTz GetSQLCurrentTimestamp(int32 typmod);
extern Timestamp GetSQLLocalTimestamp(int32 typmod);
extern void TimestampDifference(TimestampTz start_time, TimestampTz stop_time,
        long *secs, int *microsecs);
extern _Bool TimestampDifferenceExceeds(TimestampTz start_time,
            TimestampTz stop_time,
            int msec);

extern TimestampTz time_t_to_timestamptz(pg_time_t tm);
extern pg_time_t timestamptz_to_time_t(TimestampTz t);

extern const char *timestamptz_to_str(TimestampTz t);

extern int tm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *dt);
extern int timestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm,
       fsec_t *fsec, const char **tzn, pg_tz *attimezone);
extern void dt2time(Timestamp dt, int *hour, int *min, int *sec, fsec_t *fsec);

extern int interval2tm(Interval span, struct pg_tm *tm, fsec_t *fsec);
extern int tm2interval(struct pg_tm *tm, fsec_t fsec, Interval *span);

extern Timestamp SetEpochTimestamp(void);
extern void GetEpochTime(struct pg_tm *tm);

extern int timestamp_cmp_internal(Timestamp dt1, Timestamp dt2);




extern int isoweek2j(int year, int week);
extern void isoweek2date(int woy, int *year, int *mon, int *mday);
extern void isoweekdate2date(int isoweek, int wday, int *year, int *mon, int *mday);
extern int date2isoweek(int year, int mon, int mday);
extern int date2isoyear(int year, int mon, int mday);
extern int date2isoyearday(int year, int mon, int mday);

extern _Bool TimestampTimestampTzRequiresRewrite(void);
# 21 "/products1/postgres/PG12.1/include/server/utils/datetime.h" 2


struct tzEntry;
# 208 "/products1/postgres/PG12.1/include/server/utils/datetime.h"
typedef struct
{
 char token[10 + 1];
 char type;
 int32 value;
} datetkn;


typedef struct TimeZoneAbbrevTable
{
 Size tblsize;
 int numabbrevs;
 datetkn abbrevs[];

} TimeZoneAbbrevTable;


typedef struct DynamicZoneAbbrev
{
 pg_tz *tz;
 char zone[];
} DynamicZoneAbbrev;
# 260 "/products1/postgres/PG12.1/include/server/utils/datetime.h"
extern const char *const months[];
extern const char *const days[];
extern const int day_tab[2][13];
# 287 "/products1/postgres/PG12.1/include/server/utils/datetime.h"
extern void GetCurrentDateTime(struct pg_tm *tm);
extern void GetCurrentTimeUsec(struct pg_tm *tm, fsec_t *fsec, int *tzp);
extern void j2date(int jd, int *year, int *month, int *day);
extern int date2j(int year, int month, int day);

extern int ParseDateTime(const char *timestr, char *workbuf, size_t buflen,
        char **field, int *ftype,
        int maxfields, int *numfields);
extern int DecodeDateTime(char **field, int *ftype,
         int nf, int *dtype,
         struct pg_tm *tm, fsec_t *fsec, int *tzp);
extern int DecodeTimezone(char *str, int *tzp);
extern int DecodeTimeOnly(char **field, int *ftype,
         int nf, int *dtype,
         struct pg_tm *tm, fsec_t *fsec, int *tzp);
extern int DecodeInterval(char **field, int *ftype, int nf, int range,
         int *dtype, struct pg_tm *tm, fsec_t *fsec);
extern int DecodeISO8601Interval(char *str,
          int *dtype, struct pg_tm *tm, fsec_t *fsec);

extern void DateTimeParseError(int dterr, const char *str,
          const char *datatype) __attribute__((noreturn));

extern int DetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp);
extern int DetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp);
extern int DetermineTimeZoneAbbrevOffsetTS(TimestampTz ts, const char *abbr,
           pg_tz *tzp, int *isdst);

extern void EncodeDateOnly(struct pg_tm *tm, int style, char *str);
extern void EncodeTimeOnly(struct pg_tm *tm, fsec_t fsec, _Bool print_tz, int tz, int style, char *str);
extern void EncodeDateTime(struct pg_tm *tm, fsec_t fsec, _Bool print_tz, int tz, const char *tzn, int style, char *str);
extern void EncodeInterval(struct pg_tm *tm, fsec_t fsec, int style, char *str);
extern void EncodeSpecialTimestamp(Timestamp dt, char *str);

extern int ValidateDate(int fmask, _Bool isjulian, _Bool is2digits, _Bool bc,
       struct pg_tm *tm);

extern int DecodeTimezoneAbbrev(int field, char *lowtoken,
         int *offset, pg_tz **tz);
extern int DecodeSpecial(int field, char *lowtoken, int *val);
extern int DecodeUnits(int field, char *lowtoken, int *val);

extern int j2day(int jd);

extern Node *TemporalSimplify(int32 max_precis, Node *node);

extern _Bool CheckDateTokenTables(void);

extern TimeZoneAbbrevTable *ConvertTimeZoneAbbrevs(struct tzEntry *abbrevs,
               int n);
extern void InstallTimeZoneAbbrevs(TimeZoneAbbrevTable *tbl);
# 24 "/products1/postgres/PG12.1/include/server/access/xact.h" 2
# 41 "/products1/postgres/PG12.1/include/server/access/xact.h"
extern int DefaultXactIsoLevel;
extern int XactIsoLevel;
# 55 "/products1/postgres/PG12.1/include/server/access/xact.h"
extern _Bool DefaultXactReadOnly;
extern _Bool XactReadOnly;


extern _Bool xact_is_sampled;





extern _Bool DefaultXactDeferrable;
extern _Bool XactDeferrable;

typedef enum
{
 SYNCHRONOUS_COMMIT_OFF,
 SYNCHRONOUS_COMMIT_LOCAL_FLUSH,
 SYNCHRONOUS_COMMIT_REMOTE_WRITE,

 SYNCHRONOUS_COMMIT_REMOTE_FLUSH,
 SYNCHRONOUS_COMMIT_REMOTE_APPLY
} SyncCommitLevel;





extern int synchronous_commit;
# 91 "/products1/postgres/PG12.1/include/server/access/xact.h"
extern int MyXactFlags;
# 108 "/products1/postgres/PG12.1/include/server/access/xact.h"
typedef enum
{
 XACT_EVENT_COMMIT,
 XACT_EVENT_PARALLEL_COMMIT,
 XACT_EVENT_ABORT,
 XACT_EVENT_PARALLEL_ABORT,
 XACT_EVENT_PREPARE,
 XACT_EVENT_PRE_COMMIT,
 XACT_EVENT_PARALLEL_PRE_COMMIT,
 XACT_EVENT_PRE_PREPARE
} XactEvent;

typedef void (*XactCallback) (XactEvent event, void *arg);

typedef enum
{
 SUBXACT_EVENT_START_SUB,
 SUBXACT_EVENT_COMMIT_SUB,
 SUBXACT_EVENT_ABORT_SUB,
 SUBXACT_EVENT_PRE_COMMIT_SUB
} SubXactEvent;

typedef void (*SubXactCallback) (SubXactEvent event, SubTransactionId mySubid,
         SubTransactionId parentSubid, void *arg);
# 191 "/products1/postgres/PG12.1/include/server/access/xact.h"
typedef struct xl_xact_assignment
{
 TransactionId xtop;
 int nsubxacts;
 TransactionId xsub[];
} xl_xact_assignment;
# 217 "/products1/postgres/PG12.1/include/server/access/xact.h"
typedef struct xl_xact_xinfo
{





 uint32 xinfo;
} xl_xact_xinfo;

typedef struct xl_xact_dbinfo
{
 Oid dbId;
 Oid tsId;
} xl_xact_dbinfo;

typedef struct xl_xact_subxacts
{
 int nsubxacts;
 TransactionId subxacts[];
} xl_xact_subxacts;


typedef struct xl_xact_relfilenodes
{
 int nrels;
 RelFileNode xnodes[];
} xl_xact_relfilenodes;


typedef struct xl_xact_invals
{
 int nmsgs;
 SharedInvalidationMessage msgs[];
} xl_xact_invals;


typedef struct xl_xact_twophase
{
 TransactionId xid;
} xl_xact_twophase;

typedef struct xl_xact_origin
{
 XLogRecPtr origin_lsn;
 TimestampTz origin_timestamp;
} xl_xact_origin;

typedef struct xl_xact_commit
{
 TimestampTz xact_time;
# 277 "/products1/postgres/PG12.1/include/server/access/xact.h"
} xl_xact_commit;


typedef struct xl_xact_abort
{
 TimestampTz xact_time;
# 292 "/products1/postgres/PG12.1/include/server/access/xact.h"
} xl_xact_abort;







typedef struct xl_xact_parsed_commit
{
 TimestampTz xact_time;
 uint32 xinfo;

 Oid dbId;
 Oid tsId;

 int nsubxacts;
 TransactionId *subxacts;

 int nrels;
 RelFileNode *xnodes;

 int nmsgs;
 SharedInvalidationMessage *msgs;

 TransactionId twophase_xid;
 char twophase_gid[200];
 int nabortrels;
 RelFileNode *abortnodes;

 XLogRecPtr origin_lsn;
 TimestampTz origin_timestamp;
} xl_xact_parsed_commit;

typedef xl_xact_parsed_commit xl_xact_parsed_prepare;

typedef struct xl_xact_parsed_abort
{
 TimestampTz xact_time;
 uint32 xinfo;

 Oid dbId;
 Oid tsId;

 int nsubxacts;
 TransactionId *subxacts;

 int nrels;
 RelFileNode *xnodes;

 TransactionId twophase_xid;
 char twophase_gid[200];

 XLogRecPtr origin_lsn;
 TimestampTz origin_timestamp;
} xl_xact_parsed_abort;






extern _Bool IsTransactionState(void);
extern _Bool IsAbortedTransactionBlockState(void);
extern TransactionId GetTopTransactionId(void);
extern TransactionId GetTopTransactionIdIfAny(void);
extern TransactionId GetCurrentTransactionId(void);
extern TransactionId GetCurrentTransactionIdIfAny(void);
extern TransactionId GetStableLatestTransactionId(void);
extern SubTransactionId GetCurrentSubTransactionId(void);
extern FullTransactionId GetTopFullTransactionId(void);
extern FullTransactionId GetTopFullTransactionIdIfAny(void);
extern FullTransactionId GetCurrentFullTransactionId(void);
extern FullTransactionId GetCurrentFullTransactionIdIfAny(void);
extern void MarkCurrentTransactionIdLoggedIfAny(void);
extern _Bool SubTransactionIsActive(SubTransactionId subxid);
extern CommandId GetCurrentCommandId(_Bool used);
extern void SetParallelStartTimestamps(TimestampTz xact_ts, TimestampTz stmt_ts);
extern TimestampTz GetCurrentTransactionStartTimestamp(void);
extern TimestampTz GetCurrentStatementStartTimestamp(void);
extern TimestampTz GetCurrentTransactionStopTimestamp(void);
extern void SetCurrentStatementStartTimestamp(void);
extern int GetCurrentTransactionNestLevel(void);
extern _Bool TransactionIdIsCurrentTransactionId(TransactionId xid);
extern void CommandCounterIncrement(void);
extern void ForceSyncCommit(void);
extern void StartTransactionCommand(void);
extern void SaveTransactionCharacteristics(void);
extern void RestoreTransactionCharacteristics(void);
extern void CommitTransactionCommand(void);
extern void AbortCurrentTransaction(void);
extern void BeginTransactionBlock(void);
extern _Bool EndTransactionBlock(_Bool chain);
extern _Bool PrepareTransactionBlock(const char *gid);
extern void UserAbortTransactionBlock(_Bool chain);
extern void BeginImplicitTransactionBlock(void);
extern void EndImplicitTransactionBlock(void);
extern void ReleaseSavepoint(const char *name);
extern void DefineSavepoint(const char *name);
extern void RollbackToSavepoint(const char *name);
extern void BeginInternalSubTransaction(const char *name);
extern void ReleaseCurrentSubTransaction(void);
extern void RollbackAndReleaseCurrentSubTransaction(void);
extern _Bool IsSubTransaction(void);
extern Size EstimateTransactionStateSpace(void);
extern void SerializeTransactionState(Size maxsize, char *start_address);
extern void StartParallelWorkerTransaction(char *tstatespace);
extern void EndParallelWorkerTransaction(void);
extern _Bool IsTransactionBlock(void);
extern _Bool IsTransactionOrTransactionBlock(void);
extern char TransactionBlockStatusCode(void);
extern void AbortOutOfAnyTransaction(void);
extern void PreventInTransactionBlock(_Bool isTopLevel, const char *stmtType);
extern void RequireTransactionBlock(_Bool isTopLevel, const char *stmtType);
extern void WarnNoTransactionBlock(_Bool isTopLevel, const char *stmtType);
extern _Bool IsInTransactionBlock(_Bool isTopLevel);
extern void RegisterXactCallback(XactCallback callback, void *arg);
extern void UnregisterXactCallback(XactCallback callback, void *arg);
extern void RegisterSubXactCallback(SubXactCallback callback, void *arg);
extern void UnregisterSubXactCallback(SubXactCallback callback, void *arg);

extern int xactGetCommittedChildren(TransactionId **ptr);

extern XLogRecPtr XactLogCommitRecord(TimestampTz commit_time,
           int nsubxacts, TransactionId *subxacts,
           int nrels, RelFileNode *rels,
           int nmsgs, SharedInvalidationMessage *msgs,
           _Bool relcacheInval, _Bool forceSync,
           int xactflags,
           TransactionId twophase_xid,
           const char *twophase_gid);

extern XLogRecPtr XactLogAbortRecord(TimestampTz abort_time,
          int nsubxacts, TransactionId *subxacts,
          int nrels, RelFileNode *rels,
          int xactflags, TransactionId twophase_xid,
          const char *twophase_gid);
extern void xact_redo(XLogReaderState *record);


extern void xact_desc(StringInfo buf, XLogReaderState *record);
extern const char *xact_identify(uint8 info);


extern void ParseCommitRecord(uint8 info, xl_xact_commit *xlrec, xl_xact_parsed_commit *parsed);
extern void ParseAbortRecord(uint8 info, xl_xact_abort *xlrec, xl_xact_parsed_abort *parsed);

extern void EnterParallelMode(void);
extern void ExitParallelMode(void);
extern _Bool IsInParallelMode(void);
# 15 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/indexing.h" 1
# 29 "/products1/postgres/PG12.1/include/server/catalog/indexing.h"
typedef struct ResultRelInfo *CatalogIndexState;




extern CatalogIndexState CatalogOpenIndexes(Relation heapRel);
extern void CatalogCloseIndexes(CatalogIndexState indstate);
extern void CatalogTupleInsert(Relation heapRel, HeapTuple tup);
extern void CatalogTupleInsertWithInfo(Relation heapRel, HeapTuple tup,
            CatalogIndexState indstate);
extern void CatalogTupleUpdate(Relation heapRel, ItemPointer otid,
          HeapTuple tup);
extern void CatalogTupleUpdateWithInfo(Relation heapRel,
            ItemPointer otid, HeapTuple tup,
            CatalogIndexState indstate);
extern void CatalogTupleDelete(Relation heapRel, ItemPointer tid);
# 68 "/products1/postgres/PG12.1/include/server/catalog/indexing.h"
extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;

extern int no_such_variable;

extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;

extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;


extern int no_such_variable;
# 16 "db2_fdw.c" 2

# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_cast.h" 1
# 24 "/products1/postgres/PG12.1/include/server/catalog/pg_cast.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_cast_d.h" 1
# 42 "/products1/postgres/PG12.1/include/server/catalog/pg_cast_d.h"
typedef enum CoercionCodes
{
 COERCION_CODE_IMPLICIT = 'i',
 COERCION_CODE_ASSIGNMENT = 'a',
 COERCION_CODE_EXPLICIT = 'e'
} CoercionCodes;






typedef enum CoercionMethod
{
 COERCION_METHOD_FUNCTION = 'f',
 COERCION_METHOD_BINARY = 'b',
 COERCION_METHOD_INOUT = 'i'
} CoercionMethod;
# 25 "/products1/postgres/PG12.1/include/server/catalog/pg_cast.h" 2






typedef struct FormData_pg_cast
{
 Oid oid;


 Oid castsource ;


 Oid casttarget ;


 Oid castfunc ;


 char castcontext;


 char castmethod;
} FormData_pg_cast;






typedef FormData_pg_cast *Form_pg_cast;
# 18 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_collation.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_collation.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_collation_d.h" 1
# 23 "/products1/postgres/PG12.1/include/server/catalog/pg_collation.h" 2






typedef struct FormData_pg_collation
{
 Oid oid;
 NameData collname;
 Oid collnamespace;
 Oid collowner;
 char collprovider;
 _Bool collisdeterministic ;
 int32 collencoding;
 NameData collcollate;
 NameData collctype;




} FormData_pg_collation;






typedef FormData_pg_collation *Form_pg_collation;
# 62 "/products1/postgres/PG12.1/include/server/catalog/pg_collation.h"
extern Oid CollationCreate(const char *collname, Oid collnamespace,
       Oid collowner,
       char collprovider,
       _Bool collisdeterministic,
       int32 collencoding,
       const char *collcollate, const char *collctype,
       const char *collversion,
       _Bool if_not_exists,
       _Bool quiet);
extern void RemoveCollationById(Oid collationOid);
# 19 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_data_wrapper.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_data_wrapper.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_data_wrapper_d.h" 1
# 23 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_data_wrapper.h" 2






typedef struct FormData_pg_foreign_data_wrapper
{
 Oid oid;
 NameData fdwname;
 Oid fdwowner;
 Oid fdwhandler;
 Oid fdwvalidator;





} FormData_pg_foreign_data_wrapper;






typedef FormData_pg_foreign_data_wrapper *Form_pg_foreign_data_wrapper;
# 20 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_server.h" 1
# 21 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_server.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_server_d.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_server.h" 2






typedef struct FormData_pg_foreign_server
{
 Oid oid;
 NameData srvname;
 Oid srvowner;
 Oid srvfdw;







} FormData_pg_foreign_server;






typedef FormData_pg_foreign_server *Form_pg_foreign_server;
# 21 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_table.h" 1
# 21 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_table.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_table_d.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_foreign_table.h" 2






typedef struct FormData_pg_foreign_table
{
 Oid ftrelid;
 Oid ftserver;




} FormData_pg_foreign_table;






typedef FormData_pg_foreign_table *Form_pg_foreign_table;
# 22 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_namespace.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_namespace.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_namespace_d.h" 1
# 23 "/products1/postgres/PG12.1/include/server/catalog/pg_namespace.h" 2
# 34 "/products1/postgres/PG12.1/include/server/catalog/pg_namespace.h"
typedef struct FormData_pg_namespace
{
 Oid oid;

 NameData nspname;
 Oid nspowner;




} FormData_pg_namespace;






typedef FormData_pg_namespace *Form_pg_namespace;




extern Oid NamespaceCreate(const char *nspName, Oid ownerId, _Bool isTemp);
# 23 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_operator.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_operator.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_operator_d.h" 1
# 23 "/products1/postgres/PG12.1/include/server/catalog/pg_operator.h" 2

# 1 "/products1/postgres/PG12.1/include/server/catalog/objectaddress.h" 1
# 18 "/products1/postgres/PG12.1/include/server/catalog/objectaddress.h"
# 1 "/products1/postgres/PG12.1/include/server/utils/acl.h" 1
# 36 "/products1/postgres/PG12.1/include/server/utils/acl.h"
# 1 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h" 1
# 26 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
# 1 "/products1/postgres/PG12.1/include/server/nodes/lockoptions.h" 1
# 21 "/products1/postgres/PG12.1/include/server/nodes/lockoptions.h"
typedef enum LockClauseStrength
{
 LCS_NONE,
 LCS_FORKEYSHARE,
 LCS_FORSHARE,
 LCS_FORNOKEYUPDATE,
 LCS_FORUPDATE
} LockClauseStrength;







typedef enum LockWaitPolicy
{

 LockWaitBlock,

 LockWaitSkip,

 LockWaitError
} LockWaitPolicy;




typedef enum LockTupleMode
{

 LockTupleKeyShare,

 LockTupleShare,

 LockTupleNoKeyExclusive,

 LockTupleExclusive
} LockTupleMode;
# 27 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h" 2
# 1 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h" 1
# 39 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct Alias
{
 NodeTag type;
 char *aliasname;
 List *colnames;
} Alias;


typedef enum OnCommitAction
{
 ONCOMMIT_NOOP,
 ONCOMMIT_PRESERVE_ROWS,
 ONCOMMIT_DELETE_ROWS,
 ONCOMMIT_DROP
} OnCommitAction;
# 63 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct RangeVar
{
 NodeTag type;
 char *catalogname;
 char *schemaname;
 char *relname;
 _Bool inh;

 char relpersistence;
 Alias *alias;
 int location;
} RangeVar;







typedef struct TableFunc
{
 NodeTag type;
 List *ns_uris;
 List *ns_names;
 Node *docexpr;
 Node *rowexpr;
 List *colnames;
 List *coltypes;
 List *coltypmods;
 List *colcollations;
 List *colexprs;
 List *coldefexprs;
 Bitmapset *notnulls;
 int ordinalitycol;
 int location;
} TableFunc;
# 108 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct IntoClause
{
 NodeTag type;

 RangeVar *rel;
 List *colNames;
 char *accessMethod;
 List *options;
 OnCommitAction onCommit;
 char *tableSpaceName;
 Node *viewQuery;
 _Bool skipData;
} IntoClause;
# 136 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct Expr
{
 NodeTag type;
} Expr;
# 167 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct Var
{
 Expr xpr;
 Index varno;

 AttrNumber varattno;

 Oid vartype;
 int32 vartypmod;
 Oid varcollid;
 Index varlevelsup;


 Index varnoold;
 AttrNumber varoattno;
 int location;
} Var;
# 193 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct Const
{
 Expr xpr;
 Oid consttype;
 int32 consttypmod;
 Oid constcollid;
 int constlen;
 Datum constvalue;
 _Bool constisnull;

 _Bool constbyval;



 int location;
} Const;
# 237 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef enum ParamKind
{
 PARAM_EXTERN,
 PARAM_EXEC,
 PARAM_SUBLINK,
 PARAM_MULTIEXPR
} ParamKind;

typedef struct Param
{
 Expr xpr;
 ParamKind paramkind;
 int paramid;
 Oid paramtype;
 int32 paramtypmod;
 Oid paramcollid;
 int location;
} Param;
# 295 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct Aggref
{
 Expr xpr;
 Oid aggfnoid;
 Oid aggtype;
 Oid aggcollid;
 Oid inputcollid;
 Oid aggtranstype;
 List *aggargtypes;
 List *aggdirectargs;
 List *args;
 List *aggorder;
 List *aggdistinct;
 Expr *aggfilter;
 _Bool aggstar;
 _Bool aggvariadic;

 char aggkind;
 Index agglevelsup;
 AggSplit aggsplit;
 int location;
} Aggref;
# 342 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct GroupingFunc
{
 Expr xpr;
 List *args;

 List *refs;
 List *cols;
 Index agglevelsup;
 int location;
} GroupingFunc;




typedef struct WindowFunc
{
 Expr xpr;
 Oid winfnoid;
 Oid wintype;
 Oid wincollid;
 Oid inputcollid;
 List *args;
 Expr *aggfilter;
 Index winref;
 _Bool winstar;
 _Bool winagg;
 int location;
} WindowFunc;
# 401 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct SubscriptingRef
{
 Expr xpr;
 Oid refcontainertype;
 Oid refelemtype;
 int32 reftypmod;
 Oid refcollid;
 List *refupperindexpr;

 List *reflowerindexpr;


 Expr *refexpr;


 Expr *refassgnexpr;

} SubscriptingRef;







typedef enum CoercionContext
{
 COERCION_IMPLICIT,
 COERCION_ASSIGNMENT,
 COERCION_EXPLICIT
} CoercionContext;
# 442 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef enum CoercionForm
{
 COERCE_EXPLICIT_CALL,
 COERCE_EXPLICIT_CAST,
 COERCE_IMPLICIT_CAST
} CoercionForm;




typedef struct FuncExpr
{
 Expr xpr;
 Oid funcid;
 Oid funcresulttype;
 _Bool funcretset;
 _Bool funcvariadic;

 CoercionForm funcformat;
 Oid funccollid;
 Oid inputcollid;
 List *args;
 int location;
} FuncExpr;
# 481 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct NamedArgExpr
{
 Expr xpr;
 Expr *arg;
 char *name;
 int argnumber;
 int location;
} NamedArgExpr;
# 499 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct OpExpr
{
 Expr xpr;
 Oid opno;
 Oid opfuncid;
 Oid opresulttype;
 _Bool opretset;
 Oid opcollid;
 Oid inputcollid;
 List *args;
 int location;
} OpExpr;
# 522 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef OpExpr DistinctExpr;







typedef OpExpr NullIfExpr;
# 542 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct ScalarArrayOpExpr
{
 Expr xpr;
 Oid opno;
 Oid opfuncid;
 _Bool useOr;
 Oid inputcollid;
 List *args;
 int location;
} ScalarArrayOpExpr;
# 560 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef enum BoolExprType
{
 AND_EXPR, OR_EXPR, NOT_EXPR
} BoolExprType;

typedef struct BoolExpr
{
 Expr xpr;
 BoolExprType boolop;
 List *args;
 int location;
} BoolExpr;
# 624 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef enum SubLinkType
{
 EXISTS_SUBLINK,
 ALL_SUBLINK,
 ANY_SUBLINK,
 ROWCOMPARE_SUBLINK,
 EXPR_SUBLINK,
 MULTIEXPR_SUBLINK,
 ARRAY_SUBLINK,
 CTE_SUBLINK
} SubLinkType;


typedef struct SubLink
{
 Expr xpr;
 SubLinkType subLinkType;
 int subLinkId;
 Node *testexpr;
 List *operName;
 Node *subselect;
 int location;
} SubLink;
# 686 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct SubPlan
{
 Expr xpr;

 SubLinkType subLinkType;

 Node *testexpr;
 List *paramIds;

 int plan_id;

 char *plan_name;

 Oid firstColType;
 int32 firstColTypmod;
 Oid firstColCollation;


 _Bool useHashTable;

 _Bool unknownEqFalse;


 _Bool parallel_safe;



 List *setParam;

 List *parParam;
 List *args;

 Cost startup_cost;
 Cost per_call_cost;
} SubPlan;
# 730 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct AlternativeSubPlan
{
 Expr xpr;
 List *subplans;
} AlternativeSubPlan;
# 745 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct FieldSelect
{
 Expr xpr;
 Expr *arg;
 AttrNumber fieldnum;
 Oid resulttype;

 int32 resulttypmod;
 Oid resultcollid;
} FieldSelect;
# 774 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct FieldStore
{
 Expr xpr;
 Expr *arg;
 List *newvals;
 List *fieldnums;
 Oid resulttype;

} FieldStore;
# 797 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct RelabelType
{
 Expr xpr;
 Expr *arg;
 Oid resulttype;
 int32 resulttypmod;
 Oid resultcollid;
 CoercionForm relabelformat;
 int location;
} RelabelType;
# 817 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct CoerceViaIO
{
 Expr xpr;
 Expr *arg;
 Oid resulttype;

 Oid resultcollid;
 CoercionForm coerceformat;
 int location;
} CoerceViaIO;
# 841 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct ArrayCoerceExpr
{
 Expr xpr;
 Expr *arg;
 Expr *elemexpr;
 Oid resulttype;
 int32 resulttypmod;
 Oid resultcollid;
 CoercionForm coerceformat;
 int location;
} ArrayCoerceExpr;
# 866 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct ConvertRowtypeExpr
{
 Expr xpr;
 Expr *arg;
 Oid resulttype;

 CoercionForm convertformat;
 int location;
} ConvertRowtypeExpr;
# 883 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct CollateExpr
{
 Expr xpr;
 Expr *arg;
 Oid collOid;
 int location;
} CollateExpr;
# 913 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct CaseExpr
{
 Expr xpr;
 Oid casetype;
 Oid casecollid;
 Expr *arg;
 List *args;
 Expr *defresult;
 int location;
} CaseExpr;




typedef struct CaseWhen
{
 Expr xpr;
 Expr *expr;
 Expr *result;
 int location;
} CaseWhen;
# 955 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct CaseTestExpr
{
 Expr xpr;
 Oid typeId;
 int32 typeMod;
 Oid collation;
} CaseTestExpr;
# 971 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct ArrayExpr
{
 Expr xpr;
 Oid array_typeid;
 Oid array_collid;
 Oid element_typeid;
 List *elements;
 _Bool multidims;
 int location;
} ArrayExpr;
# 1005 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct RowExpr
{
 Expr xpr;
 List *args;
 Oid row_typeid;
# 1023 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
 CoercionForm row_format;
 List *colnames;
 int location;
} RowExpr;
# 1042 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef enum RowCompareType
{

 ROWCOMPARE_LT = 1,
 ROWCOMPARE_LE = 2,
 ROWCOMPARE_EQ = 3,
 ROWCOMPARE_GE = 4,
 ROWCOMPARE_GT = 5,
 ROWCOMPARE_NE = 6
} RowCompareType;

typedef struct RowCompareExpr
{
 Expr xpr;
 RowCompareType rctype;
 List *opnos;
 List *opfamilies;
 List *inputcollids;
 List *largs;
 List *rargs;
} RowCompareExpr;




typedef struct CoalesceExpr
{
 Expr xpr;
 Oid coalescetype;
 Oid coalescecollid;
 List *args;
 int location;
} CoalesceExpr;




typedef enum MinMaxOp
{
 IS_GREATEST,
 IS_LEAST
} MinMaxOp;

typedef struct MinMaxExpr
{
 Expr xpr;
 Oid minmaxtype;
 Oid minmaxcollid;
 Oid inputcollid;
 MinMaxOp op;
 List *args;
 int location;
} MinMaxExpr;
# 1107 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef enum SQLValueFunctionOp
{
 SVFOP_CURRENT_DATE,
 SVFOP_CURRENT_TIME,
 SVFOP_CURRENT_TIME_N,
 SVFOP_CURRENT_TIMESTAMP,
 SVFOP_CURRENT_TIMESTAMP_N,
 SVFOP_LOCALTIME,
 SVFOP_LOCALTIME_N,
 SVFOP_LOCALTIMESTAMP,
 SVFOP_LOCALTIMESTAMP_N,
 SVFOP_CURRENT_ROLE,
 SVFOP_CURRENT_USER,
 SVFOP_USER,
 SVFOP_SESSION_USER,
 SVFOP_CURRENT_CATALOG,
 SVFOP_CURRENT_SCHEMA
} SQLValueFunctionOp;

typedef struct SQLValueFunction
{
 Expr xpr;
 SQLValueFunctionOp op;
 Oid type;
 int32 typmod;
 int location;
} SQLValueFunction;
# 1146 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef enum XmlExprOp
{
 IS_XMLCONCAT,
 IS_XMLELEMENT,
 IS_XMLFOREST,
 IS_XMLPARSE,
 IS_XMLPI,
 IS_XMLROOT,
 IS_XMLSERIALIZE,
 IS_DOCUMENT
} XmlExprOp;

typedef enum
{
 XMLOPTION_DOCUMENT,
 XMLOPTION_CONTENT
} XmlOptionType;

typedef struct XmlExpr
{
 Expr xpr;
 XmlExprOp op;
 char *name;
 List *named_args;
 List *arg_names;
 List *args;
 XmlOptionType xmloption;
 Oid type;
 int32 typmod;
 int location;
} XmlExpr;
# 1197 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef enum NullTestType
{
 IS_NULL, IS_NOT_NULL
} NullTestType;

typedef struct NullTest
{
 Expr xpr;
 Expr *arg;
 NullTestType nulltesttype;
 _Bool argisrow;
 int location;
} NullTest;
# 1220 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef enum BoolTestType
{
 IS_TRUE, IS_NOT_TRUE, IS_FALSE, IS_NOT_FALSE, IS_UNKNOWN, IS_NOT_UNKNOWN
} BoolTestType;

typedef struct BooleanTest
{
 Expr xpr;
 Expr *arg;
 BoolTestType booltesttype;
 int location;
} BooleanTest;
# 1242 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct CoerceToDomain
{
 Expr xpr;
 Expr *arg;
 Oid resulttype;
 int32 resulttypmod;
 Oid resultcollid;
 CoercionForm coercionformat;
 int location;
} CoerceToDomain;
# 1262 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct CoerceToDomainValue
{
 Expr xpr;
 Oid typeId;
 int32 typeMod;
 Oid collation;
 int location;
} CoerceToDomainValue;
# 1278 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct SetToDefault
{
 Expr xpr;
 Oid typeId;
 int32 typeMod;
 Oid collation;
 int location;
} SetToDefault;
# 1299 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct CurrentOfExpr
{
 Expr xpr;
 Index cvarno;
 char *cursor_name;
 int cursor_param;
} CurrentOfExpr;
# 1314 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct NextValueExpr
{
 Expr xpr;
 Oid seqid;
 Oid typeId;
} NextValueExpr;
# 1328 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct InferenceElem
{
 Expr xpr;
 Node *expr;
 Oid infercollid;
 Oid inferopclass;
} InferenceElem;
# 1390 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct TargetEntry
{
 Expr xpr;
 Expr *expr;
 AttrNumber resno;
 char *resname;
 Index ressortgroupref;

 Oid resorigtbl;
 AttrNumber resorigcol;
 _Bool resjunk;

} TargetEntry;
# 1442 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct RangeTblRef
{
 NodeTag type;
 int rtindex;
} RangeTblRef;
# 1471 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct JoinExpr
{
 NodeTag type;
 JoinType jointype;
 _Bool isNatural;
 Node *larg;
 Node *rarg;
 List *usingClause;
 Node *quals;
 Alias *alias;
 int rtindex;
} JoinExpr;
# 1493 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct FromExpr
{
 NodeTag type;
 List *fromlist;
 Node *quals;
} FromExpr;
# 1509 "/products1/postgres/PG12.1/include/server/nodes/primnodes.h"
typedef struct OnConflictExpr
{
 NodeTag type;
 OnConflictAction action;


 List *arbiterElems;

 Node *arbiterWhere;
 Oid constraint;


 List *onConflictSet;
 Node *onConflictWhere;
 int exclRelIndex;
 List *exclRelTlist;
} OnConflictExpr;
# 28 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h" 2
# 1 "/products1/postgres/PG12.1/include/server/nodes/value.h" 1
# 42 "/products1/postgres/PG12.1/include/server/nodes/value.h"
typedef struct Value
{
 NodeTag type;
 union ValUnion
 {
  int ival;
  char *str;
 } val;
} Value;





extern Value *makeInteger(int i);
extern Value *makeFloat(char *numericStr);
extern Value *makeString(char *str);
extern Value *makeBitString(char *str);
# 29 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h" 2
# 1 "/products1/postgres/PG12.1/include/server/partitioning/partdefs.h" 1
# 16 "/products1/postgres/PG12.1/include/server/partitioning/partdefs.h"
typedef struct PartitionBoundInfoData *PartitionBoundInfo;

typedef struct PartitionKeyData *PartitionKey;

typedef struct PartitionBoundSpec PartitionBoundSpec;

typedef struct PartitionDescData *PartitionDesc;

typedef struct PartitionDirectoryData *PartitionDirectory;
# 30 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h" 2


typedef enum OverridingKind
{
 OVERRIDING_NOT_SET = 0,
 OVERRIDING_USER_VALUE,
 OVERRIDING_SYSTEM_VALUE
} OverridingKind;


typedef enum QuerySource
{
 QSRC_ORIGINAL,
 QSRC_PARSER,
 QSRC_INSTEAD_RULE,
 QSRC_QUAL_INSTEAD_RULE,
 QSRC_NON_INSTEAD_RULE
} QuerySource;


typedef enum SortByDir
{
 SORTBY_DEFAULT,
 SORTBY_ASC,
 SORTBY_DESC,
 SORTBY_USING
} SortByDir;

typedef enum SortByNulls
{
 SORTBY_NULLS_DEFAULT,
 SORTBY_NULLS_FIRST,
 SORTBY_NULLS_LAST
} SortByNulls;
# 72 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef uint32 AclMode;
# 108 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct Query
{
 NodeTag type;

 CmdType commandType;

 QuerySource querySource;

 uint64 queryId;

 _Bool canSetTag;

 Node *utilityStmt;

 int resultRelation;


 _Bool hasAggs;
 _Bool hasWindowFuncs;
 _Bool hasTargetSRFs;
 _Bool hasSubLinks;
 _Bool hasDistinctOn;
 _Bool hasRecursive;
 _Bool hasModifyingCTE;
 _Bool hasForUpdate;
 _Bool hasRowSecurity;

 List *cteList;

 List *rtable;
 FromExpr *jointree;

 List *targetList;

 OverridingKind override;

 OnConflictExpr *onConflict;

 List *returningList;

 List *groupClause;

 List *groupingSets;

 Node *havingQual;

 List *windowClause;

 List *distinctClause;

 List *sortClause;

 Node *limitOffset;
 Node *limitCount;

 List *rowMarks;

 Node *setOperations;


 List *constraintDeps;


 List *withCheckOptions;
# 180 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
 int stmt_location;
 int stmt_len;
} Query;
# 206 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct TypeName
{
 NodeTag type;
 List *names;
 Oid typeOid;
 _Bool setof;
 _Bool pct_type;
 List *typmods;
 int32 typemod;
 List *arrayBounds;
 int location;
} TypeName;
# 232 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct ColumnRef
{
 NodeTag type;
 List *fields;
 int location;
} ColumnRef;




typedef struct ParamRef
{
 NodeTag type;
 int number;
 int location;
} ParamRef;




typedef enum A_Expr_Kind
{
 AEXPR_OP,
 AEXPR_OP_ANY,
 AEXPR_OP_ALL,
 AEXPR_DISTINCT,
 AEXPR_NOT_DISTINCT,
 AEXPR_NULLIF,
 AEXPR_OF,
 AEXPR_IN,
 AEXPR_LIKE,
 AEXPR_ILIKE,
 AEXPR_SIMILAR,
 AEXPR_BETWEEN,
 AEXPR_NOT_BETWEEN,
 AEXPR_BETWEEN_SYM,
 AEXPR_NOT_BETWEEN_SYM,
 AEXPR_PAREN
} A_Expr_Kind;

typedef struct A_Expr
{
 NodeTag type;
 A_Expr_Kind kind;
 List *name;
 Node *lexpr;
 Node *rexpr;
 int location;
} A_Expr;




typedef struct A_Const
{
 NodeTag type;
 Value val;
 int location;
} A_Const;




typedef struct TypeCast
{
 NodeTag type;
 Node *arg;
 TypeName *typeName;
 int location;
} TypeCast;




typedef struct CollateClause
{
 NodeTag type;
 Node *arg;
 List *collname;
 int location;
} CollateClause;




typedef enum RoleSpecType
{
 ROLESPEC_CSTRING,
 ROLESPEC_CURRENT_USER,
 ROLESPEC_SESSION_USER,
 ROLESPEC_PUBLIC
} RoleSpecType;

typedef struct RoleSpec
{
 NodeTag type;
 RoleSpecType roletype;
 char *rolename;
 int location;
} RoleSpec;
# 347 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct FuncCall
{
 NodeTag type;
 List *funcname;
 List *args;
 List *agg_order;
 Node *agg_filter;
 _Bool agg_within_group;
 _Bool agg_star;
 _Bool agg_distinct;
 _Bool func_variadic;
 struct WindowDef *over;
 int location;
} FuncCall;







typedef struct A_Star
{
 NodeTag type;
} A_Star;







typedef struct A_Indices
{
 NodeTag type;
 _Bool is_slice;
 Node *lidx;
 Node *uidx;
} A_Indices;
# 402 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct A_Indirection
{
 NodeTag type;
 Node *arg;
 List *indirection;
} A_Indirection;




typedef struct A_ArrayExpr
{
 NodeTag type;
 List *elements;
 int location;
} A_ArrayExpr;
# 437 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct ResTarget
{
 NodeTag type;
 char *name;
 List *indirection;
 Node *val;
 int location;
} ResTarget;
# 455 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct MultiAssignRef
{
 NodeTag type;
 Node *source;
 int colno;
 int ncolumns;
} MultiAssignRef;




typedef struct SortBy
{
 NodeTag type;
 Node *node;
 SortByDir sortby_dir;
 SortByNulls sortby_nulls;
 List *useOp;
 int location;
} SortBy;
# 484 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct WindowDef
{
 NodeTag type;
 char *name;
 char *refname;
 List *partitionClause;
 List *orderClause;
 int frameOptions;
 Node *startOffset;
 Node *endOffset;
 int location;
} WindowDef;
# 538 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct RangeSubselect
{
 NodeTag type;
 _Bool lateral;
 Node *subquery;
 Alias *alias;
} RangeSubselect;
# 560 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct RangeFunction
{
 NodeTag type;
 _Bool lateral;
 _Bool ordinality;
 _Bool is_rowsfrom;
 List *functions;
 Alias *alias;
 List *coldeflist;

} RangeFunction;




typedef struct RangeTableFunc
{
 NodeTag type;
 _Bool lateral;
 Node *docexpr;
 Node *rowexpr;
 List *namespaces;
 List *columns;
 Alias *alias;
 int location;
} RangeTableFunc;







typedef struct RangeTableFuncCol
{
 NodeTag type;
 char *colname;
 TypeName *typeName;
 _Bool for_ordinality;
 _Bool is_not_null;
 Node *colexpr;
 Node *coldefexpr;
 int location;
} RangeTableFuncCol;
# 615 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct RangeTableSample
{
 NodeTag type;
 Node *relation;
 List *method;
 List *args;
 Node *repeatable;
 int location;
} RangeTableSample;
# 643 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct ColumnDef
{
 NodeTag type;
 char *colname;
 TypeName *typeName;
 int inhcount;
 _Bool is_local;
 _Bool is_not_null;
 _Bool is_from_type;
 char storage;
 Node *raw_default;
 Node *cooked_default;
 char identity;
 RangeVar *identitySequence;

 char generated;
 CollateClause *collClause;
 Oid collOid;
 List *constraints;
 List *fdwoptions;
 int location;
} ColumnDef;




typedef struct TableLikeClause
{
 NodeTag type;
 RangeVar *relation;
 bits32 options;
} TableLikeClause;

typedef enum TableLikeOption
{
 CREATE_TABLE_LIKE_COMMENTS = 1 << 0,
 CREATE_TABLE_LIKE_CONSTRAINTS = 1 << 1,
 CREATE_TABLE_LIKE_DEFAULTS = 1 << 2,
 CREATE_TABLE_LIKE_GENERATED = 1 << 3,
 CREATE_TABLE_LIKE_IDENTITY = 1 << 4,
 CREATE_TABLE_LIKE_INDEXES = 1 << 5,
 CREATE_TABLE_LIKE_STATISTICS = 1 << 6,
 CREATE_TABLE_LIKE_STORAGE = 1 << 7,
 CREATE_TABLE_LIKE_ALL = (0x7FFFFFFF)
} TableLikeOption;
# 696 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct IndexElem
{
 NodeTag type;
 char *name;
 Node *expr;
 char *indexcolname;
 List *collation;
 List *opclass;
 SortByDir ordering;
 SortByNulls nulls_ordering;
} IndexElem;
# 718 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef enum DefElemAction
{
 DEFELEM_UNSPEC,
 DEFELEM_SET,
 DEFELEM_ADD,
 DEFELEM_DROP
} DefElemAction;

typedef struct DefElem
{
 NodeTag type;
 char *defnamespace;
 char *defname;
 Node *arg;
 DefElemAction defaction;
 int location;
} DefElem;
# 745 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct LockingClause
{
 NodeTag type;
 List *lockedRels;
 LockClauseStrength strength;
 LockWaitPolicy waitPolicy;
} LockingClause;




typedef struct XmlSerialize
{
 NodeTag type;
 XmlOptionType xmloption;
 Node *expr;
 TypeName *typeName;
 int location;
} XmlSerialize;
# 773 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct PartitionElem
{
 NodeTag type;
 char *name;
 Node *expr;
 List *collation;
 List *opclass;
 int location;
} PartitionElem;






typedef struct PartitionSpec
{
 NodeTag type;
 char *strategy;

 List *partParams;
 int location;
} PartitionSpec;
# 808 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
struct PartitionBoundSpec
{
 NodeTag type;

 char strategy;
 _Bool is_default;


 int modulus;
 int remainder;


 List *listdatums;


 List *lowerdatums;
 List *upperdatums;

 int location;
};






typedef enum PartitionRangeDatumKind
{
 PARTITION_RANGE_DATUM_MINVALUE = -1,
 PARTITION_RANGE_DATUM_VALUE = 0,
 PARTITION_RANGE_DATUM_MAXVALUE = 1
} PartitionRangeDatumKind;

typedef struct PartitionRangeDatum
{
 NodeTag type;

 PartitionRangeDatumKind kind;
 Node *value;


 int location;
} PartitionRangeDatum;




typedef struct PartitionCmd
{
 NodeTag type;
 RangeVar *name;
 PartitionBoundSpec *bound;
} PartitionCmd;
# 955 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef enum RTEKind
{
 RTE_RELATION,
 RTE_SUBQUERY,
 RTE_JOIN,
 RTE_FUNCTION,
 RTE_TABLEFUNC,
 RTE_VALUES,
 RTE_CTE,
 RTE_NAMEDTUPLESTORE,
 RTE_RESULT


} RTEKind;

typedef struct RangeTblEntry
{
 NodeTag type;

 RTEKind rtekind;
# 1001 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
 Oid relid;
 char relkind;
 int rellockmode;
 struct TableSampleClause *tablesample;




 Query *subquery;
 _Bool security_barrier;
# 1029 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
 JoinType jointype;
 List *joinaliasvars;
# 1040 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
 List *functions;
 _Bool funcordinality;




 TableFunc *tablefunc;




 List *values_lists;




 char *ctename;
 Index ctelevelsup;
 _Bool self_reference;
# 1078 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
 List *coltypes;
 List *coltypmods;
 List *colcollations;




 char *enrname;
 double enrtuples;




 Alias *alias;
 Alias *eref;
 _Bool lateral;
 _Bool inh;
 _Bool inFromCl;
 AclMode requiredPerms;
 Oid checkAsUser;
 Bitmapset *selectedCols;
 Bitmapset *insertedCols;
 Bitmapset *updatedCols;
 Bitmapset *extraUpdatedCols;
 List *securityQuals;
} RangeTblEntry;
# 1121 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct RangeTblFunction
{
 NodeTag type;

 Node *funcexpr;
 int funccolcount;

 List *funccolnames;
 List *funccoltypes;
 List *funccoltypmods;
 List *funccolcollations;

 Bitmapset *funcparams;
} RangeTblFunction;






typedef struct TableSampleClause
{
 NodeTag type;
 Oid tsmhandler;
 List *args;
 Expr *repeatable;
} TableSampleClause;







typedef enum WCOKind
{
 WCO_VIEW_CHECK,
 WCO_RLS_INSERT_CHECK,
 WCO_RLS_UPDATE_CHECK,
 WCO_RLS_CONFLICT_CHECK
} WCOKind;

typedef struct WithCheckOption
{
 NodeTag type;
 WCOKind kind;
 char *relname;
 char *polname;
 Node *qual;
 _Bool cascaded;
} WithCheckOption;
# 1231 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct SortGroupClause
{
 NodeTag type;
 Index tleSortGroupRef;
 Oid eqop;
 Oid sortop;
 _Bool nulls_first;
 _Bool hashable;
} SortGroupClause;
# 1291 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef enum
{
 GROUPING_SET_EMPTY,
 GROUPING_SET_SIMPLE,
 GROUPING_SET_ROLLUP,
 GROUPING_SET_CUBE,
 GROUPING_SET_SETS
} GroupingSetKind;

typedef struct GroupingSet
{
 NodeTag type;
 GroupingSetKind kind;
 List *content;
 int location;
} GroupingSet;
# 1325 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct WindowClause
{
 NodeTag type;
 char *name;
 char *refname;
 List *partitionClause;
 List *orderClause;
 int frameOptions;
 Node *startOffset;
 Node *endOffset;
 Oid startInRangeFunc;
 Oid endInRangeFunc;
 Oid inRangeColl;
 _Bool inRangeAsc;
 _Bool inRangeNullsFirst;
 Index winref;
 _Bool copiedOrder;
} WindowClause;
# 1356 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct RowMarkClause
{
 NodeTag type;
 Index rti;
 LockClauseStrength strength;
 LockWaitPolicy waitPolicy;
 _Bool pushedDown;
} RowMarkClause;
# 1372 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct WithClause
{
 NodeTag type;
 List *ctes;
 _Bool recursive;
 int location;
} WithClause;







typedef struct InferClause
{
 NodeTag type;
 List *indexElems;
 Node *whereClause;
 char *conname;
 int location;
} InferClause;







typedef struct OnConflictClause
{
 NodeTag type;
 OnConflictAction action;
 InferClause *infer;
 List *targetList;
 Node *whereClause;
 int location;
} OnConflictClause;







typedef enum CTEMaterialize
{
 CTEMaterializeDefault,
 CTEMaterializeAlways,
 CTEMaterializeNever
} CTEMaterialize;

typedef struct CommonTableExpr
{
 NodeTag type;
 char *ctename;
 List *aliascolnames;
 CTEMaterialize ctematerialized;

 Node *ctequery;
 int location;

 _Bool cterecursive;
 int cterefcount;

 List *ctecolnames;
 List *ctecoltypes;
 List *ctecoltypmods;
 List *ctecolcollations;
} CommonTableExpr;
# 1458 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct TriggerTransition
{
 NodeTag type;
 char *name;
 _Bool isNew;
 _Bool isTable;
} TriggerTransition;
# 1482 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct RawStmt
{
 NodeTag type;
 Node *stmt;
 int stmt_location;
 int stmt_len;
} RawStmt;
# 1502 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct InsertStmt
{
 NodeTag type;
 RangeVar *relation;
 List *cols;
 Node *selectStmt;
 OnConflictClause *onConflictClause;
 List *returningList;
 WithClause *withClause;
 OverridingKind override;
} InsertStmt;





typedef struct DeleteStmt
{
 NodeTag type;
 RangeVar *relation;
 List *usingClause;
 Node *whereClause;
 List *returningList;
 WithClause *withClause;
} DeleteStmt;





typedef struct UpdateStmt
{
 NodeTag type;
 RangeVar *relation;
 List *targetList;
 Node *whereClause;
 List *fromClause;
 List *returningList;
 WithClause *withClause;
} UpdateStmt;
# 1556 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef enum SetOperation
{
 SETOP_NONE = 0,
 SETOP_UNION,
 SETOP_INTERSECT,
 SETOP_EXCEPT
} SetOperation;

typedef struct SelectStmt
{
 NodeTag type;




 List *distinctClause;

 IntoClause *intoClause;
 List *targetList;
 List *fromClause;
 Node *whereClause;
 List *groupClause;
 Node *havingClause;
 List *windowClause;
# 1589 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
 List *valuesLists;





 List *sortClause;
 Node *limitOffset;
 Node *limitCount;
 List *lockingClause;
 WithClause *withClause;




 SetOperation op;
 _Bool all;
 struct SelectStmt *larg;
 struct SelectStmt *rarg;

} SelectStmt;
# 1631 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct SetOperationStmt
{
 NodeTag type;
 SetOperation op;
 _Bool all;
 Node *larg;
 Node *rarg;



 List *colTypes;
 List *colTypmods;
 List *colCollations;
 List *groupClauses;

} SetOperationStmt;
# 1669 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef enum ObjectType
{
 OBJECT_ACCESS_METHOD,
 OBJECT_AGGREGATE,
 OBJECT_AMOP,
 OBJECT_AMPROC,
 OBJECT_ATTRIBUTE,
 OBJECT_CAST,
 OBJECT_COLUMN,
 OBJECT_COLLATION,
 OBJECT_CONVERSION,
 OBJECT_DATABASE,
 OBJECT_DEFAULT,
 OBJECT_DEFACL,
 OBJECT_DOMAIN,
 OBJECT_DOMCONSTRAINT,
 OBJECT_EVENT_TRIGGER,
 OBJECT_EXTENSION,
 OBJECT_FDW,
 OBJECT_FOREIGN_SERVER,
 OBJECT_FOREIGN_TABLE,
 OBJECT_FUNCTION,
 OBJECT_INDEX,
 OBJECT_LANGUAGE,
 OBJECT_LARGEOBJECT,
 OBJECT_MATVIEW,
 OBJECT_OPCLASS,
 OBJECT_OPERATOR,
 OBJECT_OPFAMILY,
 OBJECT_POLICY,
 OBJECT_PROCEDURE,
 OBJECT_PUBLICATION,
 OBJECT_PUBLICATION_REL,
 OBJECT_ROLE,
 OBJECT_ROUTINE,
 OBJECT_RULE,
 OBJECT_SCHEMA,
 OBJECT_SEQUENCE,
 OBJECT_SUBSCRIPTION,
 OBJECT_STATISTIC_EXT,
 OBJECT_TABCONSTRAINT,
 OBJECT_TABLE,
 OBJECT_TABLESPACE,
 OBJECT_TRANSFORM,
 OBJECT_TRIGGER,
 OBJECT_TSCONFIGURATION,
 OBJECT_TSDICTIONARY,
 OBJECT_TSPARSER,
 OBJECT_TSTEMPLATE,
 OBJECT_TYPE,
 OBJECT_USER_MAPPING,
 OBJECT_VIEW
} ObjectType;
# 1731 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct CreateSchemaStmt
{
 NodeTag type;
 char *schemaname;
 RoleSpec *authrole;
 List *schemaElts;
 _Bool if_not_exists;
} CreateSchemaStmt;

typedef enum DropBehavior
{
 DROP_RESTRICT,
 DROP_CASCADE
} DropBehavior;





typedef struct AlterTableStmt
{
 NodeTag type;
 RangeVar *relation;
 List *cmds;
 ObjectType relkind;
 _Bool missing_ok;
} AlterTableStmt;

typedef enum AlterTableType
{
 AT_AddColumn,
 AT_AddColumnRecurse,
 AT_AddColumnToView,
 AT_ColumnDefault,
 AT_DropNotNull,
 AT_SetNotNull,
 AT_CheckNotNull,
 AT_SetStatistics,
 AT_SetOptions,
 AT_ResetOptions,
 AT_SetStorage,
 AT_DropColumn,
 AT_DropColumnRecurse,
 AT_AddIndex,
 AT_ReAddIndex,
 AT_AddConstraint,
 AT_AddConstraintRecurse,
 AT_ReAddConstraint,
 AT_ReAddDomainConstraint,
 AT_AlterConstraint,
 AT_ValidateConstraint,
 AT_ValidateConstraintRecurse,
 AT_ProcessedConstraint,

 AT_AddIndexConstraint,
 AT_DropConstraint,
 AT_DropConstraintRecurse,
 AT_ReAddComment,
 AT_AlterColumnType,
 AT_AlterColumnGenericOptions,
 AT_ChangeOwner,
 AT_ClusterOn,
 AT_DropCluster,
 AT_SetLogged,
 AT_SetUnLogged,
 AT_DropOids,
 AT_SetTableSpace,
 AT_SetRelOptions,
 AT_ResetRelOptions,
 AT_ReplaceRelOptions,
 AT_EnableTrig,
 AT_EnableAlwaysTrig,
 AT_EnableReplicaTrig,
 AT_DisableTrig,
 AT_EnableTrigAll,
 AT_DisableTrigAll,
 AT_EnableTrigUser,
 AT_DisableTrigUser,
 AT_EnableRule,
 AT_EnableAlwaysRule,
 AT_EnableReplicaRule,
 AT_DisableRule,
 AT_AddInherit,
 AT_DropInherit,
 AT_AddOf,
 AT_DropOf,
 AT_ReplicaIdentity,
 AT_EnableRowSecurity,
 AT_DisableRowSecurity,
 AT_ForceRowSecurity,
 AT_NoForceRowSecurity,
 AT_GenericOptions,
 AT_AttachPartition,
 AT_DetachPartition,
 AT_AddIdentity,
 AT_SetIdentity,
 AT_DropIdentity
} AlterTableType;

typedef struct ReplicaIdentityStmt
{
 NodeTag type;
 char identity_type;
 char *name;
} ReplicaIdentityStmt;

typedef struct AlterTableCmd
{
 NodeTag type;
 AlterTableType subtype;
 char *name;

 int16 num;

 RoleSpec *newowner;
 Node *def;

 DropBehavior behavior;
 _Bool missing_ok;
} AlterTableCmd;






typedef struct AlterCollationStmt
{
 NodeTag type;
 List *collname;
} AlterCollationStmt;
# 1871 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct AlterDomainStmt
{
 NodeTag type;
 char subtype;







 List *typeName;
 char *name;
 Node *def;
 DropBehavior behavior;
 _Bool missing_ok;
} AlterDomainStmt;






typedef enum GrantTargetType
{
 ACL_TARGET_OBJECT,
 ACL_TARGET_ALL_IN_SCHEMA,
 ACL_TARGET_DEFAULTS
} GrantTargetType;

typedef struct GrantStmt
{
 NodeTag type;
 _Bool is_grant;
 GrantTargetType targtype;
 ObjectType objtype;
 List *objects;

 List *privileges;

 List *grantees;
 _Bool grant_option;
 DropBehavior behavior;
} GrantStmt;






typedef struct ObjectWithArgs
{
 NodeTag type;
 List *objname;
 List *objargs;
 _Bool args_unspecified;


} ObjectWithArgs;
# 1938 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct AccessPriv
{
 NodeTag type;
 char *priv_name;
 List *cols;
} AccessPriv;
# 1954 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct GrantRoleStmt
{
 NodeTag type;
 List *granted_roles;
 List *grantee_roles;
 _Bool is_grant;
 _Bool admin_opt;
 RoleSpec *grantor;
 DropBehavior behavior;
} GrantRoleStmt;





typedef struct AlterDefaultPrivilegesStmt
{
 NodeTag type;
 List *options;
 GrantStmt *action;
} AlterDefaultPrivilegesStmt;
# 1984 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct CopyStmt
{
 NodeTag type;
 RangeVar *relation;
 Node *query;

 List *attlist;

 _Bool is_from;
 _Bool is_program;
 char *filename;
 List *options;
 Node *whereClause;
} CopyStmt;
# 2006 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef enum
{
 VAR_SET_VALUE,
 VAR_SET_DEFAULT,
 VAR_SET_CURRENT,
 VAR_SET_MULTI,
 VAR_RESET,
 VAR_RESET_ALL
} VariableSetKind;

typedef struct VariableSetStmt
{
 NodeTag type;
 VariableSetKind kind;
 char *name;
 List *args;
 _Bool is_local;
} VariableSetStmt;





typedef struct VariableShowStmt
{
 NodeTag type;
 char *name;
} VariableShowStmt;
# 2046 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct CreateStmt
{
 NodeTag type;
 RangeVar *relation;
 List *tableElts;
 List *inhRelations;

 PartitionBoundSpec *partbound;
 PartitionSpec *partspec;
 TypeName *ofTypename;
 List *constraints;
 List *options;
 OnCommitAction oncommit;
 char *tablespacename;
 char *accessMethod;
 _Bool if_not_exists;
} CreateStmt;
# 2095 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef enum ConstrType
{
 CONSTR_NULL,

 CONSTR_NOTNULL,
 CONSTR_DEFAULT,
 CONSTR_IDENTITY,
 CONSTR_GENERATED,
 CONSTR_CHECK,
 CONSTR_PRIMARY,
 CONSTR_UNIQUE,
 CONSTR_EXCLUSION,
 CONSTR_FOREIGN,
 CONSTR_ATTR_DEFERRABLE,
 CONSTR_ATTR_NOT_DEFERRABLE,
 CONSTR_ATTR_DEFERRED,
 CONSTR_ATTR_IMMEDIATE
} ConstrType;
# 2126 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct Constraint
{
 NodeTag type;
 ConstrType contype;


 char *conname;
 _Bool deferrable;
 _Bool initdeferred;
 int location;


 _Bool is_no_inherit;
 Node *raw_expr;
 char *cooked_expr;
 char generated_when;


 List *keys;

 List *including;



 List *exclusions;


 List *options;
 char *indexname;
 char *indexspace;
 _Bool reset_default_tblspc;


 char *access_method;
 Node *where_clause;


 RangeVar *pktable;
 List *fk_attrs;
 List *pk_attrs;
 char fk_matchtype;
 char fk_upd_action;
 char fk_del_action;
 List *old_conpfeqop;
 Oid old_pktable_oid;



 _Bool skip_validation;
 _Bool initially_valid;
} Constraint;






typedef struct CreateTableSpaceStmt
{
 NodeTag type;
 char *tablespacename;
 RoleSpec *owner;
 char *location;
 List *options;
} CreateTableSpaceStmt;

typedef struct DropTableSpaceStmt
{
 NodeTag type;
 char *tablespacename;
 _Bool missing_ok;
} DropTableSpaceStmt;

typedef struct AlterTableSpaceOptionsStmt
{
 NodeTag type;
 char *tablespacename;
 List *options;
 _Bool isReset;
} AlterTableSpaceOptionsStmt;

typedef struct AlterTableMoveAllStmt
{
 NodeTag type;
 char *orig_tablespacename;
 ObjectType objtype;
 List *roles;
 char *new_tablespacename;
 _Bool nowait;
} AlterTableMoveAllStmt;






typedef struct CreateExtensionStmt
{
 NodeTag type;
 char *extname;
 _Bool if_not_exists;
 List *options;
} CreateExtensionStmt;


typedef struct AlterExtensionStmt
{
 NodeTag type;
 char *extname;
 List *options;
} AlterExtensionStmt;

typedef struct AlterExtensionContentsStmt
{
 NodeTag type;
 char *extname;
 int action;
 ObjectType objtype;
 Node *object;
} AlterExtensionContentsStmt;






typedef struct CreateFdwStmt
{
 NodeTag type;
 char *fdwname;
 List *func_options;
 List *options;
} CreateFdwStmt;

typedef struct AlterFdwStmt
{
 NodeTag type;
 char *fdwname;
 List *func_options;
 List *options;
} AlterFdwStmt;






typedef struct CreateForeignServerStmt
{
 NodeTag type;
 char *servername;
 char *servertype;
 char *version;
 char *fdwname;
 _Bool if_not_exists;
 List *options;
} CreateForeignServerStmt;

typedef struct AlterForeignServerStmt
{
 NodeTag type;
 char *servername;
 char *version;
 List *options;
 _Bool has_version;
} AlterForeignServerStmt;






typedef struct CreateForeignTableStmt
{
 CreateStmt base;
 char *servername;
 List *options;
} CreateForeignTableStmt;






typedef struct CreateUserMappingStmt
{
 NodeTag type;
 RoleSpec *user;
 char *servername;
 _Bool if_not_exists;
 List *options;
} CreateUserMappingStmt;

typedef struct AlterUserMappingStmt
{
 NodeTag type;
 RoleSpec *user;
 char *servername;
 List *options;
} AlterUserMappingStmt;

typedef struct DropUserMappingStmt
{
 NodeTag type;
 RoleSpec *user;
 char *servername;
 _Bool missing_ok;
} DropUserMappingStmt;






typedef enum ImportForeignSchemaType
{
 FDW_IMPORT_SCHEMA_ALL,
 FDW_IMPORT_SCHEMA_LIMIT_TO,
 FDW_IMPORT_SCHEMA_EXCEPT
} ImportForeignSchemaType;

typedef struct ImportForeignSchemaStmt
{
 NodeTag type;
 char *server_name;
 char *remote_schema;
 char *local_schema;
 ImportForeignSchemaType list_type;
 List *table_list;
 List *options;
} ImportForeignSchemaStmt;





typedef struct CreatePolicyStmt
{
 NodeTag type;
 char *policy_name;
 RangeVar *table;
 char *cmd_name;
 _Bool permissive;
 List *roles;
 Node *qual;
 Node *with_check;
} CreatePolicyStmt;





typedef struct AlterPolicyStmt
{
 NodeTag type;
 char *policy_name;
 RangeVar *table;
 List *roles;
 Node *qual;
 Node *with_check;
} AlterPolicyStmt;





typedef struct CreateAmStmt
{
 NodeTag type;
 char *amname;
 List *handler_name;
 char amtype;
} CreateAmStmt;





typedef struct CreateTrigStmt
{
 NodeTag type;
 char *trigname;
 RangeVar *relation;
 List *funcname;
 List *args;
 _Bool row;

 int16 timing;

 int16 events;
 List *columns;
 Node *whenClause;
 _Bool isconstraint;

 List *transitionRels;

 _Bool deferrable;
 _Bool initdeferred;
 RangeVar *constrrel;
} CreateTrigStmt;





typedef struct CreateEventTrigStmt
{
 NodeTag type;
 char *trigname;
 char *eventname;
 List *whenclause;
 List *funcname;
} CreateEventTrigStmt;





typedef struct AlterEventTrigStmt
{
 NodeTag type;
 char *trigname;
 char tgenabled;

} AlterEventTrigStmt;





typedef struct CreatePLangStmt
{
 NodeTag type;
 _Bool replace;
 char *plname;
 List *plhandler;
 List *plinline;
 List *plvalidator;
 _Bool pltrusted;
} CreatePLangStmt;
# 2476 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef enum RoleStmtType
{
 ROLESTMT_ROLE,
 ROLESTMT_USER,
 ROLESTMT_GROUP
} RoleStmtType;

typedef struct CreateRoleStmt
{
 NodeTag type;
 RoleStmtType stmt_type;
 char *role;
 List *options;
} CreateRoleStmt;

typedef struct AlterRoleStmt
{
 NodeTag type;
 RoleSpec *role;
 List *options;
 int action;
} AlterRoleStmt;

typedef struct AlterRoleSetStmt
{
 NodeTag type;
 RoleSpec *role;
 char *database;
 VariableSetStmt *setstmt;
} AlterRoleSetStmt;

typedef struct DropRoleStmt
{
 NodeTag type;
 List *roles;
 _Bool missing_ok;
} DropRoleStmt;






typedef struct CreateSeqStmt
{
 NodeTag type;
 RangeVar *sequence;
 List *options;
 Oid ownerId;
 _Bool for_identity;
 _Bool if_not_exists;
} CreateSeqStmt;

typedef struct AlterSeqStmt
{
 NodeTag type;
 RangeVar *sequence;
 List *options;
 _Bool for_identity;
 _Bool missing_ok;
} AlterSeqStmt;





typedef struct DefineStmt
{
 NodeTag type;
 ObjectType kind;
 _Bool oldstyle;
 List *defnames;
 List *args;
 List *definition;
 _Bool if_not_exists;
 _Bool replace;
} DefineStmt;





typedef struct CreateDomainStmt
{
 NodeTag type;
 List *domainname;
 TypeName *typeName;
 CollateClause *collClause;
 List *constraints;
} CreateDomainStmt;





typedef struct CreateOpClassStmt
{
 NodeTag type;
 List *opclassname;
 List *opfamilyname;
 char *amname;
 TypeName *datatype;
 List *items;
 _Bool isDefault;
} CreateOpClassStmt;





typedef struct CreateOpClassItem
{
 NodeTag type;
 int itemtype;
 ObjectWithArgs *name;
 int number;
 List *order_family;
 List *class_args;


 TypeName *storedtype;
} CreateOpClassItem;





typedef struct CreateOpFamilyStmt
{
 NodeTag type;
 List *opfamilyname;
 char *amname;
} CreateOpFamilyStmt;





typedef struct AlterOpFamilyStmt
{
 NodeTag type;
 List *opfamilyname;
 char *amname;
 _Bool isDrop;
 List *items;
} AlterOpFamilyStmt;






typedef struct DropStmt
{
 NodeTag type;
 List *objects;
 ObjectType removeType;
 DropBehavior behavior;
 _Bool missing_ok;
 _Bool concurrent;
} DropStmt;





typedef struct TruncateStmt
{
 NodeTag type;
 List *relations;
 _Bool restart_seqs;
 DropBehavior behavior;
} TruncateStmt;





typedef struct CommentStmt
{
 NodeTag type;
 ObjectType objtype;
 Node *object;
 char *comment;
} CommentStmt;





typedef struct SecLabelStmt
{
 NodeTag type;
 ObjectType objtype;
 Node *object;
 char *provider;
 char *label;
} SecLabelStmt;
# 2694 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct DeclareCursorStmt
{
 NodeTag type;
 char *portalname;
 int options;
 Node *query;
} DeclareCursorStmt;





typedef struct ClosePortalStmt
{
 NodeTag type;
 char *portalname;

} ClosePortalStmt;





typedef enum FetchDirection
{

 FETCH_FORWARD,
 FETCH_BACKWARD,

 FETCH_ABSOLUTE,
 FETCH_RELATIVE
} FetchDirection;



typedef struct FetchStmt
{
 NodeTag type;
 FetchDirection direction;
 long howMany;
 char *portalname;
 _Bool ismove;
} FetchStmt;
# 2749 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct IndexStmt
{
 NodeTag type;
 char *idxname;
 RangeVar *relation;
 char *accessMethod;
 char *tableSpace;
 List *indexParams;
 List *indexIncludingParams;

 List *options;
 Node *whereClause;
 List *excludeOpNames;
 char *idxcomment;
 Oid indexOid;
 Oid oldNode;
 _Bool unique;
 _Bool primary;
 _Bool isconstraint;
 _Bool deferrable;
 _Bool initdeferred;
 _Bool transformed;
 _Bool concurrent;
 _Bool if_not_exists;
 _Bool reset_default_tblspc;

} IndexStmt;





typedef struct CreateStatsStmt
{
 NodeTag type;
 List *defnames;
 List *stat_types;
 List *exprs;
 List *relations;
 char *stxcomment;
 _Bool if_not_exists;
} CreateStatsStmt;





typedef struct CreateFunctionStmt
{
 NodeTag type;
 _Bool is_procedure;
 _Bool replace;
 List *funcname;
 List *parameters;
 TypeName *returnType;
 List *options;
} CreateFunctionStmt;

typedef enum FunctionParameterMode
{

 FUNC_PARAM_IN = 'i',
 FUNC_PARAM_OUT = 'o',
 FUNC_PARAM_INOUT = 'b',
 FUNC_PARAM_VARIADIC = 'v',
 FUNC_PARAM_TABLE = 't'
} FunctionParameterMode;

typedef struct FunctionParameter
{
 NodeTag type;
 char *name;
 TypeName *argType;
 FunctionParameterMode mode;
 Node *defexpr;
} FunctionParameter;

typedef struct AlterFunctionStmt
{
 NodeTag type;
 ObjectType objtype;
 ObjectWithArgs *func;
 List *actions;
} AlterFunctionStmt;







typedef struct DoStmt
{
 NodeTag type;
 List *args;
} DoStmt;

typedef struct InlineCodeBlock
{
 NodeTag type;
 char *source_text;
 Oid langOid;
 _Bool langIsTrusted;
 _Bool atomic;
} InlineCodeBlock;





typedef struct CallStmt
{
 NodeTag type;
 FuncCall *funccall;
 FuncExpr *funcexpr;
} CallStmt;

typedef struct CallContext
{
 NodeTag type;
 _Bool atomic;
} CallContext;





typedef struct RenameStmt
{
 NodeTag type;
 ObjectType renameType;
 ObjectType relationType;
 RangeVar *relation;
 Node *object;
 char *subname;

 char *newname;
 DropBehavior behavior;
 _Bool missing_ok;
} RenameStmt;





typedef struct AlterObjectDependsStmt
{
 NodeTag type;
 ObjectType objectType;
 RangeVar *relation;
 Node *object;
 Value *extname;
} AlterObjectDependsStmt;





typedef struct AlterObjectSchemaStmt
{
 NodeTag type;
 ObjectType objectType;
 RangeVar *relation;
 Node *object;
 char *newschema;
 _Bool missing_ok;
} AlterObjectSchemaStmt;





typedef struct AlterOwnerStmt
{
 NodeTag type;
 ObjectType objectType;
 RangeVar *relation;
 Node *object;
 RoleSpec *newowner;
} AlterOwnerStmt;






typedef struct AlterOperatorStmt
{
 NodeTag type;
 ObjectWithArgs *opername;
 List *options;
} AlterOperatorStmt;






typedef struct RuleStmt
{
 NodeTag type;
 RangeVar *relation;
 char *rulename;
 Node *whereClause;
 CmdType event;
 _Bool instead;
 List *actions;
 _Bool replace;
} RuleStmt;





typedef struct NotifyStmt
{
 NodeTag type;
 char *conditionname;
 char *payload;
} NotifyStmt;





typedef struct ListenStmt
{
 NodeTag type;
 char *conditionname;
} ListenStmt;





typedef struct UnlistenStmt
{
 NodeTag type;
 char *conditionname;
} UnlistenStmt;





typedef enum TransactionStmtKind
{
 TRANS_STMT_BEGIN,
 TRANS_STMT_START,
 TRANS_STMT_COMMIT,
 TRANS_STMT_ROLLBACK,
 TRANS_STMT_SAVEPOINT,
 TRANS_STMT_RELEASE,
 TRANS_STMT_ROLLBACK_TO,
 TRANS_STMT_PREPARE,
 TRANS_STMT_COMMIT_PREPARED,
 TRANS_STMT_ROLLBACK_PREPARED
} TransactionStmtKind;

typedef struct TransactionStmt
{
 NodeTag type;
 TransactionStmtKind kind;
 List *options;
 char *savepoint_name;
 char *gid;
 _Bool chain;
} TransactionStmt;





typedef struct CompositeTypeStmt
{
 NodeTag type;
 RangeVar *typevar;
 List *coldeflist;
} CompositeTypeStmt;





typedef struct CreateEnumStmt
{
 NodeTag type;
 List *typeName;
 List *vals;
} CreateEnumStmt;





typedef struct CreateRangeStmt
{
 NodeTag type;
 List *typeName;
 List *params;
} CreateRangeStmt;





typedef struct AlterEnumStmt
{
 NodeTag type;
 List *typeName;
 char *oldVal;
 char *newVal;
 char *newValNeighbor;
 _Bool newValIsAfter;
 _Bool skipIfNewValExists;
} AlterEnumStmt;





typedef enum ViewCheckOption
{
 NO_CHECK_OPTION,
 LOCAL_CHECK_OPTION,
 CASCADED_CHECK_OPTION
} ViewCheckOption;

typedef struct ViewStmt
{
 NodeTag type;
 RangeVar *view;
 List *aliases;
 Node *query;
 _Bool replace;
 List *options;
 ViewCheckOption withCheckOption;
} ViewStmt;





typedef struct LoadStmt
{
 NodeTag type;
 char *filename;
} LoadStmt;





typedef struct CreatedbStmt
{
 NodeTag type;
 char *dbname;
 List *options;
} CreatedbStmt;





typedef struct AlterDatabaseStmt
{
 NodeTag type;
 char *dbname;
 List *options;
} AlterDatabaseStmt;

typedef struct AlterDatabaseSetStmt
{
 NodeTag type;
 char *dbname;
 VariableSetStmt *setstmt;
} AlterDatabaseSetStmt;





typedef struct DropdbStmt
{
 NodeTag type;
 char *dbname;
 _Bool missing_ok;
} DropdbStmt;





typedef struct AlterSystemStmt
{
 NodeTag type;
 VariableSetStmt *setstmt;
} AlterSystemStmt;





typedef enum ClusterOption
{
 CLUOPT_RECHECK = 1 << 0,
 CLUOPT_VERBOSE = 1 << 1
} ClusterOption;

typedef struct ClusterStmt
{
 NodeTag type;
 RangeVar *relation;
 char *indexname;
 int options;
} ClusterStmt;
# 3173 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct VacuumStmt
{
 NodeTag type;
 List *options;
 List *rels;
 _Bool is_vacuumcmd;
} VacuumStmt;
# 3188 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct VacuumRelation
{
 NodeTag type;
 RangeVar *relation;
 Oid oid;
 List *va_cols;
} VacuumRelation;
# 3204 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct ExplainStmt
{
 NodeTag type;
 Node *query;
 List *options;
} ExplainStmt;
# 3224 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef struct CreateTableAsStmt
{
 NodeTag type;
 Node *query;
 IntoClause *into;
 ObjectType relkind;
 _Bool is_select_into;
 _Bool if_not_exists;
} CreateTableAsStmt;





typedef struct RefreshMatViewStmt
{
 NodeTag type;
 _Bool concurrent;
 _Bool skipData;
 RangeVar *relation;
} RefreshMatViewStmt;





typedef struct CheckPointStmt
{
 NodeTag type;
} CheckPointStmt;






typedef enum DiscardMode
{
 DISCARD_ALL,
 DISCARD_PLANS,
 DISCARD_SEQUENCES,
 DISCARD_TEMP
} DiscardMode;

typedef struct DiscardStmt
{
 NodeTag type;
 DiscardMode target;
} DiscardStmt;





typedef struct LockStmt
{
 NodeTag type;
 List *relations;
 int mode;
 _Bool nowait;
} LockStmt;





typedef struct ConstraintsSetStmt
{
 NodeTag type;
 List *constraints;
 _Bool deferred;
} ConstraintsSetStmt;
# 3306 "/products1/postgres/PG12.1/include/server/nodes/parsenodes.h"
typedef enum ReindexObjectType
{
 REINDEX_OBJECT_INDEX,
 REINDEX_OBJECT_TABLE,
 REINDEX_OBJECT_SCHEMA,
 REINDEX_OBJECT_SYSTEM,
 REINDEX_OBJECT_DATABASE
} ReindexObjectType;

typedef struct ReindexStmt
{
 NodeTag type;
 ReindexObjectType kind;

 RangeVar *relation;
 const char *name;
 int options;
 _Bool concurrent;
} ReindexStmt;





typedef struct CreateConversionStmt
{
 NodeTag type;
 List *conversion_name;
 char *for_encoding_name;
 char *to_encoding_name;
 List *func_name;
 _Bool def;
} CreateConversionStmt;





typedef struct CreateCastStmt
{
 NodeTag type;
 TypeName *sourcetype;
 TypeName *targettype;
 ObjectWithArgs *func;
 CoercionContext context;
 _Bool inout;
} CreateCastStmt;





typedef struct CreateTransformStmt
{
 NodeTag type;
 _Bool replace;
 TypeName *type_name;
 char *lang;
 ObjectWithArgs *fromsql;
 ObjectWithArgs *tosql;
} CreateTransformStmt;





typedef struct PrepareStmt
{
 NodeTag type;
 char *name;
 List *argtypes;
 Node *query;
} PrepareStmt;







typedef struct ExecuteStmt
{
 NodeTag type;
 char *name;
 List *params;
} ExecuteStmt;






typedef struct DeallocateStmt
{
 NodeTag type;
 char *name;

} DeallocateStmt;




typedef struct DropOwnedStmt
{
 NodeTag type;
 List *roles;
 DropBehavior behavior;
} DropOwnedStmt;




typedef struct ReassignOwnedStmt
{
 NodeTag type;
 List *roles;
 RoleSpec *newrole;
} ReassignOwnedStmt;




typedef struct AlterTSDictionaryStmt
{
 NodeTag type;
 List *dictname;
 List *options;
} AlterTSDictionaryStmt;




typedef enum AlterTSConfigType
{
 ALTER_TSCONFIG_ADD_MAPPING,
 ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN,
 ALTER_TSCONFIG_REPLACE_DICT,
 ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN,
 ALTER_TSCONFIG_DROP_MAPPING
} AlterTSConfigType;

typedef struct AlterTSConfigurationStmt
{
 NodeTag type;
 AlterTSConfigType kind;
 List *cfgname;





 List *tokentype;
 List *dicts;
 _Bool override;
 _Bool replace;
 _Bool missing_ok;
} AlterTSConfigurationStmt;


typedef struct CreatePublicationStmt
{
 NodeTag type;
 char *pubname;
 List *options;
 List *tables;
 _Bool for_all_tables;
} CreatePublicationStmt;

typedef struct AlterPublicationStmt
{
 NodeTag type;
 char *pubname;


 List *options;


 List *tables;
 _Bool for_all_tables;
 DefElemAction tableAction;
} AlterPublicationStmt;

typedef struct CreateSubscriptionStmt
{
 NodeTag type;
 char *subname;
 char *conninfo;
 List *publication;
 List *options;
} CreateSubscriptionStmt;

typedef enum AlterSubscriptionType
{
 ALTER_SUBSCRIPTION_OPTIONS,
 ALTER_SUBSCRIPTION_CONNECTION,
 ALTER_SUBSCRIPTION_PUBLICATION,
 ALTER_SUBSCRIPTION_REFRESH,
 ALTER_SUBSCRIPTION_ENABLED
} AlterSubscriptionType;

typedef struct AlterSubscriptionStmt
{
 NodeTag type;
 AlterSubscriptionType kind;
 char *subname;
 char *conninfo;
 List *publication;
 List *options;
} AlterSubscriptionStmt;

typedef struct DropSubscriptionStmt
{
 NodeTag type;
 char *subname;
 _Bool missing_ok;
 DropBehavior behavior;
} DropSubscriptionStmt;
# 37 "/products1/postgres/PG12.1/include/server/utils/acl.h" 2
# 1 "/products1/postgres/PG12.1/include/server/parser/parse_node.h" 1
# 18 "/products1/postgres/PG12.1/include/server/parser/parse_node.h"
# 1 "/products1/postgres/PG12.1/include/server/utils/queryenvironment.h" 1
# 20 "/products1/postgres/PG12.1/include/server/utils/queryenvironment.h"
typedef enum EphemeralNameRelationType
{
 ENR_NAMED_TUPLESTORE
} EphemeralNameRelationType;
# 32 "/products1/postgres/PG12.1/include/server/utils/queryenvironment.h"
typedef struct EphemeralNamedRelationMetadataData
{
 char *name;


 Oid reliddesc;
 TupleDesc tupdesc;

 EphemeralNameRelationType enrtype;
 double enrtuples;
} EphemeralNamedRelationMetadataData;

typedef EphemeralNamedRelationMetadataData *EphemeralNamedRelationMetadata;





typedef struct EphemeralNamedRelationData
{
 EphemeralNamedRelationMetadataData md;
 void *reldata;
} EphemeralNamedRelationData;

typedef EphemeralNamedRelationData *EphemeralNamedRelation;







typedef struct QueryEnvironment QueryEnvironment;


extern QueryEnvironment *create_queryEnv(void);
extern EphemeralNamedRelationMetadata get_visible_ENR_metadata(QueryEnvironment *queryEnv, const char *refname);
extern void register_ENR(QueryEnvironment *queryEnv, EphemeralNamedRelation enr);
extern void unregister_ENR(QueryEnvironment *queryEnv, const char *name);
extern EphemeralNamedRelation get_ENR(QueryEnvironment *queryEnv, const char *name);
extern TupleDesc ENRMetadataGetTupDesc(EphemeralNamedRelationMetadata enrmd);
# 19 "/products1/postgres/PG12.1/include/server/parser/parse_node.h" 2
# 33 "/products1/postgres/PG12.1/include/server/parser/parse_node.h"
typedef enum ParseExprKind
{
 EXPR_KIND_NONE = 0,
 EXPR_KIND_OTHER,
 EXPR_KIND_JOIN_ON,
 EXPR_KIND_JOIN_USING,
 EXPR_KIND_FROM_SUBSELECT,
 EXPR_KIND_FROM_FUNCTION,
 EXPR_KIND_WHERE,
 EXPR_KIND_HAVING,
 EXPR_KIND_FILTER,
 EXPR_KIND_WINDOW_PARTITION,
 EXPR_KIND_WINDOW_ORDER,
 EXPR_KIND_WINDOW_FRAME_RANGE,
 EXPR_KIND_WINDOW_FRAME_ROWS,
 EXPR_KIND_WINDOW_FRAME_GROUPS,
 EXPR_KIND_SELECT_TARGET,
 EXPR_KIND_INSERT_TARGET,
 EXPR_KIND_UPDATE_SOURCE,
 EXPR_KIND_UPDATE_TARGET,
 EXPR_KIND_GROUP_BY,
 EXPR_KIND_ORDER_BY,
 EXPR_KIND_DISTINCT_ON,
 EXPR_KIND_LIMIT,
 EXPR_KIND_OFFSET,
 EXPR_KIND_RETURNING,
 EXPR_KIND_VALUES,
 EXPR_KIND_VALUES_SINGLE,
 EXPR_KIND_CHECK_CONSTRAINT,
 EXPR_KIND_DOMAIN_CHECK,
 EXPR_KIND_COLUMN_DEFAULT,
 EXPR_KIND_FUNCTION_DEFAULT,
 EXPR_KIND_INDEX_EXPRESSION,
 EXPR_KIND_INDEX_PREDICATE,
 EXPR_KIND_ALTER_COL_TRANSFORM,
 EXPR_KIND_EXECUTE_PARAMETER,
 EXPR_KIND_TRIGGER_WHEN,
 EXPR_KIND_POLICY,
 EXPR_KIND_PARTITION_BOUND,
 EXPR_KIND_PARTITION_EXPRESSION,
 EXPR_KIND_CALL_ARGUMENT,
 EXPR_KIND_COPY_WHERE,
 EXPR_KIND_GENERATED_COLUMN,
} ParseExprKind;





typedef struct ParseState ParseState;

typedef Node *(*PreParseColumnRefHook) (ParseState *pstate, ColumnRef *cref);
typedef Node *(*PostParseColumnRefHook) (ParseState *pstate, ColumnRef *cref, Node *var);
typedef Node *(*ParseParamRefHook) (ParseState *pstate, ParamRef *pref);
typedef Node *(*CoerceParamHook) (ParseState *pstate, Param *param,
          Oid targetTypeId, int32 targetTypeMod,
          int location);
# 173 "/products1/postgres/PG12.1/include/server/parser/parse_node.h"
struct ParseState
{
 struct ParseState *parentParseState;
 const char *p_sourcetext;
 List *p_rtable;
 List *p_joinexprs;
 List *p_joinlist;

 List *p_namespace;

 _Bool p_lateral_active;
 List *p_ctenamespace;
 List *p_future_ctes;
 CommonTableExpr *p_parent_cte;
 Relation p_target_relation;
 RangeTblEntry *p_target_rangetblentry;
 _Bool p_is_insert;
 List *p_windowdefs;
 ParseExprKind p_expr_kind;
 int p_next_resno;
 List *p_multiassign_exprs;
 List *p_locking_clause;
 _Bool p_locked_from_parent;

 _Bool p_resolve_unknowns;


 QueryEnvironment *p_queryEnv;


 _Bool p_hasAggs;
 _Bool p_hasWindowFuncs;
 _Bool p_hasTargetSRFs;
 _Bool p_hasSubLinks;
 _Bool p_hasModifyingCTE;

 Node *p_last_srf;





 PreParseColumnRefHook p_pre_columnref_hook;
 PostParseColumnRefHook p_post_columnref_hook;
 ParseParamRefHook p_paramref_hook;
 CoerceParamHook p_coerce_param_hook;
 void *p_ref_hook_state;
};
# 249 "/products1/postgres/PG12.1/include/server/parser/parse_node.h"
typedef struct ParseNamespaceItem
{
 RangeTblEntry *p_rte;
 _Bool p_rel_visible;
 _Bool p_cols_visible;
 _Bool p_lateral_only;
 _Bool p_lateral_ok;
} ParseNamespaceItem;


typedef struct ParseCallbackState
{
 ParseState *pstate;
 int location;
 ErrorContextCallback errcallback;
} ParseCallbackState;


extern ParseState *make_parsestate(ParseState *parentParseState);
extern void free_parsestate(ParseState *pstate);
extern int parser_errposition(ParseState *pstate, int location);

extern void setup_parser_errposition_callback(ParseCallbackState *pcbstate,
             ParseState *pstate, int location);
extern void cancel_parser_errposition_callback(ParseCallbackState *pcbstate);

extern Var *make_var(ParseState *pstate, RangeTblEntry *rte, int attrno,
      int location);
extern Oid transformContainerType(Oid *containerType, int32 *containerTypmod);

extern SubscriptingRef *transformContainerSubscripts(ParseState *pstate,
              Node *containerBase,
              Oid containerType,
              Oid elementType,
              int32 containerTypMod,
              List *indirection,
              Node *assignFrom);
extern Const *make_const(ParseState *pstate, Value *value, int location);
# 38 "/products1/postgres/PG12.1/include/server/utils/acl.h" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/array.h" 1
# 65 "/products1/postgres/PG12.1/include/server/utils/array.h"
# 1 "/products1/postgres/PG12.1/include/server/utils/expandeddatum.h" 1
# 67 "/products1/postgres/PG12.1/include/server/utils/expandeddatum.h"
typedef Size (*EOM_get_flat_size_method) (ExpandedObjectHeader *eohptr);
typedef void (*EOM_flatten_into_method) (ExpandedObjectHeader *eohptr,
           void *result, Size allocated_size);


typedef struct ExpandedObjectMethods
{
 EOM_get_flat_size_method get_flat_size;
 EOM_flatten_into_method flatten_into;
} ExpandedObjectMethods;
# 98 "/products1/postgres/PG12.1/include/server/utils/expandeddatum.h"
struct ExpandedObjectHeader
{

 int32 vl_len_;


 const ExpandedObjectMethods *eoh_methods;


 MemoryContext eoh_context;


 char eoh_rw_ptr[(__builtin_offsetof (varattrib_1b_e, va_data) + sizeof(varatt_expanded))];


 char eoh_ro_ptr[(__builtin_offsetof (varattrib_1b_e, va_data) + sizeof(varatt_expanded))];
};
# 148 "/products1/postgres/PG12.1/include/server/utils/expandeddatum.h"
extern ExpandedObjectHeader *DatumGetEOHP(Datum d);
extern void EOH_init_header(ExpandedObjectHeader *eohptr,
       const ExpandedObjectMethods *methods,
       MemoryContext obj_context);
extern Size EOH_get_flat_size(ExpandedObjectHeader *eohptr);
extern void EOH_flatten_into(ExpandedObjectHeader *eohptr,
        void *result, Size allocated_size);
extern Datum MakeExpandedObjectReadOnlyInternal(Datum d);
extern Datum TransferExpandedObject(Datum d, MemoryContext new_parent);
extern void DeleteExpandedObject(Datum d);
# 66 "/products1/postgres/PG12.1/include/server/utils/array.h" 2


struct ExprState;
struct ExprContext;
# 80 "/products1/postgres/PG12.1/include/server/utils/array.h"
typedef struct
{
 int32 vl_len_;
 int ndim;
 int32 dataoffset;
 Oid elemtype;
} ArrayType;
# 103 "/products1/postgres/PG12.1/include/server/utils/array.h"
typedef struct ExpandedArrayHeader
{

 ExpandedObjectHeader hdr;


 int ea_magic;


 int ndims;
 int *dims;
 int *lbound;


 Oid element_type;
 int16 typlen;
 _Bool typbyval;
 char typalign;
# 134 "/products1/postgres/PG12.1/include/server/utils/array.h"
 Datum *dvalues;
 _Bool *dnulls;
 int dvalueslen;
 int nelems;






 Size flat_size;
# 153 "/products1/postgres/PG12.1/include/server/utils/array.h"
 ArrayType *fvalue;
 char *fstartptr;
 char *fendptr;
} ExpandedArrayHeader;
# 165 "/products1/postgres/PG12.1/include/server/utils/array.h"
typedef union AnyArrayType
{
 ArrayType flt;
 ExpandedArrayHeader xpn;
} AnyArrayType;





typedef struct ArrayBuildState
{
 MemoryContext mcontext;
 Datum *dvalues;
 _Bool *dnulls;
 int alen;
 int nelems;
 Oid element_type;
 int16 typlen;
 _Bool typbyval;
 char typalign;
 _Bool private_cxt;
} ArrayBuildState;





typedef struct ArrayBuildStateArr
{
 MemoryContext mcontext;
 char *data;
 bits8 *nullbitmap;
 int abytes;
 int nbytes;
 int aitems;
 int nitems;
 int ndims;
 int dims[6];
 int lbs[6];
 Oid array_type;
 Oid element_type;
 _Bool private_cxt;
} ArrayBuildStateArr;





typedef struct ArrayBuildStateAny
{

 ArrayBuildState *scalarstate;
 ArrayBuildStateArr *arraystate;
} ArrayBuildStateAny;




typedef struct ArrayMetaState
{
 Oid element_type;
 int16 typlen;
 _Bool typbyval;
 char typalign;
 char typdelim;
 Oid typioparam;
 Oid typiofunc;
 FmgrInfo proc;
} ArrayMetaState;




typedef struct ArrayMapState
{
 ArrayMetaState inp_extra;
 ArrayMetaState ret_extra;
} ArrayMapState;


typedef struct ArrayIteratorData *ArrayIterator;
# 337 "/products1/postgres/PG12.1/include/server/utils/array.h"
extern _Bool Array_nulls;




extern void CopyArrayEls(ArrayType *array,
       Datum *values,
       _Bool *nulls,
       int nitems,
       int typlen,
       _Bool typbyval,
       char typalign,
       _Bool freedata);

extern Datum array_get_element(Datum arraydatum, int nSubscripts, int *indx,
          int arraytyplen, int elmlen, _Bool elmbyval, char elmalign,
          _Bool *isNull);
extern Datum array_set_element(Datum arraydatum, int nSubscripts, int *indx,
          Datum dataValue, _Bool isNull,
          int arraytyplen, int elmlen, _Bool elmbyval, char elmalign);
extern Datum array_get_slice(Datum arraydatum, int nSubscripts,
        int *upperIndx, int *lowerIndx,
        _Bool *upperProvided, _Bool *lowerProvided,
        int arraytyplen, int elmlen, _Bool elmbyval, char elmalign);
extern Datum array_set_slice(Datum arraydatum, int nSubscripts,
        int *upperIndx, int *lowerIndx,
        _Bool *upperProvided, _Bool *lowerProvided,
        Datum srcArrayDatum, _Bool isNull,
        int arraytyplen, int elmlen, _Bool elmbyval, char elmalign);

extern Datum array_ref(ArrayType *array, int nSubscripts, int *indx,
        int arraytyplen, int elmlen, _Bool elmbyval, char elmalign,
        _Bool *isNull);
extern ArrayType *array_set(ArrayType *array, int nSubscripts, int *indx,
       Datum dataValue, _Bool isNull,
       int arraytyplen, int elmlen, _Bool elmbyval, char elmalign);

extern Datum array_map(Datum arrayd,
        struct ExprState *exprstate, struct ExprContext *econtext,
        Oid retType, ArrayMapState *amstate);

extern void array_bitmap_copy(bits8 *destbitmap, int destoffset,
         const bits8 *srcbitmap, int srcoffset,
         int nitems);

extern ArrayType *construct_array(Datum *elems, int nelems,
          Oid elmtype,
          int elmlen, _Bool elmbyval, char elmalign);
extern ArrayType *construct_md_array(Datum *elems,
          _Bool *nulls,
          int ndims,
          int *dims,
          int *lbs,
          Oid elmtype, int elmlen, _Bool elmbyval, char elmalign);
extern ArrayType *construct_empty_array(Oid elmtype);
extern ExpandedArrayHeader *construct_empty_expanded_array(Oid element_type,
                 MemoryContext parentcontext,
                 ArrayMetaState *metacache);
extern void deconstruct_array(ArrayType *array,
         Oid elmtype,
         int elmlen, _Bool elmbyval, char elmalign,
         Datum **elemsp, _Bool **nullsp, int *nelemsp);
extern _Bool array_contains_nulls(ArrayType *array);

extern ArrayBuildState *initArrayResult(Oid element_type,
          MemoryContext rcontext, _Bool subcontext);
extern ArrayBuildState *accumArrayResult(ArrayBuildState *astate,
           Datum dvalue, _Bool disnull,
           Oid element_type,
           MemoryContext rcontext);
extern Datum makeArrayResult(ArrayBuildState *astate,
        MemoryContext rcontext);
extern Datum makeMdArrayResult(ArrayBuildState *astate, int ndims,
          int *dims, int *lbs, MemoryContext rcontext, _Bool release);

extern ArrayBuildStateArr *initArrayResultArr(Oid array_type, Oid element_type,
             MemoryContext rcontext, _Bool subcontext);
extern ArrayBuildStateArr *accumArrayResultArr(ArrayBuildStateArr *astate,
              Datum dvalue, _Bool disnull,
              Oid array_type,
              MemoryContext rcontext);
extern Datum makeArrayResultArr(ArrayBuildStateArr *astate,
        MemoryContext rcontext, _Bool release);

extern ArrayBuildStateAny *initArrayResultAny(Oid input_type,
             MemoryContext rcontext, _Bool subcontext);
extern ArrayBuildStateAny *accumArrayResultAny(ArrayBuildStateAny *astate,
              Datum dvalue, _Bool disnull,
              Oid input_type,
              MemoryContext rcontext);
extern Datum makeArrayResultAny(ArrayBuildStateAny *astate,
        MemoryContext rcontext, _Bool release);

extern ArrayIterator array_create_iterator(ArrayType *arr, int slice_ndim, ArrayMetaState *mstate);
extern _Bool array_iterate(ArrayIterator iterator, Datum *value, _Bool *isnull);
extern void array_free_iterator(ArrayIterator iterator);





extern int ArrayGetOffset(int n, const int *dim, const int *lb, const int *indx);
extern int ArrayGetOffset0(int n, const int *tup, const int *scale);
extern int ArrayGetNItems(int ndim, const int *dims);
extern void mda_get_range(int n, int *span, const int *st, const int *endp);
extern void mda_get_prod(int n, const int *range, int *prod);
extern void mda_get_offset_values(int n, int *dist, const int *prod, const int *span);
extern int mda_next_tuple(int n, int *curr, const int *span);
extern int32 *ArrayGetIntegerTypmods(ArrayType *arr, int *n);




extern Datum expand_array(Datum arraydatum, MemoryContext parentcontext,
        ArrayMetaState *metacache);
extern ExpandedArrayHeader *DatumGetExpandedArray(Datum d);
extern ExpandedArrayHeader *DatumGetExpandedArrayX(Datum d,
               ArrayMetaState *metacache);
extern AnyArrayType *DatumGetAnyArrayP(Datum d);
extern void deconstruct_expanded_array(ExpandedArrayHeader *eah);
# 39 "/products1/postgres/PG12.1/include/server/utils/acl.h" 2
# 55 "/products1/postgres/PG12.1/include/server/utils/acl.h"
typedef struct AclItem
{
 Oid ai_grantee;
 Oid ai_grantor;
 AclMode ai_privs;
} AclItem;
# 107 "/products1/postgres/PG12.1/include/server/utils/acl.h"
typedef ArrayType Acl;
# 171 "/products1/postgres/PG12.1/include/server/utils/acl.h"
typedef enum
{
 ACLMASK_ALL,
 ACLMASK_ANY
} AclMaskHow;


typedef enum
{
 ACLCHECK_OK = 0,
 ACLCHECK_NO_PRIV,
 ACLCHECK_NOT_OWNER
} AclResult;





extern Acl *acldefault(ObjectType objtype, Oid ownerId);
extern Acl *get_user_default_acl(ObjectType objtype, Oid ownerId,
         Oid nsp_oid);
extern void recordDependencyOnNewAcl(Oid classId, Oid objectId, int32 objsubId,
          Oid ownerId, Acl *acl);

extern Acl *aclupdate(const Acl *old_acl, const AclItem *mod_aip,
       int modechg, Oid ownerId, DropBehavior behavior);
extern Acl *aclnewowner(const Acl *old_acl, Oid oldOwnerId, Oid newOwnerId);
extern Acl *make_empty_acl(void);
extern Acl *aclcopy(const Acl *orig_acl);
extern Acl *aclconcat(const Acl *left_acl, const Acl *right_acl);
extern Acl *aclmerge(const Acl *left_acl, const Acl *right_acl, Oid ownerId);
extern void aclitemsort(Acl *acl);
extern _Bool aclequal(const Acl *left_acl, const Acl *right_acl);

extern AclMode aclmask(const Acl *acl, Oid roleid, Oid ownerId,
        AclMode mask, AclMaskHow how);
extern int aclmembers(const Acl *acl, Oid **roleids);

extern _Bool has_privs_of_role(Oid member, Oid role);
extern _Bool is_member_of_role(Oid member, Oid role);
extern _Bool is_member_of_role_nosuper(Oid member, Oid role);
extern _Bool is_admin_of_role(Oid member, Oid role);
extern void check_is_member_of_role(Oid member, Oid role);
extern Oid get_role_oid(const char *rolename, _Bool missing_ok);
extern Oid get_role_oid_or_public(const char *rolename);
extern Oid get_rolespec_oid(const RoleSpec *role, _Bool missing_ok);
extern void check_rolespec_name(const RoleSpec *role, const char *detail_msg);
extern HeapTuple get_rolespec_tuple(const RoleSpec *role);
extern char *get_rolespec_name(const RoleSpec *role);

extern void select_best_grantor(Oid roleId, AclMode privileges,
        const Acl *acl, Oid ownerId,
        Oid *grantorId, AclMode *grantOptions);

extern void initialize_acl(void);




extern void ExecuteGrantStmt(GrantStmt *stmt);
extern void ExecAlterDefaultPrivilegesStmt(ParseState *pstate, AlterDefaultPrivilegesStmt *stmt);

extern void RemoveRoleFromObjectACL(Oid roleid, Oid classid, Oid objid);
extern void RemoveDefaultACLById(Oid defaclOid);

extern AclMode pg_attribute_aclmask(Oid table_oid, AttrNumber attnum,
         Oid roleid, AclMode mask, AclMaskHow how);
extern AclMode pg_class_aclmask(Oid table_oid, Oid roleid,
        AclMode mask, AclMaskHow how);
extern AclMode pg_database_aclmask(Oid db_oid, Oid roleid,
           AclMode mask, AclMaskHow how);
extern AclMode pg_proc_aclmask(Oid proc_oid, Oid roleid,
          AclMode mask, AclMaskHow how);
extern AclMode pg_language_aclmask(Oid lang_oid, Oid roleid,
           AclMode mask, AclMaskHow how);
extern AclMode pg_largeobject_aclmask_snapshot(Oid lobj_oid, Oid roleid,
              AclMode mask, AclMaskHow how, Snapshot snapshot);
extern AclMode pg_namespace_aclmask(Oid nsp_oid, Oid roleid,
         AclMode mask, AclMaskHow how);
extern AclMode pg_tablespace_aclmask(Oid spc_oid, Oid roleid,
          AclMode mask, AclMaskHow how);
extern AclMode pg_foreign_data_wrapper_aclmask(Oid fdw_oid, Oid roleid,
              AclMode mask, AclMaskHow how);
extern AclMode pg_foreign_server_aclmask(Oid srv_oid, Oid roleid,
           AclMode mask, AclMaskHow how);
extern AclMode pg_type_aclmask(Oid type_oid, Oid roleid,
          AclMode mask, AclMaskHow how);

extern AclResult pg_attribute_aclcheck(Oid table_oid, AttrNumber attnum,
            Oid roleid, AclMode mode);
extern AclResult pg_attribute_aclcheck_all(Oid table_oid, Oid roleid,
             AclMode mode, AclMaskHow how);
extern AclResult pg_class_aclcheck(Oid table_oid, Oid roleid, AclMode mode);
extern AclResult pg_database_aclcheck(Oid db_oid, Oid roleid, AclMode mode);
extern AclResult pg_proc_aclcheck(Oid proc_oid, Oid roleid, AclMode mode);
extern AclResult pg_language_aclcheck(Oid lang_oid, Oid roleid, AclMode mode);
extern AclResult pg_largeobject_aclcheck_snapshot(Oid lang_oid, Oid roleid,
              AclMode mode, Snapshot snapshot);
extern AclResult pg_namespace_aclcheck(Oid nsp_oid, Oid roleid, AclMode mode);
extern AclResult pg_tablespace_aclcheck(Oid spc_oid, Oid roleid, AclMode mode);
extern AclResult pg_foreign_data_wrapper_aclcheck(Oid fdw_oid, Oid roleid, AclMode mode);
extern AclResult pg_foreign_server_aclcheck(Oid srv_oid, Oid roleid, AclMode mode);
extern AclResult pg_type_aclcheck(Oid type_oid, Oid roleid, AclMode mode);

extern void aclcheck_error(AclResult aclerr, ObjectType objtype,
         const char *objectname);

extern void aclcheck_error_col(AclResult aclerr, ObjectType objtype,
          const char *objectname, const char *colname);

extern void aclcheck_error_type(AclResult aclerr, Oid typeOid);

extern void recordExtObjInitPriv(Oid objoid, Oid classoid);
extern void removeExtObjInitPriv(Oid objoid, Oid classoid);



extern _Bool pg_class_ownercheck(Oid class_oid, Oid roleid);
extern _Bool pg_type_ownercheck(Oid type_oid, Oid roleid);
extern _Bool pg_oper_ownercheck(Oid oper_oid, Oid roleid);
extern _Bool pg_proc_ownercheck(Oid proc_oid, Oid roleid);
extern _Bool pg_language_ownercheck(Oid lan_oid, Oid roleid);
extern _Bool pg_largeobject_ownercheck(Oid lobj_oid, Oid roleid);
extern _Bool pg_namespace_ownercheck(Oid nsp_oid, Oid roleid);
extern _Bool pg_tablespace_ownercheck(Oid spc_oid, Oid roleid);
extern _Bool pg_opclass_ownercheck(Oid opc_oid, Oid roleid);
extern _Bool pg_opfamily_ownercheck(Oid opf_oid, Oid roleid);
extern _Bool pg_database_ownercheck(Oid db_oid, Oid roleid);
extern _Bool pg_collation_ownercheck(Oid coll_oid, Oid roleid);
extern _Bool pg_conversion_ownercheck(Oid conv_oid, Oid roleid);
extern _Bool pg_ts_dict_ownercheck(Oid dict_oid, Oid roleid);
extern _Bool pg_ts_config_ownercheck(Oid cfg_oid, Oid roleid);
extern _Bool pg_foreign_data_wrapper_ownercheck(Oid srv_oid, Oid roleid);
extern _Bool pg_foreign_server_ownercheck(Oid srv_oid, Oid roleid);
extern _Bool pg_event_trigger_ownercheck(Oid et_oid, Oid roleid);
extern _Bool pg_extension_ownercheck(Oid ext_oid, Oid roleid);
extern _Bool pg_publication_ownercheck(Oid pub_oid, Oid roleid);
extern _Bool pg_subscription_ownercheck(Oid sub_oid, Oid roleid);
extern _Bool pg_statistics_object_ownercheck(Oid stat_oid, Oid roleid);
extern _Bool has_createrole_privilege(Oid roleid);
extern _Bool has_bypassrls_privilege(Oid roleid);
# 19 "/products1/postgres/PG12.1/include/server/catalog/objectaddress.h" 2





typedef struct ObjectAddress
{
 Oid classId;
 Oid objectId;
 int32 objectSubId;
} ObjectAddress;

extern const ObjectAddress InvalidObjectAddress;
# 43 "/products1/postgres/PG12.1/include/server/catalog/objectaddress.h"
extern ObjectAddress get_object_address(ObjectType objtype, Node *object,
          Relation *relp,
          LOCKMODE lockmode, _Bool missing_ok);

extern ObjectAddress get_object_address_rv(ObjectType objtype, RangeVar *rel,
             List *object, Relation *relp,
             LOCKMODE lockmode, _Bool missing_ok);

extern void check_object_ownership(Oid roleid,
           ObjectType objtype, ObjectAddress address,
           Node *object, Relation relation);

extern Oid get_object_namespace(const ObjectAddress *address);

extern _Bool is_objectclass_supported(Oid class_id);
extern Oid get_object_oid_index(Oid class_id);
extern int get_object_catcache_oid(Oid class_id);
extern int get_object_catcache_name(Oid class_id);
extern AttrNumber get_object_attnum_oid(Oid class_id);
extern AttrNumber get_object_attnum_name(Oid class_id);
extern AttrNumber get_object_attnum_namespace(Oid class_id);
extern AttrNumber get_object_attnum_owner(Oid class_id);
extern AttrNumber get_object_attnum_acl(Oid class_id);
extern ObjectType get_object_type(Oid class_id, Oid object_id);
extern _Bool get_object_namensp_unique(Oid class_id);

extern HeapTuple get_catalog_object_by_oid(Relation catalog,
             AttrNumber oidcol, Oid objectId);

extern char *getObjectDescription(const ObjectAddress *object);
extern char *getObjectDescriptionOids(Oid classid, Oid objid);

extern int read_objtype_from_string(const char *objtype);
extern char *getObjectTypeDescription(const ObjectAddress *object);
extern char *getObjectIdentity(const ObjectAddress *address);
extern char *getObjectIdentityParts(const ObjectAddress *address,
         List **objname, List **objargs);
extern ArrayType *strlist_to_textarray(List *list);

extern ObjectType get_relkind_objtype(char relkind);
# 25 "/products1/postgres/PG12.1/include/server/catalog/pg_operator.h" 2







typedef struct FormData_pg_operator
{
 Oid oid;


 NameData oprname;


 Oid oprnamespace ;


 Oid oprowner ;


 char oprkind ;


 _Bool oprcanmerge ;


 _Bool oprcanhash ;


 Oid oprleft ;


 Oid oprright ;


 Oid oprresult ;


 Oid oprcom ;


 Oid oprnegate ;


 regproc oprcode ;


 regproc oprrest ;


 regproc oprjoin ;
} FormData_pg_operator;






typedef FormData_pg_operator *Form_pg_operator;


extern ObjectAddress OperatorCreate(const char *operatorName,
         Oid operatorNamespace,
         Oid leftTypeId,
         Oid rightTypeId,
         Oid procedureId,
         List *commutatorName,
         List *negatorName,
         Oid restrictionId,
         Oid joinId,
         _Bool canMerge,
         _Bool canHash);

extern ObjectAddress makeOperatorDependencies(HeapTuple tuple, _Bool isUpdate);

extern void OperatorUpd(Oid baseId, Oid commId, Oid negId, _Bool isDelete);
# 24 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_proc.h" 1
# 21 "/products1/postgres/PG12.1/include/server/catalog/pg_proc.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_proc_d.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_proc.h" 2
# 31 "/products1/postgres/PG12.1/include/server/catalog/pg_proc.h"
typedef struct FormData_pg_proc
{
 Oid oid;


 NameData proname;


 Oid pronamespace ;


 Oid proowner ;


 Oid prolang ;


 float4 procost ;


 float4 prorows ;


 Oid provariadic ;


 regproc prosupport ;


 char prokind ;


 _Bool prosecdef ;


 _Bool proleakproof ;


 _Bool proisstrict ;


 _Bool proretset ;


 char provolatile ;


 char proparallel ;



 int16 pronargs;


 int16 pronargdefaults ;


 Oid prorettype ;







 oidvector proargtypes ;
# 127 "/products1/postgres/PG12.1/include/server/catalog/pg_proc.h"
} FormData_pg_proc;






typedef FormData_pg_proc *Form_pg_proc;
# 181 "/products1/postgres/PG12.1/include/server/catalog/pg_proc.h"
extern ObjectAddress ProcedureCreate(const char *procedureName,
          Oid procNamespace,
          _Bool replace,
          _Bool returnsSet,
          Oid returnType,
          Oid proowner,
          Oid languageObjectId,
          Oid languageValidator,
          const char *prosrc,
          const char *probin,
          char prokind,
          _Bool security_definer,
          _Bool isLeakProof,
          _Bool isStrict,
          char volatility,
          char parallel,
          oidvector *parameterTypes,
          Datum allParameterTypes,
          Datum parameterModes,
          Datum parameterNames,
          List *parameterDefaults,
          Datum trftypes,
          Datum proconfig,
          Oid prosupport,
          float4 procost,
          float4 prorows);

extern _Bool function_parse_error_transpose(const char *prosrc);

extern List *oid_array_to_list(Datum datum);
# 25 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_user_mapping.h" 1
# 21 "/products1/postgres/PG12.1/include/server/catalog/pg_user_mapping.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_user_mapping_d.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_user_mapping.h" 2






typedef struct FormData_pg_user_mapping
{
 Oid oid;

 Oid umuser;

 Oid umserver;




} FormData_pg_user_mapping;






typedef FormData_pg_user_mapping *Form_pg_user_mapping;
# 26 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_type_d.h" 1
# 23 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h" 2
# 37 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
typedef struct FormData_pg_type
{
 Oid oid;


 NameData typname;


 Oid typnamespace ;


 Oid typowner ;
# 57 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
 int16 typlen ;
# 67 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
 _Bool typbyval ;
# 76 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
 char typtype ;
# 86 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
 char typcategory ;


 _Bool typispreferred ;






 _Bool typisdefined ;


 char typdelim ;


 Oid typrelid ;
# 115 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
 Oid typelem ;





 Oid typarray ;






 regproc typinput ;
 regproc typoutput ;


 regproc typreceive ;
 regproc typsend ;




 regproc typmodin ;
 regproc typmodout ;




 regproc typanalyze ;
# 170 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
 char typalign;
# 182 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
 char typstorage ;
# 192 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
 _Bool typnotnull ;





 Oid typbasetype ;






 int32 typtypmod ;





 int32 typndims ;






 Oid typcollation ;
# 244 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
} FormData_pg_type;






typedef FormData_pg_type *Form_pg_type;
# 293 "/products1/postgres/PG12.1/include/server/catalog/pg_type.h"
extern ObjectAddress TypeShellMake(const char *typeName,
           Oid typeNamespace,
           Oid ownerId);

extern ObjectAddress TypeCreate(Oid newTypeOid,
        const char *typeName,
        Oid typeNamespace,
        Oid relationOid,
        char relationKind,
        Oid ownerId,
        int16 internalSize,
        char typeType,
        char typeCategory,
        _Bool typePreferred,
        char typDelim,
        Oid inputProcedure,
        Oid outputProcedure,
        Oid receiveProcedure,
        Oid sendProcedure,
        Oid typmodinProcedure,
        Oid typmodoutProcedure,
        Oid analyzeProcedure,
        Oid elementType,
        _Bool isImplicitArray,
        Oid arrayType,
        Oid baseType,
        const char *defaultTypeValue,
        char *defaultTypeBin,
        _Bool passedByValue,
        char alignment,
        char storage,
        int32 typeMod,
        int32 typNDims,
        _Bool typeNotNull,
        Oid typeCollation);

extern void GenerateTypeDependencies(Oid typeObjectId,
          Form_pg_type typeForm,
          Node *defaultExpr,
          void *typacl,
          char relationKind,

          _Bool isImplicitArray,
          _Bool isDependentType,
          _Bool rebuild);

extern void RenameTypeInternal(Oid typeOid, const char *newTypeName,
          Oid typeNamespace);

extern char *makeArrayTypeName(const char *typeName, Oid typeNamespace);

extern _Bool moveArrayTypeName(Oid typeOid, const char *typeName,
         Oid typeNamespace);
# 27 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/commands/defrem.h" 1
# 18 "/products1/postgres/PG12.1/include/server/commands/defrem.h"
# 1 "/products1/postgres/PG12.1/include/server/nodes/params.h" 1
# 18 "/products1/postgres/PG12.1/include/server/nodes/params.h"
struct Bitmapset;
struct ExprState;
struct Param;
struct ParseState;
# 90 "/products1/postgres/PG12.1/include/server/nodes/params.h"
typedef struct ParamExternData
{
 Datum value;
 _Bool isnull;
 uint16 pflags;
 Oid ptype;
} ParamExternData;

typedef struct ParamListInfoData *ParamListInfo;

typedef ParamExternData *(*ParamFetchHook) (ParamListInfo params,
           int paramid, _Bool speculative,
           ParamExternData *workspace);

typedef void (*ParamCompileHook) (ParamListInfo params, struct Param *param,
          struct ExprState *state,
          Datum *resv, _Bool *resnull);

typedef void (*ParserSetupHook) (struct ParseState *pstate, void *arg);

typedef struct ParamListInfoData
{
 ParamFetchHook paramFetch;
 void *paramFetchArg;
 ParamCompileHook paramCompile;
 void *paramCompileArg;
 ParserSetupHook parserSetup;
 void *parserSetupArg;
 int numParams;





 ParamExternData params[];
} ParamListInfoData;
# 145 "/products1/postgres/PG12.1/include/server/nodes/params.h"
typedef struct ParamExecData
{
 void *execPlan;
 Datum value;
 _Bool isnull;
} ParamExecData;



extern ParamListInfo makeParamList(int numParams);
extern ParamListInfo copyParamList(ParamListInfo from);
extern Size EstimateParamListSpace(ParamListInfo paramLI);
extern void SerializeParamList(ParamListInfo paramLI, char **start_address);
extern ParamListInfo RestoreParamList(char **start_address);
# 19 "/products1/postgres/PG12.1/include/server/commands/defrem.h" 2

# 1 "/products1/postgres/PG12.1/include/server/tcop/dest.h" 1
# 70 "/products1/postgres/PG12.1/include/server/tcop/dest.h"
# 1 "/products1/postgres/PG12.1/include/server/executor/tuptable.h" 1
# 111 "/products1/postgres/PG12.1/include/server/executor/tuptable.h"
struct TupleTableSlotOps;
typedef struct TupleTableSlotOps TupleTableSlotOps;


typedef struct TupleTableSlot
{
 NodeTag type;

 uint16 tts_flags;

 AttrNumber tts_nvalid;
 const TupleTableSlotOps *const tts_ops;

 TupleDesc tts_tupleDescriptor;

 Datum *tts_values;

 _Bool *tts_isnull;
 MemoryContext tts_mcxt;
 ItemPointerData tts_tid;
 Oid tts_tableOid;
} TupleTableSlot;


struct TupleTableSlotOps
{

 size_t base_slot_size;


 void (*init) (TupleTableSlot *slot);


 void (*release) (TupleTableSlot *slot);







 void (*clear) (TupleTableSlot *slot);
# 161 "/products1/postgres/PG12.1/include/server/executor/tuptable.h"
 void (*getsomeattrs) (TupleTableSlot *slot, int natts);






 Datum (*getsysattr) (TupleTableSlot *slot, int attnum, _Bool *isnull);





 void (*materialize) (TupleTableSlot *slot);





 void (*copyslot) (TupleTableSlot *dstslot, TupleTableSlot *srcslot);







 HeapTuple (*get_heap_tuple) (TupleTableSlot *slot);







 MinimalTuple (*get_minimal_tuple) (TupleTableSlot *slot);
# 206 "/products1/postgres/PG12.1/include/server/executor/tuptable.h"
 HeapTuple (*copy_heap_tuple) (TupleTableSlot *slot);
# 216 "/products1/postgres/PG12.1/include/server/executor/tuptable.h"
 MinimalTuple (*copy_minimal_tuple) (TupleTableSlot *slot);
};





extern const TupleTableSlotOps TTSOpsVirtual;
extern const TupleTableSlotOps TTSOpsHeapTuple;
extern const TupleTableSlotOps TTSOpsMinimalTuple;
extern const TupleTableSlotOps TTSOpsBufferHeapTuple;
# 238 "/products1/postgres/PG12.1/include/server/executor/tuptable.h"
typedef struct VirtualTupleTableSlot
{
 TupleTableSlot base;

 char *data;
} VirtualTupleTableSlot;

typedef struct HeapTupleTableSlot
{
 TupleTableSlot base;


 HeapTuple tuple;

 uint32 off;
 HeapTupleData tupdata;
} HeapTupleTableSlot;


typedef struct BufferHeapTupleTableSlot
{
 HeapTupleTableSlot base;







 Buffer buffer;
} BufferHeapTupleTableSlot;

typedef struct MinimalTupleTableSlot
{
 TupleTableSlot base;
# 282 "/products1/postgres/PG12.1/include/server/executor/tuptable.h"
 HeapTuple tuple;
 MinimalTuple mintuple;
 HeapTupleData minhdr;

 uint32 off;
} MinimalTupleTableSlot;
# 296 "/products1/postgres/PG12.1/include/server/executor/tuptable.h"
extern TupleTableSlot *MakeTupleTableSlot(TupleDesc tupleDesc,
            const TupleTableSlotOps *tts_ops);
extern TupleTableSlot *ExecAllocTableSlot(List **tupleTable, TupleDesc desc,
            const TupleTableSlotOps *tts_ops);
extern void ExecResetTupleTable(List *tupleTable, _Bool shouldFree);
extern TupleTableSlot *MakeSingleTupleTableSlot(TupleDesc tupdesc,
            const TupleTableSlotOps *tts_ops);
extern void ExecDropSingleTupleTableSlot(TupleTableSlot *slot);
extern void ExecSetSlotDescriptor(TupleTableSlot *slot, TupleDesc tupdesc);
extern TupleTableSlot *ExecStoreHeapTuple(HeapTuple tuple,
            TupleTableSlot *slot,
            _Bool shouldFree);
extern void ExecForceStoreHeapTuple(HeapTuple tuple,
         TupleTableSlot *slot,
         _Bool shouldFree);
extern TupleTableSlot *ExecStoreBufferHeapTuple(HeapTuple tuple,
            TupleTableSlot *slot,
            Buffer buffer);
extern TupleTableSlot *ExecStorePinnedBufferHeapTuple(HeapTuple tuple,
               TupleTableSlot *slot,
               Buffer buffer);
extern TupleTableSlot *ExecStoreMinimalTuple(MinimalTuple mtup,
            TupleTableSlot *slot,
            _Bool shouldFree);
extern void ExecForceStoreMinimalTuple(MinimalTuple mtup, TupleTableSlot *slot,
            _Bool shouldFree);
extern TupleTableSlot *ExecStoreVirtualTuple(TupleTableSlot *slot);
extern TupleTableSlot *ExecStoreAllNullTuple(TupleTableSlot *slot);
extern void ExecStoreHeapTupleDatum(Datum data, TupleTableSlot *slot);
extern HeapTuple ExecFetchSlotHeapTuple(TupleTableSlot *slot, _Bool materialize, _Bool *shouldFree);
extern MinimalTuple ExecFetchSlotMinimalTuple(TupleTableSlot *slot,
             _Bool *shouldFree);
extern Datum ExecFetchSlotHeapTupleDatum(TupleTableSlot *slot);
extern void slot_getmissingattrs(TupleTableSlot *slot, int startAttNum,
         int lastAttNum);
extern void slot_getsomeattrs_int(TupleTableSlot *slot, int attnum);
# 340 "/products1/postgres/PG12.1/include/server/executor/tuptable.h"
static inline void
slot_getsomeattrs(TupleTableSlot *slot, int attnum)
{
 if (slot->tts_nvalid < attnum)
  slot_getsomeattrs_int(slot, attnum);
}







static inline void
slot_getallattrs(TupleTableSlot *slot)
{
 slot_getsomeattrs(slot, slot->tts_tupleDescriptor->natts);
}
# 366 "/products1/postgres/PG12.1/include/server/executor/tuptable.h"
static inline _Bool
slot_attisnull(TupleTableSlot *slot, int attnum)
{
 ((void)1);

 if (attnum > slot->tts_nvalid)
  slot_getsomeattrs(slot, attnum);

 return slot->tts_isnull[attnum - 1];
}




static inline Datum
slot_getattr(TupleTableSlot *slot, int attnum,
    _Bool *isnull)
{
 ((void)1);

 if (attnum > slot->tts_nvalid)
  slot_getsomeattrs(slot, attnum);

 *isnull = slot->tts_isnull[attnum - 1];

 return slot->tts_values[attnum - 1];
}
# 401 "/products1/postgres/PG12.1/include/server/executor/tuptable.h"
static inline Datum
slot_getsysattr(TupleTableSlot *slot, int attnum, _Bool *isnull)
{
 ((void)1);

 if (attnum == (-6))
 {
  *isnull = 0;
  return ((Datum) (slot->tts_tableOid));
 }
 else if (attnum == (-1))
 {
  *isnull = 0;
  return ((Datum) (&slot->tts_tid));
 }


 return slot->tts_ops->getsysattr(slot, attnum, isnull);
}




static inline TupleTableSlot *
ExecClearTuple(TupleTableSlot *slot)
{
 slot->tts_ops->clear(slot);

 return slot;
}
# 442 "/products1/postgres/PG12.1/include/server/executor/tuptable.h"
static inline void
ExecMaterializeSlot(TupleTableSlot *slot)
{
 slot->tts_ops->materialize(slot);
}




static inline HeapTuple
ExecCopySlotHeapTuple(TupleTableSlot *slot)
{
 ((void)1);

 return slot->tts_ops->copy_heap_tuple(slot);
}




static inline MinimalTuple
ExecCopySlotMinimalTuple(TupleTableSlot *slot)
{
 return slot->tts_ops->copy_minimal_tuple(slot);
}







static inline TupleTableSlot *
ExecCopySlot(TupleTableSlot *dstslot, TupleTableSlot *srcslot)
{
 ((void)1);
 ((void)1);

 dstslot->tts_ops->copyslot(dstslot, srcslot);

 return dstslot;
}
# 71 "/products1/postgres/PG12.1/include/server/tcop/dest.h" 2
# 86 "/products1/postgres/PG12.1/include/server/tcop/dest.h"
typedef enum
{
 DestNone,
 DestDebug,
 DestRemote,
 DestRemoteExecute,
 DestRemoteSimple,
 DestSPI,
 DestTuplestore,
 DestIntoRel,
 DestCopyOut,
 DestSQLFunction,
 DestTransientRel,
 DestTupleQueue
} CommandDest;
# 113 "/products1/postgres/PG12.1/include/server/tcop/dest.h"
typedef struct _DestReceiver DestReceiver;

struct _DestReceiver
{

 _Bool (*receiveSlot) (TupleTableSlot *slot,
        DestReceiver *self);

 void (*rStartup) (DestReceiver *self,
        int operation,
        TupleDesc typeinfo);
 void (*rShutdown) (DestReceiver *self);

 void (*rDestroy) (DestReceiver *self);

 CommandDest mydest;

};

extern DestReceiver *None_Receiver;




extern void BeginCommand(const char *commandTag, CommandDest dest);
extern DestReceiver *CreateDestReceiver(CommandDest dest);
extern void EndCommand(const char *commandTag, CommandDest dest);



extern void NullCommand(CommandDest dest);
extern void ReadyForQuery(CommandDest dest);
# 21 "/products1/postgres/PG12.1/include/server/commands/defrem.h" 2



extern void RemoveObjects(DropStmt *stmt);


extern ObjectAddress DefineIndex(Oid relationId,
         IndexStmt *stmt,
         Oid indexRelationId,
         Oid parentIndexId,
         Oid parentConstraintId,
         _Bool is_alter_table,
         _Bool check_rights,
         _Bool check_not_in_use,
         _Bool skip_build,
         _Bool quiet);
extern void ReindexIndex(RangeVar *indexRelation, int options, _Bool concurrent);
extern Oid ReindexTable(RangeVar *relation, int options, _Bool concurrent);
extern void ReindexMultipleTables(const char *objectName, ReindexObjectType objectKind,
          int options, _Bool concurrent);
extern char *makeObjectName(const char *name1, const char *name2,
       const char *label);
extern char *ChooseRelationName(const char *name1, const char *name2,
        const char *label, Oid namespaceid,
        _Bool isconstraint);
extern _Bool CheckIndexCompatible(Oid oldId,
         const char *accessMethodName,
         List *attributeList,
         List *exclusionOpNames);
extern Oid GetDefaultOpClass(Oid type_id, Oid am_id);
extern Oid ResolveOpClass(List *opclass, Oid attrType,
         const char *accessMethodName, Oid accessMethodId);


extern ObjectAddress CreateFunction(ParseState *pstate, CreateFunctionStmt *stmt);
extern void RemoveFunctionById(Oid funcOid);
extern void SetFunctionReturnType(Oid funcOid, Oid newRetType);
extern void SetFunctionArgType(Oid funcOid, int argIndex, Oid newArgType);
extern ObjectAddress AlterFunction(ParseState *pstate, AlterFunctionStmt *stmt);
extern ObjectAddress CreateCast(CreateCastStmt *stmt);
extern void DropCastById(Oid castOid);
extern ObjectAddress CreateTransform(CreateTransformStmt *stmt);
extern void DropTransformById(Oid transformOid);
extern void IsThereFunctionInNamespace(const char *proname, int pronargs,
            oidvector *proargtypes, Oid nspOid);
extern void ExecuteDoStmt(DoStmt *stmt, _Bool atomic);
extern void ExecuteCallStmt(CallStmt *stmt, ParamListInfo params, _Bool atomic, DestReceiver *dest);
extern TupleDesc CallStmtResultDesc(CallStmt *stmt);
extern Oid get_cast_oid(Oid sourcetypeid, Oid targettypeid, _Bool missing_ok);
extern Oid get_transform_oid(Oid type_id, Oid lang_id, _Bool missing_ok);
extern void interpret_function_parameter_list(ParseState *pstate,
             List *parameters,
             Oid languageOid,
             ObjectType objtype,
             oidvector **parameterTypes,
             ArrayType **allParameterTypes,
             ArrayType **parameterModes,
             ArrayType **parameterNames,
             List **parameterDefaults,
             Oid *variadicArgType,
             Oid *requiredResultType);


extern ObjectAddress DefineOperator(List *names, List *parameters);
extern void RemoveOperatorById(Oid operOid);
extern ObjectAddress AlterOperator(AlterOperatorStmt *stmt);


extern ObjectAddress CreateStatistics(CreateStatsStmt *stmt);
extern void RemoveStatisticsById(Oid statsOid);
extern void UpdateStatisticsForTypeChange(Oid statsOid,
            Oid relationOid, int attnum,
            Oid oldColumnType, Oid newColumnType);


extern ObjectAddress DefineAggregate(ParseState *pstate, List *name, List *args, _Bool oldstyle,
          List *parameters, _Bool replace);


extern ObjectAddress DefineOpClass(CreateOpClassStmt *stmt);
extern ObjectAddress DefineOpFamily(CreateOpFamilyStmt *stmt);
extern Oid AlterOpFamily(AlterOpFamilyStmt *stmt);
extern void RemoveOpClassById(Oid opclassOid);
extern void RemoveOpFamilyById(Oid opfamilyOid);
extern void RemoveAmOpEntryById(Oid entryOid);
extern void RemoveAmProcEntryById(Oid entryOid);
extern void IsThereOpClassInNamespace(const char *opcname, Oid opcmethod,
           Oid opcnamespace);
extern void IsThereOpFamilyInNamespace(const char *opfname, Oid opfmethod,
            Oid opfnamespace);
extern Oid get_opclass_oid(Oid amID, List *opclassname, _Bool missing_ok);
extern Oid get_opfamily_oid(Oid amID, List *opfamilyname, _Bool missing_ok);


extern ObjectAddress DefineTSParser(List *names, List *parameters);
extern void RemoveTSParserById(Oid prsId);

extern ObjectAddress DefineTSDictionary(List *names, List *parameters);
extern void RemoveTSDictionaryById(Oid dictId);
extern ObjectAddress AlterTSDictionary(AlterTSDictionaryStmt *stmt);

extern ObjectAddress DefineTSTemplate(List *names, List *parameters);
extern void RemoveTSTemplateById(Oid tmplId);

extern ObjectAddress DefineTSConfiguration(List *names, List *parameters,
             ObjectAddress *copied);
extern void RemoveTSConfigurationById(Oid cfgId);
extern ObjectAddress AlterTSConfiguration(AlterTSConfigurationStmt *stmt);

extern text *serialize_deflist(List *deflist);
extern List *deserialize_deflist(Datum txt);


extern ObjectAddress AlterForeignServerOwner(const char *name, Oid newOwnerId);
extern void AlterForeignServerOwner_oid(Oid, Oid newOwnerId);
extern ObjectAddress AlterForeignDataWrapperOwner(const char *name, Oid newOwnerId);
extern void AlterForeignDataWrapperOwner_oid(Oid fwdId, Oid newOwnerId);
extern ObjectAddress CreateForeignDataWrapper(CreateFdwStmt *stmt);
extern ObjectAddress AlterForeignDataWrapper(AlterFdwStmt *stmt);
extern void RemoveForeignDataWrapperById(Oid fdwId);
extern ObjectAddress CreateForeignServer(CreateForeignServerStmt *stmt);
extern ObjectAddress AlterForeignServer(AlterForeignServerStmt *stmt);
extern void RemoveForeignServerById(Oid srvId);
extern ObjectAddress CreateUserMapping(CreateUserMappingStmt *stmt);
extern ObjectAddress AlterUserMapping(AlterUserMappingStmt *stmt);
extern Oid RemoveUserMapping(DropUserMappingStmt *stmt);
extern void RemoveUserMappingById(Oid umId);
extern void CreateForeignTable(CreateForeignTableStmt *stmt, Oid relid);
extern void ImportForeignSchema(ImportForeignSchemaStmt *stmt);
extern Datum transformGenericOptions(Oid catalogId,
          Datum oldOptions,
          List *options,
          Oid fdwvalidator);


extern ObjectAddress CreateAccessMethod(CreateAmStmt *stmt);
extern void RemoveAccessMethodById(Oid amOid);
extern Oid get_index_am_oid(const char *amname, _Bool missing_ok);
extern Oid get_table_am_oid(const char *amname, _Bool missing_ok);
extern Oid get_am_oid(const char *amname, _Bool missing_ok);
extern char *get_am_name(Oid amOid);



extern char *defGetString(DefElem *def);
extern double defGetNumeric(DefElem *def);
extern _Bool defGetBoolean(DefElem *def);
extern int32 defGetInt32(DefElem *def);
extern int64 defGetInt64(DefElem *def);
extern List *defGetQualifiedName(DefElem *def);
extern TypeName *defGetTypeName(DefElem *def);
extern int defGetTypeLength(DefElem *def);
extern List *defGetStringList(DefElem *def);
# 28 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/commands/explain.h" 1
# 16 "/products1/postgres/PG12.1/include/server/commands/explain.h"
# 1 "/products1/postgres/PG12.1/include/server/executor/executor.h" 1
# 17 "/products1/postgres/PG12.1/include/server/executor/executor.h"
# 1 "/products1/postgres/PG12.1/include/server/executor/execdesc.h" 1
# 18 "/products1/postgres/PG12.1/include/server/executor/execdesc.h"
# 1 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h" 1
# 17 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
# 1 "/products1/postgres/PG12.1/include/server/access/tupconvert.h" 1
# 22 "/products1/postgres/PG12.1/include/server/access/tupconvert.h"
typedef struct TupleConversionMap
{
 TupleDesc indesc;
 TupleDesc outdesc;
 AttrNumber *attrMap;
 Datum *invalues;
 _Bool *inisnull;
 Datum *outvalues;
 _Bool *outisnull;
} TupleConversionMap;


extern TupleConversionMap *convert_tuples_by_position(TupleDesc indesc,
               TupleDesc outdesc,
               const char *msg);

extern TupleConversionMap *convert_tuples_by_name(TupleDesc indesc,
              TupleDesc outdesc,
              const char *msg);

extern AttrNumber *convert_tuples_by_name_map(TupleDesc indesc,
             TupleDesc outdesc,
             const char *msg);
extern AttrNumber *convert_tuples_by_name_map_if_req(TupleDesc indesc,
              TupleDesc outdesc,
              const char *msg);

extern HeapTuple execute_attr_map_tuple(HeapTuple tuple, TupleConversionMap *map);
extern TupleTableSlot *execute_attr_map_slot(AttrNumber *attrMap,
            TupleTableSlot *in_slot, TupleTableSlot *out_slot);

extern void free_conversion_map(TupleConversionMap *map);
# 18 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h" 2
# 1 "/products1/postgres/PG12.1/include/server/executor/instrument.h" 1
# 16 "/products1/postgres/PG12.1/include/server/executor/instrument.h"
# 1 "/products1/postgres/PG12.1/include/server/portability/instr_time.h" 1
# 64 "/products1/postgres/PG12.1/include/server/portability/instr_time.h"
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 88 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/timex.h" 1 3 4
# 25 "/usr/include/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 89 "/usr/include/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));


# 42 "/usr/include/time.h" 2 3 4
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));






extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) __attribute__ ((__nothrow__ , __leaf__));
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 65 "/products1/postgres/PG12.1/include/server/portability/instr_time.h" 2
# 86 "/products1/postgres/PG12.1/include/server/portability/instr_time.h"
typedef struct timespec instr_time;
# 17 "/products1/postgres/PG12.1/include/server/executor/instrument.h" 2


typedef struct BufferUsage
{
 long shared_blks_hit;
 long shared_blks_read;
 long shared_blks_dirtied;
 long shared_blks_written;
 long local_blks_hit;
 long local_blks_read;
 long local_blks_dirtied;
 long local_blks_written;
 long temp_blks_read;
 long temp_blks_written;
 instr_time blk_read_time;
 instr_time blk_write_time;
} BufferUsage;


typedef enum InstrumentOption
{
 INSTRUMENT_TIMER = 1 << 0,
 INSTRUMENT_BUFFERS = 1 << 1,
 INSTRUMENT_ROWS = 1 << 2,
 INSTRUMENT_ALL = (0x7FFFFFFF)
} InstrumentOption;

typedef struct Instrumentation
{

 _Bool need_timer;
 _Bool need_bufusage;

 _Bool running;
 instr_time starttime;
 instr_time counter;
 double firsttuple;
 double tuplecount;
 BufferUsage bufusage_start;

 double startup;
 double total;
 double ntuples;
 double ntuples2;
 double nloops;
 double nfiltered1;
 double nfiltered2;
 BufferUsage bufusage;
} Instrumentation;

typedef struct WorkerInstrumentation
{
 int num_workers;
 Instrumentation instrument[];
} WorkerInstrumentation;

extern BufferUsage pgBufferUsage;

extern Instrumentation *InstrAlloc(int n, int instrument_options);
extern void InstrInit(Instrumentation *instr, int instrument_options);
extern void InstrStartNode(Instrumentation *instr);
extern void InstrStopNode(Instrumentation *instr, double nTuples);
extern void InstrEndLoop(Instrumentation *instr);
extern void InstrAggNode(Instrumentation *dst, Instrumentation *add);
extern void InstrStartParallelQuery(void);
extern void InstrEndParallelQuery(BufferUsage *result);
extern void InstrAccumParallelQuery(BufferUsage *result);
# 19 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h" 2


# 1 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h" 1
# 42 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct PlannedStmt
{
 NodeTag type;

 CmdType commandType;

 uint64 queryId;

 _Bool hasReturning;

 _Bool hasModifyingCTE;

 _Bool canSetTag;

 _Bool transientPlan;

 _Bool dependsOnRole;

 _Bool parallelModeNeeded;

 int jitFlags;

 struct Plan *planTree;

 List *rtable;


 List *resultRelations;





 List *rootResultRelations;

 List *subplans;


 Bitmapset *rewindPlanIDs;

 List *rowMarks;

 List *relationOids;

 List *invalItems;

 List *paramExecTypes;

 Node *utilityStmt;


 int stmt_location;
 int stmt_len;
} PlannedStmt;
# 114 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct Plan
{
 NodeTag type;




 Cost startup_cost;
 Cost total_cost;




 double plan_rows;
 int plan_width;




 _Bool parallel_aware;
 _Bool parallel_safe;




 int plan_node_id;
 List *targetlist;
 List *qual;
 struct Plan *lefttree;
 struct Plan *righttree;
 List *initPlan;
# 158 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
 Bitmapset *extParam;
 Bitmapset *allParam;
} Plan;
# 184 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct Result
{
 Plan plan;
 Node *resconstantqual;
} Result;







typedef struct ProjectSet
{
 Plan plan;
} ProjectSet;
# 216 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct ModifyTable
{
 Plan plan;
 CmdType operation;
 _Bool canSetTag;
 Index nominalRelation;
 Index rootRelation;
 _Bool partColsUpdated;
 List *resultRelations;
 int resultRelIndex;
 int rootResultRelIndex;
 List *plans;
 List *withCheckOptionLists;
 List *returningLists;
 List *fdwPrivLists;
 Bitmapset *fdwDirectModifyPlans;
 List *rowMarks;
 int epqParam;
 OnConflictAction onConflictAction;
 List *arbiterIndexes;
 List *onConflictSet;
 Node *onConflictWhere;
 Index exclRelRTI;
 List *exclRelTlist;
} ModifyTable;

struct PartitionPruneInfo;






typedef struct Append
{
 Plan plan;
 List *appendplans;





 int first_partial_plan;


 struct PartitionPruneInfo *part_prune_info;
} Append;






typedef struct MergeAppend
{
 Plan plan;
 List *mergeplans;

 int numCols;
 AttrNumber *sortColIdx;
 Oid *sortOperators;
 Oid *collations;
 _Bool *nullsFirst;

 struct PartitionPruneInfo *part_prune_info;
} MergeAppend;
# 291 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct RecursiveUnion
{
 Plan plan;
 int wtParam;

 int numCols;

 AttrNumber *dupColIdx;
 Oid *dupOperators;
 Oid *dupCollations;
 long numGroups;
} RecursiveUnion;
# 312 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct BitmapAnd
{
 Plan plan;
 List *bitmapplans;
} BitmapAnd;
# 326 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct BitmapOr
{
 Plan plan;
 _Bool isshared;
 List *bitmapplans;
} BitmapOr;






typedef struct Scan
{
 Plan plan;
 Index scanrelid;
} Scan;





typedef Scan SeqScan;





typedef struct SampleScan
{
 Scan scan;

 struct TableSampleClause *tablesample;
} SampleScan;
# 398 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct IndexScan
{
 Scan scan;
 Oid indexid;
 List *indexqual;
 List *indexqualorig;
 List *indexorderby;
 List *indexorderbyorig;
 List *indexorderbyops;
 ScanDirection indexorderdir;
} IndexScan;
# 427 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct IndexOnlyScan
{
 Scan scan;
 Oid indexid;
 List *indexqual;
 List *indexorderby;
 List *indextlist;
 ScanDirection indexorderdir;
} IndexOnlyScan;
# 454 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct BitmapIndexScan
{
 Scan scan;
 Oid indexid;
 _Bool isshared;
 List *indexqual;
 List *indexqualorig;
} BitmapIndexScan;
# 472 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct BitmapHeapScan
{
 Scan scan;
 List *bitmapqualorig;
} BitmapHeapScan;
# 486 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct TidScan
{
 Scan scan;
 List *tidquals;
} TidScan;
# 508 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct SubqueryScan
{
 Scan scan;
 Plan *subplan;
} SubqueryScan;





typedef struct FunctionScan
{
 Scan scan;
 List *functions;
 _Bool funcordinality;
} FunctionScan;





typedef struct ValuesScan
{
 Scan scan;
 List *values_lists;
} ValuesScan;





typedef struct TableFuncScan
{
 Scan scan;
 TableFunc *tablefunc;
} TableFuncScan;





typedef struct CteScan
{
 Scan scan;
 int ctePlanId;
 int cteParam;
} CteScan;





typedef struct NamedTuplestoreScan
{
 Scan scan;
 char *enrname;
} NamedTuplestoreScan;





typedef struct WorkTableScan
{
 Scan scan;
 int wtParam;
} WorkTableScan;
# 608 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct ForeignScan
{
 Scan scan;
 CmdType operation;
 Oid fs_server;
 List *fdw_exprs;
 List *fdw_private;
 List *fdw_scan_tlist;
 List *fdw_recheck_quals;
 Bitmapset *fs_relids;
 _Bool fsSystemCol;
} ForeignScan;
# 634 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
struct CustomScanMethods;

typedef struct CustomScan
{
 Scan scan;
 uint32 flags;

 List *custom_plans;
 List *custom_exprs;
 List *custom_private;
 List *custom_scan_tlist;
 Bitmapset *custom_relids;
 const struct CustomScanMethods *methods;
} CustomScan;
# 677 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct Join
{
 Plan plan;
 JoinType jointype;
 _Bool inner_unique;
 List *joinqual;
} Join;
# 696 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct NestLoop
{
 Join join;
 List *nestParams;
} NestLoop;

typedef struct NestLoopParam
{
 NodeTag type;
 int paramno;
 Var *paramval;
} NestLoopParam;
# 720 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct MergeJoin
{
 Join join;
 _Bool skip_mark_restore;
 List *mergeclauses;

 Oid *mergeFamilies;
 Oid *mergeCollations;
 int *mergeStrategies;
 _Bool *mergeNullsFirst;
} MergeJoin;





typedef struct HashJoin
{
 Join join;
 List *hashclauses;
 List *hashoperators;
 List *hashcollations;





 List *hashkeys;
} HashJoin;





typedef struct Material
{
 Plan plan;
} Material;





typedef struct Sort
{
 Plan plan;
 int numCols;
 AttrNumber *sortColIdx;
 Oid *sortOperators;
 Oid *collations;
 _Bool *nullsFirst;
} Sort;







typedef struct Group
{
 Plan plan;
 int numCols;
 AttrNumber *grpColIdx;
 Oid *grpOperators;
 Oid *grpCollations;
} Group;
# 802 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct Agg
{
 Plan plan;
 AggStrategy aggstrategy;
 AggSplit aggsplit;
 int numCols;
 AttrNumber *grpColIdx;
 Oid *grpOperators;
 Oid *grpCollations;
 long numGroups;
 Bitmapset *aggParams;

 List *groupingSets;
 List *chain;
} Agg;





typedef struct WindowAgg
{
 Plan plan;
 Index winref;
 int partNumCols;
 AttrNumber *partColIdx;
 Oid *partOperators;
 Oid *partCollations;
 int ordNumCols;
 AttrNumber *ordColIdx;
 Oid *ordOperators;
 Oid *ordCollations;
 int frameOptions;
 Node *startOffset;
 Node *endOffset;

 Oid startInRangeFunc;
 Oid endInRangeFunc;
 Oid inRangeColl;
 _Bool inRangeAsc;
 _Bool inRangeNullsFirst;
} WindowAgg;





typedef struct Unique
{
 Plan plan;
 int numCols;
 AttrNumber *uniqColIdx;
 Oid *uniqOperators;
 Oid *uniqCollations;
} Unique;
# 869 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct Gather
{
 Plan plan;
 int num_workers;
 int rescan_param;
 _Bool single_copy;
 _Bool invisible;
 Bitmapset *initParam;

} Gather;





typedef struct GatherMerge
{
 Plan plan;
 int num_workers;
 int rescan_param;

 int numCols;
 AttrNumber *sortColIdx;
 Oid *sortOperators;
 Oid *collations;
 _Bool *nullsFirst;
 Bitmapset *initParam;

} GatherMerge;
# 907 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct Hash
{
 Plan plan;





 List *hashkeys;
 Oid skewTable;
 AttrNumber skewColumn;
 _Bool skewInherit;

 double rows_total;
} Hash;





typedef struct SetOp
{
 Plan plan;
 SetOpCmd cmd;
 SetOpStrategy strategy;
 int numCols;

 AttrNumber *dupColIdx;
 Oid *dupOperators;
 Oid *dupCollations;
 AttrNumber flagColIdx;
 int firstFlag;
 long numGroups;
} SetOp;
# 951 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct LockRows
{
 Plan plan;
 List *rowMarks;
 int epqParam;
} LockRows;
# 965 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct Limit
{
 Plan plan;
 Node *limitOffset;
 Node *limitCount;
} Limit;
# 1003 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef enum RowMarkType
{
 ROW_MARK_EXCLUSIVE,
 ROW_MARK_NOKEYEXCLUSIVE,
 ROW_MARK_SHARE,
 ROW_MARK_KEYSHARE,
 ROW_MARK_REFERENCE,
 ROW_MARK_COPY
} RowMarkType;
# 1054 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct PlanRowMark
{
 NodeTag type;
 Index rti;
 Index prti;
 Index rowmarkId;
 RowMarkType markType;
 int allMarkTypes;
 LockClauseStrength strength;
 LockWaitPolicy waitPolicy;
 _Bool isParent;
} PlanRowMark;
# 1098 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct PartitionPruneInfo
{
 NodeTag type;
 List *prune_infos;
 Bitmapset *other_subplans;
} PartitionPruneInfo;
# 1122 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct PartitionedRelPruneInfo
{
 NodeTag type;
 Index rtindex;
 Bitmapset *present_parts;

 int nparts;
 int *subplan_map;
 int *subpart_map;
 Oid *relid_map;







 List *initial_pruning_steps;
 List *exec_pruning_steps;
 Bitmapset *execparamids;

} PartitionedRelPruneInfo;







typedef struct PartitionPruneStep
{
 NodeTag type;
 int step_id;
} PartitionPruneStep;
# 1184 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct PartitionPruneStepOp
{
 PartitionPruneStep step;

 StrategyNumber opstrategy;
 List *exprs;
 List *cmpfns;
 Bitmapset *nullkeys;
} PartitionPruneStepOp;







typedef enum PartitionPruneCombineOp
{
 PARTPRUNE_COMBINE_UNION,
 PARTPRUNE_COMBINE_INTERSECT
} PartitionPruneCombineOp;

typedef struct PartitionPruneStepCombine
{
 PartitionPruneStep step;

 PartitionPruneCombineOp combineOp;
 List *source_stepids;
} PartitionPruneStepCombine;
# 1224 "/products1/postgres/PG12.1/include/server/nodes/plannodes.h"
typedef struct PlanInvalItem
{
 NodeTag type;
 int cacheId;
 uint32 hashValue;
} PlanInvalItem;
# 22 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h" 2



# 1 "/products1/postgres/PG12.1/include/server/utils/reltrigger.h" 1
# 23 "/products1/postgres/PG12.1/include/server/utils/reltrigger.h"
typedef struct Trigger
{
 Oid tgoid;

 char *tgname;
 Oid tgfoid;
 int16 tgtype;
 char tgenabled;
 _Bool tgisinternal;
 Oid tgconstrrelid;
 Oid tgconstrindid;
 Oid tgconstraint;
 _Bool tgdeferrable;
 _Bool tginitdeferred;
 int16 tgnargs;
 int16 tgnattr;
 int16 *tgattr;
 char **tgargs;
 char *tgqual;
 char *tgoldtable;
 char *tgnewtable;
} Trigger;

typedef struct TriggerDesc
{
 Trigger *triggers;
 int numtriggers;





 _Bool trig_insert_before_row;
 _Bool trig_insert_after_row;
 _Bool trig_insert_instead_row;
 _Bool trig_insert_before_statement;
 _Bool trig_insert_after_statement;
 _Bool trig_update_before_row;
 _Bool trig_update_after_row;
 _Bool trig_update_instead_row;
 _Bool trig_update_before_statement;
 _Bool trig_update_after_statement;
 _Bool trig_delete_before_row;
 _Bool trig_delete_after_row;
 _Bool trig_delete_instead_row;
 _Bool trig_delete_before_statement;
 _Bool trig_delete_after_statement;

 _Bool trig_truncate_before_statement;
 _Bool trig_truncate_after_statement;

 _Bool trig_insert_new_table;
 _Bool trig_update_old_table;
 _Bool trig_update_new_table;
 _Bool trig_delete_old_table;
} TriggerDesc;
# 26 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/sharedtuplestore.h" 1
# 17 "/products1/postgres/PG12.1/include/server/utils/sharedtuplestore.h"
# 1 "/products1/postgres/PG12.1/include/server/storage/fd.h" 1
# 42 "/products1/postgres/PG12.1/include/server/storage/fd.h"
# 1 "/usr/include/dirent.h" 1 3 4
# 28 "/usr/include/dirent.h" 3 4

# 62 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/bits/dirent.h" 1 3 4
# 22 "/usr/include/bits/dirent.h" 3 4
struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };


struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };
# 63 "/usr/include/dirent.h" 2 3 4
# 98 "/usr/include/dirent.h" 3 4
enum
  {
    DT_UNKNOWN = 0,

    DT_FIFO = 1,

    DT_CHR = 2,

    DT_DIR = 4,

    DT_BLK = 6,

    DT_REG = 8,

    DT_LNK = 10,

    DT_SOCK = 12,

    DT_WHT = 14

  };
# 128 "/usr/include/dirent.h" 3 4
typedef struct __dirstream DIR;






extern DIR *opendir (const char *__name) __attribute__ ((__nonnull__ (1)));






extern DIR *fdopendir (int __fd);







extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 163 "/usr/include/dirent.h" 3 4
extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 174 "/usr/include/dirent.h" 3 4
extern struct dirent64 *readdir64 (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 184 "/usr/include/dirent.h" 3 4
extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 201 "/usr/include/dirent.h" 3 4
extern int readdir64_r (DIR *__restrict __dirp,
   struct dirent64 *__restrict __entry,
   struct dirent64 **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 245 "/usr/include/dirent.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h" 1 3 4
# 246 "/usr/include/dirent.h" 2 3 4
# 255 "/usr/include/dirent.h" 3 4
extern int scandir (const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (const struct dirent *),
      int (*__cmp) (const struct dirent **,
      const struct dirent **))
     __attribute__ ((__nonnull__ (1, 2)));
# 278 "/usr/include/dirent.h" 3 4
extern int scandir64 (const char *__restrict __dir,
        struct dirent64 ***__restrict __namelist,
        int (*__selector) (const struct dirent64 *),
        int (*__cmp) (const struct dirent64 **,
        const struct dirent64 **))
     __attribute__ ((__nonnull__ (1, 2)));
# 293 "/usr/include/dirent.h" 3 4
extern int scandirat (int __dfd, const char *__restrict __dir,
        struct dirent ***__restrict __namelist,
        int (*__selector) (const struct dirent *),
        int (*__cmp) (const struct dirent **,
        const struct dirent **))
     __attribute__ ((__nonnull__ (2, 3)));
# 315 "/usr/include/dirent.h" 3 4
extern int scandirat64 (int __dfd, const char *__restrict __dir,
   struct dirent64 ***__restrict __namelist,
   int (*__selector) (const struct dirent64 *),
   int (*__cmp) (const struct dirent64 **,
          const struct dirent64 **))
     __attribute__ ((__nonnull__ (2, 3)));




extern int alphasort (const struct dirent **__e1,
        const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/dirent.h" 3 4
extern int alphasort64 (const struct dirent64 **__e1,
   const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 353 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
    size_t __nbytes,
    __off_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));
# 370 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,
      size_t __nbytes,
      __off64_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));






extern int versionsort (const struct dirent **__e1,
   const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 396 "/usr/include/dirent.h" 3 4
extern int versionsort64 (const struct dirent64 **__e1,
     const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




# 43 "/products1/postgres/PG12.1/include/server/storage/fd.h" 2


typedef int File;



extern int max_files_per_process;
extern _Bool data_sync_retry;




extern int max_safe_fds;
# 75 "/products1/postgres/PG12.1/include/server/storage/fd.h"
extern File PathNameOpenFile(const char *fileName, int fileFlags);
extern File PathNameOpenFilePerm(const char *fileName, int fileFlags, mode_t fileMode);
extern File OpenTemporaryFile(_Bool interXact);
extern void FileClose(File file);
extern int FilePrefetch(File file, off_t offset, int amount, uint32 wait_event_info);
extern int FileRead(File file, char *buffer, int amount, off_t offset, uint32 wait_event_info);
extern int FileWrite(File file, char *buffer, int amount, off_t offset, uint32 wait_event_info);
extern int FileSync(File file, uint32 wait_event_info);
extern off_t FileSize(File file);
extern int FileTruncate(File file, off_t offset, uint32 wait_event_info);
extern void FileWriteback(File file, off_t offset, off_t nbytes, uint32 wait_event_info);
extern char *FilePathName(File file);
extern int FileGetRawDesc(File file);
extern int FileGetRawFlags(File file);
extern mode_t FileGetRawMode(File file);


extern File PathNameCreateTemporaryFile(const char *name, _Bool error_on_failure);
extern File PathNameOpenTemporaryFile(const char *name);
extern _Bool PathNameDeleteTemporaryFile(const char *name, _Bool error_on_failure);
extern void PathNameCreateTemporaryDir(const char *base, const char *name);
extern void PathNameDeleteTemporaryDir(const char *name);
extern void TempTablespacePath(char *path, Oid tablespace);


extern FILE *AllocateFile(const char *name, const char *mode);
extern int FreeFile(FILE *file);


extern FILE *OpenPipeStream(const char *command, const char *mode);
extern int ClosePipeStream(FILE *file);


extern DIR *AllocateDir(const char *dirname);
extern struct dirent *ReadDir(DIR *dir, const char *dirname);
extern struct dirent *ReadDirExtended(DIR *dir, const char *dirname,
           int elevel);
extern int FreeDir(DIR *dir);


extern int OpenTransientFile(const char *fileName, int fileFlags);
extern int OpenTransientFilePerm(const char *fileName, int fileFlags, mode_t fileMode);
extern int CloseTransientFile(int fd);


extern int BasicOpenFile(const char *fileName, int fileFlags);
extern int BasicOpenFilePerm(const char *fileName, int fileFlags, mode_t fileMode);


extern int MakePGDirectory(const char *directoryName);


extern void InitFileAccess(void);
extern void set_max_safe_fds(void);
extern void closeAllVfds(void);
extern void SetTempTablespaces(Oid *tableSpaces, int numSpaces);
extern _Bool TempTablespacesAreSet(void);
extern int GetTempTablespaces(Oid *tableSpaces, int numSpaces);
extern Oid GetNextTempTableSpace(void);
extern void AtEOXact_Files(_Bool isCommit);
extern void AtEOSubXact_Files(_Bool isCommit, SubTransactionId mySubid,
         SubTransactionId parentSubid);
extern void RemovePgTempFiles(void);
extern _Bool looks_like_temp_rel_name(const char *name);

extern int pg_fsync(int fd);
extern int pg_fsync_no_writethrough(int fd);
extern int pg_fsync_writethrough(int fd);
extern int pg_fdatasync(int fd);
extern void pg_flush_data(int fd, off_t offset, off_t amount);
extern void fsync_fname(const char *fname, _Bool isdir);
extern int durable_rename(const char *oldfile, const char *newfile, int loglevel);
extern int durable_unlink(const char *fname, int loglevel);
extern int durable_link_or_rename(const char *oldfile, const char *newfile, int loglevel);
extern void SyncDataDirectory(void);
extern int data_sync_elevel(int elevel);
# 18 "/products1/postgres/PG12.1/include/server/utils/sharedtuplestore.h" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/sharedfileset.h" 1
# 20 "/products1/postgres/PG12.1/include/server/storage/sharedfileset.h"
# 1 "/products1/postgres/PG12.1/include/server/storage/spin.h" 1
# 69 "/products1/postgres/PG12.1/include/server/storage/spin.h"
extern int SpinlockSemas(void);
extern Size SpinlockSemaSize(void);
# 21 "/products1/postgres/PG12.1/include/server/storage/sharedfileset.h" 2




typedef struct SharedFileSet
{
 pid_t creator_pid;
 uint32 number;
 slock_t mutex;
 int refcnt;
 int ntablespaces;
 Oid tablespaces[8];


} SharedFileSet;

extern void SharedFileSetInit(SharedFileSet *fileset, dsm_segment *seg);
extern void SharedFileSetAttach(SharedFileSet *fileset, dsm_segment *seg);
extern File SharedFileSetCreate(SharedFileSet *fileset, const char *name);
extern File SharedFileSetOpen(SharedFileSet *fileset, const char *name);
extern _Bool SharedFileSetDelete(SharedFileSet *fileset, const char *name,
        _Bool error_on_failure);
extern void SharedFileSetDeleteAll(SharedFileSet *fileset);
# 19 "/products1/postgres/PG12.1/include/server/utils/sharedtuplestore.h" 2

struct SharedTuplestore;
typedef struct SharedTuplestore SharedTuplestore;

struct SharedTuplestoreAccessor;
typedef struct SharedTuplestoreAccessor SharedTuplestoreAccessor;







extern size_t sts_estimate(int participants);

extern SharedTuplestoreAccessor *sts_initialize(SharedTuplestore *sts,
            int participants,
            int my_participant_number,
            size_t meta_data_size,
            int flags,
            SharedFileSet *fileset,
            const char *name);

extern SharedTuplestoreAccessor *sts_attach(SharedTuplestore *sts,
           int my_participant_number,
           SharedFileSet *fileset);

extern void sts_end_write(SharedTuplestoreAccessor *accessor);

extern void sts_reinitialize(SharedTuplestoreAccessor *accessor);

extern void sts_begin_parallel_scan(SharedTuplestoreAccessor *accessor);

extern void sts_end_parallel_scan(SharedTuplestoreAccessor *accessor);

extern void sts_puttuple(SharedTuplestoreAccessor *accessor,
       void *meta_data,
       MinimalTuple tuple);

extern MinimalTuple sts_parallel_scan_next(SharedTuplestoreAccessor *accessor,
             void *meta_data);
# 27 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h" 2

# 1 "/products1/postgres/PG12.1/include/server/utils/sortsupport.h" 1
# 58 "/products1/postgres/PG12.1/include/server/utils/sortsupport.h"
typedef struct SortSupportData *SortSupport;

typedef struct SortSupportData
{




 MemoryContext ssup_cxt;
 Oid ssup_collation;






 _Bool ssup_reverse;
 _Bool ssup_nulls_first;





 AttrNumber ssup_attno;





 void *ssup_extra;
# 106 "/products1/postgres/PG12.1/include/server/utils/sortsupport.h"
 int (*comparator) (Datum x, Datum y, SortSupport ssup);
# 155 "/products1/postgres/PG12.1/include/server/utils/sortsupport.h"
 _Bool abbreviate;
# 172 "/products1/postgres/PG12.1/include/server/utils/sortsupport.h"
 Datum (*abbrev_converter) (Datum original, SortSupport ssup);
# 182 "/products1/postgres/PG12.1/include/server/utils/sortsupport.h"
 _Bool (*abbrev_abort) (int memtupcount, SortSupport ssup);
# 191 "/products1/postgres/PG12.1/include/server/utils/sortsupport.h"
 int (*abbrev_full_comparator) (Datum x, Datum y, SortSupport ssup);
} SortSupportData;






static inline int
ApplySortComparator(Datum datum1, _Bool isNull1,
     Datum datum2, _Bool isNull2,
     SortSupport ssup)
{
 int compare;

 if (isNull1)
 {
  if (isNull2)
   compare = 0;
  else if (ssup->ssup_nulls_first)
   compare = -1;
  else
   compare = 1;
 }
 else if (isNull2)
 {
  if (ssup->ssup_nulls_first)
   compare = 1;
  else
   compare = -1;
 }
 else
 {
  compare = ssup->comparator(datum1, datum2, ssup);
  if (ssup->ssup_reverse)
   ((compare) = ((compare) < 0) ? 1 : -(compare));
 }

 return compare;
}






static inline int
ApplySortAbbrevFullComparator(Datum datum1, _Bool isNull1,
         Datum datum2, _Bool isNull2,
         SortSupport ssup)
{
 int compare;

 if (isNull1)
 {
  if (isNull2)
   compare = 0;
  else if (ssup->ssup_nulls_first)
   compare = -1;
  else
   compare = 1;
 }
 else if (isNull2)
 {
  if (ssup->ssup_nulls_first)
   compare = 1;
  else
   compare = -1;
 }
 else
 {
  compare = ssup->abbrev_full_comparator(datum1, datum2, ssup);
  if (ssup->ssup_reverse)
   ((compare) = ((compare) < 0) ? 1 : -(compare));
 }

 return compare;
}


extern void PrepareSortSupportComparisonShim(Oid cmpFunc, SortSupport ssup);
extern void PrepareSortSupportFromOrderingOp(Oid orderingOp, SortSupport ssup);
extern void PrepareSortSupportFromIndexRel(Relation indexRel, int16 strategy,
             SortSupport ssup);
# 29 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/tuplestore.h" 1
# 40 "/products1/postgres/PG12.1/include/server/utils/tuplestore.h"
typedef struct Tuplestorestate Tuplestorestate;






extern Tuplestorestate *tuplestore_begin_heap(_Bool randomAccess,
             _Bool interXact,
             int maxKBytes);

extern void tuplestore_set_eflags(Tuplestorestate *state, int eflags);

extern void tuplestore_puttupleslot(Tuplestorestate *state,
         TupleTableSlot *slot);
extern void tuplestore_puttuple(Tuplestorestate *state, HeapTuple tuple);
extern void tuplestore_putvalues(Tuplestorestate *state, TupleDesc tdesc,
         Datum *values, _Bool *isnull);




extern int tuplestore_alloc_read_pointer(Tuplestorestate *state, int eflags);

extern void tuplestore_select_read_pointer(Tuplestorestate *state, int ptr);

extern void tuplestore_copy_read_pointer(Tuplestorestate *state,
           int srcptr, int destptr);

extern void tuplestore_trim(Tuplestorestate *state);

extern _Bool tuplestore_in_memory(Tuplestorestate *state);

extern _Bool tuplestore_gettupleslot(Tuplestorestate *state, _Bool forward,
         _Bool copy, TupleTableSlot *slot);

extern _Bool tuplestore_advance(Tuplestorestate *state, _Bool forward);

extern _Bool tuplestore_skiptuples(Tuplestorestate *state,
          int64 ntuples, _Bool forward);

extern int64 tuplestore_tuple_count(Tuplestorestate *state);

extern _Bool tuplestore_ateof(Tuplestorestate *state);

extern void tuplestore_rescan(Tuplestorestate *state);

extern void tuplestore_clear(Tuplestorestate *state);

extern void tuplestore_end(Tuplestorestate *state);
# 30 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/tuplesort.h" 1
# 24 "/products1/postgres/PG12.1/include/server/utils/tuplesort.h"
# 1 "/products1/postgres/PG12.1/include/server/access/itup.h" 1
# 35 "/products1/postgres/PG12.1/include/server/access/itup.h"
typedef struct IndexTupleData
{
 ItemPointerData t_tid;
# 49 "/products1/postgres/PG12.1/include/server/access/itup.h"
 unsigned short t_info;

} IndexTupleData;

typedef IndexTupleData *IndexTuple;

typedef struct IndexAttributeBitMapData
{
 bits8 bits[(32 + 8 - 1) / 8];
} IndexAttributeBitMapData;

typedef IndexAttributeBitMapData * IndexAttributeBitMap;
# 151 "/products1/postgres/PG12.1/include/server/access/itup.h"
extern IndexTuple index_form_tuple(TupleDesc tupleDescriptor,
           Datum *values, _Bool *isnull);
extern Datum nocache_index_getattr(IndexTuple tup, int attnum,
           TupleDesc tupleDesc);
extern void index_deform_tuple(IndexTuple tup, TupleDesc tupleDescriptor,
          Datum *values, _Bool *isnull);
extern IndexTuple CopyIndexTuple(IndexTuple source);
extern IndexTuple index_truncate_tuple(TupleDesc sourceDescriptor,
            IndexTuple source, int leavenatts);
# 25 "/products1/postgres/PG12.1/include/server/utils/tuplesort.h" 2
# 35 "/products1/postgres/PG12.1/include/server/utils/tuplesort.h"
typedef struct Tuplesortstate Tuplesortstate;
typedef struct Sharedsort Sharedsort;






typedef struct SortCoordinateData
{

 _Bool isWorker;






 int nParticipants;


 Sharedsort *sharedsort;
} SortCoordinateData;

typedef struct SortCoordinateData *SortCoordinate;






typedef enum
{
 SORT_TYPE_STILL_IN_PROGRESS = 0,
 SORT_TYPE_TOP_N_HEAPSORT,
 SORT_TYPE_QUICKSORT,
 SORT_TYPE_EXTERNAL_SORT,
 SORT_TYPE_EXTERNAL_MERGE
} TuplesortMethod;

typedef enum
{
 SORT_SPACE_TYPE_DISK,
 SORT_SPACE_TYPE_MEMORY
} TuplesortSpaceType;

typedef struct TuplesortInstrumentation
{
 TuplesortMethod sortMethod;
 TuplesortSpaceType spaceType;
 long spaceUsed;
} TuplesortInstrumentation;
# 191 "/products1/postgres/PG12.1/include/server/utils/tuplesort.h"
extern Tuplesortstate *tuplesort_begin_heap(TupleDesc tupDesc,
           int nkeys, AttrNumber *attNums,
           Oid *sortOperators, Oid *sortCollations,
           _Bool *nullsFirstFlags,
           int workMem, SortCoordinate coordinate,
           _Bool randomAccess);
extern Tuplesortstate *tuplesort_begin_cluster(TupleDesc tupDesc,
              Relation indexRel, int workMem,
              SortCoordinate coordinate, _Bool randomAccess);
extern Tuplesortstate *tuplesort_begin_index_btree(Relation heapRel,
               Relation indexRel,
               _Bool enforceUnique,
               int workMem, SortCoordinate coordinate,
               _Bool randomAccess);
extern Tuplesortstate *tuplesort_begin_index_hash(Relation heapRel,
              Relation indexRel,
              uint32 high_mask,
              uint32 low_mask,
              uint32 max_buckets,
              int workMem, SortCoordinate coordinate,
              _Bool randomAccess);
extern Tuplesortstate *tuplesort_begin_datum(Oid datumType,
            Oid sortOperator, Oid sortCollation,
            _Bool nullsFirstFlag,
            int workMem, SortCoordinate coordinate,
            _Bool randomAccess);

extern void tuplesort_set_bound(Tuplesortstate *state, int64 bound);

extern void tuplesort_puttupleslot(Tuplesortstate *state,
           TupleTableSlot *slot);
extern void tuplesort_putheaptuple(Tuplesortstate *state, HeapTuple tup);
extern void tuplesort_putindextuplevalues(Tuplesortstate *state,
            Relation rel, ItemPointer self,
            Datum *values, _Bool *isnull);
extern void tuplesort_putdatum(Tuplesortstate *state, Datum val,
          _Bool isNull);

extern void tuplesort_performsort(Tuplesortstate *state);

extern _Bool tuplesort_gettupleslot(Tuplesortstate *state, _Bool forward,
           _Bool copy, TupleTableSlot *slot, Datum *abbrev);
extern HeapTuple tuplesort_getheaptuple(Tuplesortstate *state, _Bool forward);
extern IndexTuple tuplesort_getindextuple(Tuplesortstate *state, _Bool forward);
extern _Bool tuplesort_getdatum(Tuplesortstate *state, _Bool forward,
          Datum *val, _Bool *isNull, Datum *abbrev);

extern _Bool tuplesort_skiptuples(Tuplesortstate *state, int64 ntuples,
         _Bool forward);

extern void tuplesort_end(Tuplesortstate *state);

extern void tuplesort_get_stats(Tuplesortstate *state,
        TuplesortInstrumentation *stats);
extern const char *tuplesort_method_name(TuplesortMethod m);
extern const char *tuplesort_space_type_name(TuplesortSpaceType t);

extern int tuplesort_merge_order(int64 allowedMem);

extern Size tuplesort_estimate_shared(int nworkers);
extern void tuplesort_initialize_shared(Sharedsort *shared, int nWorkers,
          dsm_segment *seg);
extern void tuplesort_attach_shared(Sharedsort *shared, dsm_segment *seg);
# 262 "/products1/postgres/PG12.1/include/server/utils/tuplesort.h"
extern void tuplesort_rescan(Tuplesortstate *state);
extern void tuplesort_markpos(Tuplesortstate *state);
extern void tuplesort_restorepos(Tuplesortstate *state);
# 31 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h" 2

# 1 "/products1/postgres/PG12.1/include/server/storage/condition_variable.h" 1
# 28 "/products1/postgres/PG12.1/include/server/storage/condition_variable.h"
typedef struct
{
 slock_t mutex;
 proclist_head wakeup;
} ConditionVariable;


extern void ConditionVariableInit(ConditionVariable *cv);
# 45 "/products1/postgres/PG12.1/include/server/storage/condition_variable.h"
extern void ConditionVariableSleep(ConditionVariable *cv, uint32 wait_event_info);
extern void ConditionVariableCancelSleep(void);







extern void ConditionVariablePrepareToSleep(ConditionVariable *cv);


extern void ConditionVariableSignal(ConditionVariable *cv);
extern void ConditionVariableBroadcast(ConditionVariable *cv);
# 33 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h" 2


struct PlanState;
struct PartitionRoutingInfo;
struct ParallelHashJoinState;
struct ExecRowMark;
struct ExprState;
struct ExprContext;
struct RangeTblEntry;
struct ExprEvalStep;
struct CopyMultiInsertBuffer;
# 53 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef Datum (*ExprStateEvalFunc) (struct ExprState *expression,
         struct ExprContext *econtext,
         _Bool *isNull);





typedef struct ExprState
{
 Node tag;

 uint8 flags;






 _Bool resnull;

 Datum resvalue;





 TupleTableSlot *resultslot;




 struct ExprEvalStep *steps;





 ExprStateEvalFunc evalfunc;


 Expr *expr;


 void *evalfunc_private;






 int steps_len;
 int steps_alloc;

 struct PlanState *parent;
 ParamListInfo ext_params;

 Datum *innermost_caseval;
 _Bool *innermost_casenull;

 Datum *innermost_domainval;
 _Bool *innermost_domainnull;
} ExprState;
# 153 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct IndexInfo
{
 NodeTag type;
 int ii_NumIndexAttrs;
 int ii_NumIndexKeyAttrs;
 AttrNumber ii_IndexAttrNumbers[32];
 List *ii_Expressions;
 List *ii_ExpressionsState;
 List *ii_Predicate;
 ExprState *ii_PredicateState;
 Oid *ii_ExclusionOps;
 Oid *ii_ExclusionProcs;
 uint16 *ii_ExclusionStrats;
 Oid *ii_UniqueOps;
 Oid *ii_UniqueProcs;
 uint16 *ii_UniqueStrats;
 _Bool ii_Unique;
 _Bool ii_ReadyForInserts;
 _Bool ii_Concurrent;
 _Bool ii_BrokenHotChain;
 int ii_ParallelWorkers;
 Oid ii_Am;
 void *ii_AmCache;
 MemoryContext ii_Context;
} IndexInfo;







typedef void (*ExprContextCallbackFunction) (Datum arg);

typedef struct ExprContext_CB
{
 struct ExprContext_CB *next;
 ExprContextCallbackFunction function;
 Datum arg;
} ExprContext_CB;
# 217 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct ExprContext
{
 NodeTag type;



 TupleTableSlot *ecxt_scantuple;

 TupleTableSlot *ecxt_innertuple;

 TupleTableSlot *ecxt_outertuple;


 MemoryContext ecxt_per_query_memory;
 MemoryContext ecxt_per_tuple_memory;


 ParamExecData *ecxt_param_exec_vals;
 ParamListInfo ecxt_param_list_info;






 Datum *ecxt_aggvalues;

 _Bool *ecxt_aggnulls;



 Datum caseValue_datum;

 _Bool caseValue_isNull;



 Datum domainValue_datum;

 _Bool domainValue_isNull;


 struct EState *ecxt_estate;


 ExprContext_CB *ecxt_callbacks;
} ExprContext;





typedef enum
{
 ExprSingleResult,
 ExprMultipleResult,
 ExprEndResult
} ExprDoneCond;







typedef enum
{
 SFRM_ValuePerCall = 0x01,
 SFRM_Materialize = 0x02,
 SFRM_Materialize_Random = 0x04,
 SFRM_Materialize_Preferred = 0x08
} SetFunctionReturnMode;







typedef struct ReturnSetInfo
{
 NodeTag type;

 ExprContext *econtext;
 TupleDesc expectedDesc;
 int allowedModes;

 SetFunctionReturnMode returnMode;
 ExprDoneCond isDone;

 Tuplestorestate *setResult;
 TupleDesc setDesc;
} ReturnSetInfo;
# 326 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct ProjectionInfo
{
 NodeTag type;

 ExprState pi_state;

 ExprContext *pi_exprContext;
} ProjectionInfo;
# 363 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct JunkFilter
{
 NodeTag type;
 List *jf_targetList;
 TupleDesc jf_cleanTupType;
 AttrNumber *jf_cleanMap;
 TupleTableSlot *jf_resultSlot;
 AttrNumber jf_junkAttNo;
} JunkFilter;






typedef struct OnConflictSetState
{
 NodeTag type;

 TupleTableSlot *oc_Existing;
 TupleTableSlot *oc_ProjSlot;
 ProjectionInfo *oc_ProjInfo;
 ExprState *oc_WhereClause;
} OnConflictSetState;
# 402 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct ResultRelInfo
{
 NodeTag type;


 Index ri_RangeTableIndex;


 Relation ri_RelationDesc;


 int ri_NumIndices;


 RelationPtr ri_IndexRelationDescs;


 IndexInfo **ri_IndexRelationInfo;


 TriggerDesc *ri_TrigDesc;


 FmgrInfo *ri_TrigFunctions;


 ExprState **ri_TrigWhenExprs;


 Instrumentation *ri_TrigInstrument;


 TupleTableSlot *ri_ReturningSlot;
 TupleTableSlot *ri_TrigOldSlot;
 TupleTableSlot *ri_TrigNewSlot;


 struct FdwRoutine *ri_FdwRoutine;


 void *ri_FdwState;


 _Bool ri_usesFdwDirectModify;


 List *ri_WithCheckOptions;


 List *ri_WithCheckOptionExprs;


 ExprState **ri_ConstraintExprs;


 ExprState **ri_GeneratedExprs;


 JunkFilter *ri_junkFilter;


 List *ri_returningList;


 ProjectionInfo *ri_projectReturning;


 List *ri_onConflictArbiterIndexes;


 OnConflictSetState *ri_onConflict;


 List *ri_PartitionCheck;


 ExprState *ri_PartitionCheckExpr;


 Relation ri_PartitionRoot;


 struct PartitionRoutingInfo *ri_PartitionInfo;


 struct CopyMultiInsertBuffer *ri_CopyMultiInsertBuffer;
} ResultRelInfo;







typedef struct EState
{
 NodeTag type;


 ScanDirection es_direction;
 Snapshot es_snapshot;
 Snapshot es_crosscheck_snapshot;
 List *es_range_table;
 struct RangeTblEntry **es_range_table_array;
 Index es_range_table_size;
 Relation *es_relations;

 struct ExecRowMark **es_rowmarks;

 PlannedStmt *es_plannedstmt;
 const char *es_sourceText;

 JunkFilter *es_junkFilter;


 CommandId es_output_cid;


 ResultRelInfo *es_result_relations;
 int es_num_result_relations;
 ResultRelInfo *es_result_relation_info;







 ResultRelInfo *es_root_result_relations;
 int es_num_root_result_relations;
 PartitionDirectory es_partition_directory;





 List *es_tuple_routing_result_relations;


 List *es_trig_target_relations;


 ParamListInfo es_param_list_info;
 ParamExecData *es_param_exec_vals;

 QueryEnvironment *es_queryEnv;


 MemoryContext es_query_cxt;

 List *es_tupleTable;

 uint64 es_processed;

 int es_top_eflags;
 int es_instrument;
 _Bool es_finished;

 List *es_exprcontexts;

 List *es_subplanstates;

 List *es_auxmodifytables;






 ExprContext *es_per_tuple_exprcontext;







 struct EPQState *es_epq_active;

 _Bool es_use_parallel_mode;


 struct dsa_area *es_query_dsa;
# 595 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
 int es_jit_flags;
 struct JitContext *es_jit;
 struct JitInstrumentation *es_jit_worker_instr;
} EState;
# 620 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct ExecRowMark
{
 Relation relation;
 Oid relid;
 Index rti;
 Index prti;
 Index rowmarkId;
 RowMarkType markType;
 LockClauseStrength strength;
 LockWaitPolicy waitPolicy;
 _Bool ermActive;
 ItemPointerData curCtid;
 void *ermExtra;
} ExecRowMark;
# 647 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct ExecAuxRowMark
{
 ExecRowMark *rowmark;
 AttrNumber ctidAttNo;
 AttrNumber toidAttNo;
 AttrNumber wholeAttNo;
} ExecAuxRowMark;
# 672 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct TupleHashEntryData *TupleHashEntry;
typedef struct TupleHashTableData *TupleHashTable;

typedef struct TupleHashEntryData
{
 MinimalTuple firstTuple;
 void *additional;
 uint32 status;
 uint32 hash;
} TupleHashEntryData;







# 1 "/products1/postgres/PG12.1/include/server/lib/simplehash.h" 1
# 99 "/products1/postgres/PG12.1/include/server/lib/simplehash.h"
typedef struct tuplehash_hash
{





 uint64 size;


 uint32 members;


 uint32 sizemask;


 uint32 grow_threshold;


 TupleHashEntryData *data;


 MemoryContext ctx;


 void *private_data;
} tuplehash_hash;

typedef enum tuplehash_status
{
 tuplehash_SH_EMPTY = 0x00,
 tuplehash_SH_IN_USE = 0x01
} tuplehash_status;

typedef struct tuplehash_iterator
{
 uint32 cur;
 uint32 end;
 _Bool done;
} tuplehash_iterator;


extern tuplehash_hash *tuplehash_create(MemoryContext ctx, uint32 nelements,
          void *private_data);
extern void tuplehash_destroy(tuplehash_hash * tb);
extern void tuplehash_reset(tuplehash_hash * tb);
extern void tuplehash_grow(tuplehash_hash * tb, uint32 newsize);
extern TupleHashEntryData *tuplehash_insert(tuplehash_hash * tb, MinimalTuple key, _Bool *found);
extern TupleHashEntryData *tuplehash_lookup(tuplehash_hash * tb, MinimalTuple key);
extern _Bool tuplehash_delete(tuplehash_hash * tb, MinimalTuple key);
extern void tuplehash_start_iterate(tuplehash_hash * tb, tuplehash_iterator * iter);
extern void tuplehash_start_iterate_at(tuplehash_hash * tb, tuplehash_iterator * iter, uint32 at);
extern TupleHashEntryData *tuplehash_iterate(tuplehash_hash * tb, tuplehash_iterator * iter);
extern void tuplehash_stat(tuplehash_hash * tb);
# 690 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h" 2

typedef struct TupleHashTableData
{
 tuplehash_hash *hashtab;
 int numCols;
 AttrNumber *keyColIdx;
 FmgrInfo *tab_hash_funcs;
 ExprState *tab_eq_func;
 Oid *tab_collations;
 MemoryContext tablecxt;
 MemoryContext tempcxt;
 Size entrysize;
 TupleTableSlot *tableslot;

 TupleTableSlot *inputslot;
 FmgrInfo *in_hash_funcs;
 ExprState *cur_eq_func;
 uint32 hash_iv;
 ExprContext *exprcontext;
} TupleHashTableData;

typedef tuplehash_iterator TupleHashIterator;
# 744 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct AggrefExprState
{
 NodeTag type;
 Aggref *aggref;
 int aggno;
} AggrefExprState;





typedef struct WindowFuncExprState
{
 NodeTag type;
 WindowFunc *wfunc;
 List *args;
 ExprState *aggfilter;
 int wfuncno;
} WindowFuncExprState;
# 774 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct SetExprState
{
 NodeTag type;
 Expr *expr;
 List *args;






 ExprState *elidedFuncState;






 FmgrInfo func;






 Tuplestorestate *funcResultStore;
 TupleTableSlot *funcResultSlot;





 TupleDesc funcResultDesc;
 _Bool funcReturnsTuple;





 _Bool funcReturnsSet;
# 822 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
 _Bool setArgsValid;







 _Bool shutdown_reg;






 FunctionCallInfo fcinfo;
} SetExprState;





typedef struct SubPlanState
{
 NodeTag type;
 SubPlan *subplan;
 struct PlanState *planstate;
 struct PlanState *parent;
 ExprState *testexpr;
 List *args;
 HeapTuple curTuple;
 Datum curArray;

 TupleDesc descRight;
 ProjectionInfo *projLeft;
 ProjectionInfo *projRight;
 TupleHashTable hashtable;
 TupleHashTable hashnulls;
 _Bool havehashrows;
 _Bool havenullrows;
 MemoryContext hashtablecxt;
 MemoryContext hashtempcxt;
 ExprContext *innerecontext;
 AttrNumber *keyColIdx;
 Oid *tab_eq_funcoids;

 Oid *tab_collations;
 FmgrInfo *tab_hash_funcs;
 FmgrInfo *tab_eq_funcs;
 FmgrInfo *lhs_hash_funcs;
 FmgrInfo *cur_eq_funcs;
 ExprState *cur_eq_comp;
} SubPlanState;





typedef struct AlternativeSubPlanState
{
 NodeTag type;
 AlternativeSubPlan *subplan;
 List *subplans;
 int active;
} AlternativeSubPlanState;
# 895 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef enum DomainConstraintType
{
 DOM_CONSTRAINT_NOTNULL,
 DOM_CONSTRAINT_CHECK
} DomainConstraintType;

typedef struct DomainConstraintState
{
 NodeTag type;
 DomainConstraintType constrainttype;
 char *name;
 Expr *check_expr;
 ExprState *check_exprstate;
} DomainConstraintState;
# 927 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef TupleTableSlot *(*ExecProcNodeMtd) (struct PlanState *pstate);
# 936 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct PlanState
{
 NodeTag type;

 Plan *plan;

 EState *state;



 ExecProcNodeMtd ExecProcNode;
 ExecProcNodeMtd ExecProcNodeReal;


 Instrumentation *instrument;
 WorkerInstrumentation *worker_instrument;


 struct SharedJitInstrumentation *worker_jit_instrument;






 ExprState *qual;
 struct PlanState *lefttree;
 struct PlanState *righttree;

 List *initPlan;

 List *subPlan;




 Bitmapset *chgParam;




 TupleDesc ps_ResultTupleDesc;
 TupleTableSlot *ps_ResultTupleSlot;
 ExprContext *ps_ExprContext;
 ProjectionInfo *ps_ProjInfo;






 TupleDesc scandesc;
# 1012 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
 const TupleTableSlotOps *scanops;
 const TupleTableSlotOps *outerops;
 const TupleTableSlotOps *innerops;
 const TupleTableSlotOps *resultops;
 _Bool scanopsfixed;
 _Bool outeropsfixed;
 _Bool inneropsfixed;
 _Bool resultopsfixed;
 _Bool scanopsset;
 _Bool outeropsset;
 _Bool inneropsset;
 _Bool resultopsset;
} PlanState;
# 1072 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct EPQState
{


 EState *parentestate;
 int epqParam;






 List *tuple_table;
 TupleTableSlot **relsubs_slot;






 Plan *plan;
 List *arowMarks;







 TupleTableSlot *origslot;




 EState *recheckestate;






 ExecAuxRowMark **relsubs_rowmark;





 _Bool *relsubs_done;

 PlanState *recheckplanstate;
} EPQState;






typedef struct ResultState
{
 PlanState ps;
 ExprState *resconstantqual;
 _Bool rs_done;
 _Bool rs_checkqual;
} ResultState;
# 1144 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct ProjectSetState
{
 PlanState ps;
 Node **elems;
 ExprDoneCond *elemdone;
 int nelems;
 _Bool pending_srf_tuples;
 MemoryContext argcontext;
} ProjectSetState;





typedef struct ModifyTableState
{
 PlanState ps;
 CmdType operation;
 _Bool canSetTag;
 _Bool mt_done;
 PlanState **mt_plans;
 int mt_nplans;
 int mt_whichplan;
 TupleTableSlot **mt_scans;

 ResultRelInfo *resultRelInfo;
 ResultRelInfo *rootResultRelInfo;

 List **mt_arowmarks;
 EPQState mt_epqstate;
 _Bool fireBSTriggers;
 List *mt_excludedtlist;





 TupleTableSlot *mt_root_tuple_slot;


 struct PartitionTupleRouting *mt_partition_tuple_routing;


 struct TransitionCaptureState *mt_transition_capture;


 struct TransitionCaptureState *mt_oc_transition_capture;


 TupleConversionMap **mt_per_subplan_tupconv_maps;
} ModifyTableState;
# 1209 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
struct AppendState;
typedef struct AppendState AppendState;
struct ParallelAppendState;
typedef struct ParallelAppendState ParallelAppendState;
struct PartitionPruneState;

struct AppendState
{
 PlanState ps;
 PlanState **appendplans;
 int as_nplans;
 int as_whichplan;
 int as_first_partial_plan;

 ParallelAppendState *as_pstate;
 Size pstate_len;
 struct PartitionPruneState *as_prune_state;
 Bitmapset *as_valid_subplans;
 _Bool (*choose_next_subplan) (AppendState *);
};
# 1247 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct MergeAppendState
{
 PlanState ps;
 PlanState **mergeplans;
 int ms_nplans;
 int ms_nkeys;
 SortSupport ms_sortkeys;
 TupleTableSlot **ms_slots;
 struct binaryheap *ms_heap;
 _Bool ms_initialized;
 _Bool ms_noopscan;
 struct PartitionPruneState *ms_prune_state;
 Bitmapset *ms_valid_subplans;
} MergeAppendState;
# 1273 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct RecursiveUnionState
{
 PlanState ps;
 _Bool recursing;
 _Bool intermediate_empty;
 Tuplestorestate *working_table;
 Tuplestorestate *intermediate_table;

 Oid *eqfuncoids;
 FmgrInfo *hashfunctions;
 MemoryContext tempContext;
 TupleHashTable hashtable;
 MemoryContext tableContext;
} RecursiveUnionState;





typedef struct BitmapAndState
{
 PlanState ps;
 PlanState **bitmapplans;
 int nplans;
} BitmapAndState;





typedef struct BitmapOrState
{
 PlanState ps;
 PlanState **bitmapplans;
 int nplans;
} BitmapOrState;
# 1329 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct ScanState
{
 PlanState ps;
 Relation ss_currentRelation;
 struct TableScanDescData *ss_currentScanDesc;
 TupleTableSlot *ss_ScanTupleSlot;
} ScanState;





typedef struct SeqScanState
{
 ScanState ss;
 Size pscan_len;
} SeqScanState;





typedef struct SampleScanState
{
 ScanState ss;
 List *args;
 ExprState *repeatable;

 struct TsmRoutine *tsmroutine;
 void *tsm_state;
 _Bool use_bulkread;
 _Bool use_pagemode;
 _Bool begun;
 uint32 seed;
 int64 donetuples;
 _Bool haveblock;
 _Bool done;
} SampleScanState;






typedef struct
{
 struct ScanKeyData *scan_key;
 ExprState *key_expr;
 _Bool key_toastable;
} IndexRuntimeKeyInfo;

typedef struct
{
 struct ScanKeyData *scan_key;
 ExprState *array_expr;
 int next_elem;
 int num_elems;
 Datum *elem_values;
 _Bool *elem_nulls;
} IndexArrayKeyInfo;
# 1416 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct IndexScanState
{
 ScanState ss;
 ExprState *indexqualorig;
 List *indexorderbyorig;
 struct ScanKeyData *iss_ScanKeys;
 int iss_NumScanKeys;
 struct ScanKeyData *iss_OrderByKeys;
 int iss_NumOrderByKeys;
 IndexRuntimeKeyInfo *iss_RuntimeKeys;
 int iss_NumRuntimeKeys;
 _Bool iss_RuntimeKeysReady;
 ExprContext *iss_RuntimeContext;
 Relation iss_RelationDesc;
 struct IndexScanDescData *iss_ScanDesc;


 pairingheap *iss_ReorderQueue;
 _Bool iss_ReachedEnd;
 Datum *iss_OrderByValues;
 _Bool *iss_OrderByNulls;
 SortSupport iss_SortSupport;
 _Bool *iss_OrderByTypByVals;
 int16 *iss_OrderByTypLens;
 Size iss_PscanLen;
} IndexScanState;
# 1462 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct IndexOnlyScanState
{
 ScanState ss;
 ExprState *indexqual;
 struct ScanKeyData *ioss_ScanKeys;
 int ioss_NumScanKeys;
 struct ScanKeyData *ioss_OrderByKeys;
 int ioss_NumOrderByKeys;
 IndexRuntimeKeyInfo *ioss_RuntimeKeys;
 int ioss_NumRuntimeKeys;
 _Bool ioss_RuntimeKeysReady;
 ExprContext *ioss_RuntimeContext;
 Relation ioss_RelationDesc;
 struct IndexScanDescData *ioss_ScanDesc;
 TupleTableSlot *ioss_TableSlot;
 Buffer ioss_VMBuffer;
 Size ioss_PscanLen;
} IndexOnlyScanState;
# 1497 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct BitmapIndexScanState
{
 ScanState ss;
 TIDBitmap *biss_result;
 struct ScanKeyData *biss_ScanKeys;
 int biss_NumScanKeys;
 IndexRuntimeKeyInfo *biss_RuntimeKeys;
 int biss_NumRuntimeKeys;
 IndexArrayKeyInfo *biss_ArrayKeys;
 int biss_NumArrayKeys;
 _Bool biss_RuntimeKeysReady;
 ExprContext *biss_RuntimeContext;
 Relation biss_RelationDesc;
 struct IndexScanDescData *biss_ScanDesc;
} BitmapIndexScanState;
# 1526 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef enum
{
 BM_INITIAL,
 BM_INPROGRESS,
 BM_FINISHED
} SharedBitmapState;
# 1546 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct ParallelBitmapHeapState
{
 dsa_pointer tbmiterator;
 dsa_pointer prefetch_iterator;
 slock_t mutex;
 int prefetch_pages;
 int prefetch_target;
 SharedBitmapState state;
 ConditionVariable cv;
 char phs_snapshot_data[];
} ParallelBitmapHeapState;
# 1582 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct BitmapHeapScanState
{
 ScanState ss;
 ExprState *bitmapqualorig;
 TIDBitmap *tbm;
 TBMIterator *tbmiterator;
 TBMIterateResult *tbmres;
 _Bool can_skip_fetch;
 int return_empty_tuples;
 Buffer vmbuffer;
 Buffer pvmbuffer;
 long exact_pages;
 long lossy_pages;
 TBMIterator *prefetch_iterator;
 int prefetch_pages;
 int prefetch_target;
 int prefetch_maximum;
 Size pscan_len;
 _Bool initialized;
 TBMSharedIterator *shared_tbmiterator;
 TBMSharedIterator *shared_prefetch_iterator;
 ParallelBitmapHeapState *pstate;
} BitmapHeapScanState;
# 1617 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct TidScanState
{
 ScanState ss;
 List *tss_tidexprs;
 _Bool tss_isCurrentOf;
 int tss_NumTids;
 int tss_TidPtr;
 ItemPointerData *tss_TidList;
 HeapTupleData tss_htup;
} TidScanState;
# 1635 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct SubqueryScanState
{
 ScanState ss;
 PlanState *subplan;
} SubqueryScanState;
# 1657 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
struct FunctionScanPerFuncState;

typedef struct FunctionScanState
{
 ScanState ss;
 int eflags;
 _Bool ordinality;
 _Bool simple;
 int64 ordinal;
 int nfuncs;
 struct FunctionScanPerFuncState *funcstates;
 MemoryContext argcontext;
} FunctionScanState;
# 1688 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct ValuesScanState
{
 ScanState ss;
 ExprContext *rowcontext;
 List **exprlists;
 int array_len;
 int curr_idx;
} ValuesScanState;







typedef struct TableFuncScanState
{
 ScanState ss;
 ExprState *docexpr;
 ExprState *rowexpr;
 List *colexprs;
 List *coldefexprs;
 List *ns_names;
 List *ns_uris;
 Bitmapset *notnulls;
 void *opaque;
 const struct TableFuncRoutine *routine;
 FmgrInfo *in_functions;
 Oid *typioparams;
 int64 ordinal;
 MemoryContext perTableCxt;
 Tuplestorestate *tupstore;
} TableFuncScanState;
# 1732 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct CteScanState
{
 ScanState ss;
 int eflags;
 int readptr;
 PlanState *cteplanstate;

 struct CteScanState *leader;

 Tuplestorestate *cte_table;
 _Bool eof_cte;
} CteScanState;
# 1755 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct NamedTuplestoreScanState
{
 ScanState ss;
 int readptr;
 TupleDesc tupdesc;
 Tuplestorestate *relation;
} NamedTuplestoreScanState;
# 1771 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct WorkTableScanState
{
 ScanState ss;
 RecursiveUnionState *rustate;
} WorkTableScanState;







typedef struct ForeignScanState
{
 ScanState ss;
 ExprState *fdw_recheck_quals;
 Size pscan_len;

 struct FdwRoutine *fdwroutine;
 void *fdw_state;
} ForeignScanState;
# 1806 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
struct CustomExecMethods;

typedef struct CustomScanState
{
 ScanState ss;
 uint32 flags;

 List *custom_ps;
 Size pscan_len;
 const struct CustomExecMethods *methods;
} CustomScanState;
# 1829 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct JoinState
{
 PlanState ps;
 JoinType jointype;
 _Bool single_match;

 ExprState *joinqual;
} JoinState;
# 1846 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct NestLoopState
{
 JoinState js;
 _Bool nl_NeedNewOuter;
 _Bool nl_MatchedOuter;
 TupleTableSlot *nl_NullInnerTupleSlot;
} NestLoopState;
# 1877 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct MergeJoinClauseData *MergeJoinClause;

typedef struct MergeJoinState
{
 JoinState js;
 int mj_NumClauses;
 MergeJoinClause mj_Clauses;
 int mj_JoinState;
 _Bool mj_SkipMarkRestore;
 _Bool mj_ExtraMarks;
 _Bool mj_ConstFalseJoin;
 _Bool mj_FillOuter;
 _Bool mj_FillInner;
 _Bool mj_MatchedOuter;
 _Bool mj_MatchedInner;
 TupleTableSlot *mj_OuterTupleSlot;
 TupleTableSlot *mj_InnerTupleSlot;
 TupleTableSlot *mj_MarkedTupleSlot;
 TupleTableSlot *mj_NullOuterTupleSlot;
 TupleTableSlot *mj_NullInnerTupleSlot;
 ExprContext *mj_OuterEContext;
 ExprContext *mj_InnerEContext;
} MergeJoinState;
# 1928 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct HashJoinTupleData *HashJoinTuple;
typedef struct HashJoinTableData *HashJoinTable;

typedef struct HashJoinState
{
 JoinState js;
 ExprState *hashclauses;
 List *hj_OuterHashKeys;
 List *hj_HashOperators;
 List *hj_Collations;
 HashJoinTable hj_HashTable;
 uint32 hj_CurHashValue;
 int hj_CurBucketNo;
 int hj_CurSkewBucketNo;
 HashJoinTuple hj_CurTuple;
 TupleTableSlot *hj_OuterTupleSlot;
 TupleTableSlot *hj_HashTupleSlot;
 TupleTableSlot *hj_NullOuterTupleSlot;
 TupleTableSlot *hj_NullInnerTupleSlot;
 TupleTableSlot *hj_FirstOuterTupleSlot;
 int hj_JoinState;
 _Bool hj_MatchedOuter;
 _Bool hj_OuterNotEmpty;
} HashJoinState;
# 1968 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct MaterialState
{
 ScanState ss;
 int eflags;
 _Bool eof_underlying;
 Tuplestorestate *tuplestorestate;
} MaterialState;





typedef struct SharedSortInfo
{
 int num_workers;
 TuplesortInstrumentation sinstrument[];
} SharedSortInfo;





typedef struct SortState
{
 ScanState ss;
 _Bool randomAccess;
 _Bool bounded;
 int64 bound;
 _Bool sort_Done;
 _Bool bounded_Done;
 int64 bound_Done;
 void *tuplesortstate;
 _Bool am_worker;
 SharedSortInfo *shared_info;
} SortState;





typedef struct GroupState
{
 ScanState ss;
 ExprState *eqfunction;
 _Bool grp_done;
} GroupState;
# 2028 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct AggStatePerAggData *AggStatePerAgg;
typedef struct AggStatePerTransData *AggStatePerTrans;
typedef struct AggStatePerGroupData *AggStatePerGroup;
typedef struct AggStatePerPhaseData *AggStatePerPhase;
typedef struct AggStatePerHashData *AggStatePerHash;

typedef struct AggState
{
 ScanState ss;
 List *aggs;
 int numaggs;
 int numtrans;
 AggStrategy aggstrategy;
 AggSplit aggsplit;
 AggStatePerPhase phase;
 int numphases;
 int current_phase;
 AggStatePerAgg peragg;
 AggStatePerTrans pertrans;
 ExprContext *hashcontext;
 ExprContext **aggcontexts;
 ExprContext *tmpcontext;

 ExprContext *curaggcontext;
 AggStatePerAgg curperagg;

 AggStatePerTrans curpertrans;
 _Bool input_done;
 _Bool agg_done;
 int projected_set;

 int current_set;
 Bitmapset *grouped_cols;
 List *all_grouped_cols;

 int maxsets;
 AggStatePerPhase phases;
 Tuplesortstate *sort_in;
 Tuplesortstate *sort_out;
 TupleTableSlot *sort_slot;

 AggStatePerGroup *pergroups;

 HeapTuple grp_firstTuple;

 _Bool table_filled;
 int num_hashes;
 AggStatePerHash perhash;
 AggStatePerGroup *hash_pergroup;




 AggStatePerGroup *all_pergroups;

 ProjectionInfo *combinedproj;
} AggState;






typedef struct WindowStatePerFuncData *WindowStatePerFunc;
typedef struct WindowStatePerAggData *WindowStatePerAgg;

typedef struct WindowAggState
{
 ScanState ss;


 List *funcs;
 int numfuncs;
 int numaggs;

 WindowStatePerFunc perfunc;
 WindowStatePerAgg peragg;
 ExprState *partEqfunction;
 ExprState *ordEqfunction;
 Tuplestorestate *buffer;
 int current_ptr;
 int framehead_ptr;
 int frametail_ptr;
 int grouptail_ptr;
 int64 spooled_rows;
 int64 currentpos;
 int64 frameheadpos;
 int64 frametailpos;

 struct WindowObjectData *agg_winobj;
 int64 aggregatedbase;
 int64 aggregatedupto;

 int frameOptions;
 ExprState *startOffset;
 ExprState *endOffset;
 Datum startOffsetValue;
 Datum endOffsetValue;


 FmgrInfo startInRangeFunc;
 FmgrInfo endInRangeFunc;
 Oid inRangeColl;
 _Bool inRangeAsc;
 _Bool inRangeNullsFirst;


 int64 currentgroup;
 int64 frameheadgroup;
 int64 frametailgroup;
 int64 groupheadpos;
 int64 grouptailpos;

 MemoryContext partcontext;
 MemoryContext aggcontext;
 MemoryContext curaggcontext;
 ExprContext *tmpcontext;

 _Bool all_first;
 _Bool all_done;
 _Bool partition_spooled;

 _Bool more_partitions;

 _Bool framehead_valid;

 _Bool frametail_valid;

 _Bool grouptail_valid;


 TupleTableSlot *first_part_slot;

 TupleTableSlot *framehead_slot;
 TupleTableSlot *frametail_slot;


 TupleTableSlot *agg_row_slot;
 TupleTableSlot *temp_slot_1;
 TupleTableSlot *temp_slot_2;
} WindowAggState;
# 2181 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct UniqueState
{
 PlanState ps;
 ExprState *eqfunction;
} UniqueState;
# 2194 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct GatherState
{
 PlanState ps;
 _Bool initialized;
 _Bool need_to_scan_locally;
 int64 tuples_needed;

 TupleTableSlot *funnel_slot;
 struct ParallelExecutorInfo *pei;

 int nworkers_launched;
 int nreaders;
 int nextreader;
 struct TupleQueueReader **reader;
} GatherState;
# 2218 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
struct GMReaderTupleBuffer;

typedef struct GatherMergeState
{
 PlanState ps;
 _Bool initialized;
 _Bool gm_initialized;
 _Bool need_to_scan_locally;
 int64 tuples_needed;

 TupleDesc tupDesc;
 int gm_nkeys;
 SortSupport gm_sortkeys;
 struct ParallelExecutorInfo *pei;


 int nworkers_launched;
 int nreaders;
 TupleTableSlot **gm_slots;
 struct TupleQueueReader **reader;
 struct GMReaderTupleBuffer *gm_tuple_buffers;
 struct binaryheap *gm_heap;
} GatherMergeState;





typedef struct HashInstrumentation
{
 int nbuckets;
 int nbuckets_original;
 int nbatch;
 int nbatch_original;
 size_t space_peak;
} HashInstrumentation;





typedef struct SharedHashInfo
{
 int num_workers;
 HashInstrumentation hinstrument[];
} SharedHashInfo;





typedef struct HashState
{
 PlanState ps;
 HashJoinTable hashtable;
 List *hashkeys;

 SharedHashInfo *shared_info;
 HashInstrumentation *hinstrument;


 struct ParallelHashJoinState *parallel_state;
} HashState;
# 2292 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef struct SetOpStatePerGroupData *SetOpStatePerGroup;

typedef struct SetOpState
{
 PlanState ps;
 ExprState *eqfunction;
 Oid *eqfuncoids;
 FmgrInfo *hashfunctions;
 _Bool setop_done;
 long numOutput;

 SetOpStatePerGroup pergroup;
 HeapTuple grp_firstTuple;

 TupleHashTable hashtable;
 MemoryContext tableContext;
 _Bool table_filled;
 TupleHashIterator hashiter;
} SetOpState;







typedef struct LockRowsState
{
 PlanState ps;
 List *lr_arowMarks;
 EPQState lr_epqstate;
} LockRowsState;
# 2337 "/products1/postgres/PG12.1/include/server/nodes/execnodes.h"
typedef enum
{
 LIMIT_INITIAL,
 LIMIT_RESCAN,
 LIMIT_EMPTY,
 LIMIT_INWINDOW,
 LIMIT_SUBPLANEOF,
 LIMIT_WINDOWEND,
 LIMIT_WINDOWSTART
} LimitStateCond;

typedef struct LimitState
{
 PlanState ps;
 ExprState *limitOffset;
 ExprState *limitCount;
 int64 offset;
 int64 count;
 _Bool noCount;
 LimitStateCond lstate;
 int64 position;
 TupleTableSlot *subSlot;
} LimitState;
# 19 "/products1/postgres/PG12.1/include/server/executor/execdesc.h" 2
# 33 "/products1/postgres/PG12.1/include/server/executor/execdesc.h"
typedef struct QueryDesc
{

 CmdType operation;
 PlannedStmt *plannedstmt;
 const char *sourceText;
 Snapshot snapshot;
 Snapshot crosscheck_snapshot;
 DestReceiver *dest;
 ParamListInfo params;
 QueryEnvironment *queryEnv;
 int instrument_options;


 TupleDesc tupDesc;
 EState *estate;
 PlanState *planstate;


 _Bool already_executed;


 struct Instrumentation *totaltime;
} QueryDesc;


extern QueryDesc *CreateQueryDesc(PlannedStmt *plannedstmt,
          const char *sourceText,
          Snapshot snapshot,
          Snapshot crosscheck_snapshot,
          DestReceiver *dest,
          ParamListInfo params,
          QueryEnvironment *queryEnv,
          int instrument_options);

extern void FreeQueryDesc(QueryDesc *qdesc);
# 18 "/products1/postgres/PG12.1/include/server/executor/executor.h" 2


# 1 "/products1/postgres/PG12.1/include/server/utils/memutils.h" 1
# 20 "/products1/postgres/PG12.1/include/server/utils/memutils.h"
# 1 "/products1/postgres/PG12.1/include/server/nodes/memnodes.h" 1
# 29 "/products1/postgres/PG12.1/include/server/nodes/memnodes.h"
typedef struct MemoryContextCounters
{
 Size nblocks;
 Size freechunks;
 Size totalspace;
 Size freespace;
} MemoryContextCounters;
# 54 "/products1/postgres/PG12.1/include/server/nodes/memnodes.h"
typedef void (*MemoryStatsPrintFunc) (MemoryContext context, void *passthru,
           const char *stats_string);

typedef struct MemoryContextMethods
{
 void *(*alloc) (MemoryContext context, Size size);

 void (*free_p) (MemoryContext context, void *pointer);
 void *(*realloc) (MemoryContext context, void *pointer, Size size);
 void (*reset) (MemoryContext context);
 void (*delete_context) (MemoryContext context);
 Size (*get_chunk_space) (MemoryContext context, void *pointer);
 _Bool (*is_empty) (MemoryContext context);
 void (*stats) (MemoryContext context,
        MemoryStatsPrintFunc printfunc, void *passthru,
        MemoryContextCounters *totals);



} MemoryContextMethods;


typedef struct MemoryContextData
{
 NodeTag type;

 _Bool isReset;
 _Bool allowInCritSection;
 const MemoryContextMethods *methods;
 MemoryContext parent;
 MemoryContext firstchild;
 MemoryContext prevchild;
 MemoryContext nextchild;
 const char *name;
 const char *ident;
 MemoryContextCallback *reset_cbs;
} MemoryContextData;
# 21 "/products1/postgres/PG12.1/include/server/utils/memutils.h" 2
# 55 "/products1/postgres/PG12.1/include/server/utils/memutils.h"
extern MemoryContext TopMemoryContext;
extern MemoryContext ErrorContext;
extern MemoryContext PostmasterContext;
extern MemoryContext CacheMemoryContext;
extern MemoryContext MessageContext;
extern MemoryContext TopTransactionContext;
extern MemoryContext CurTransactionContext;


extern MemoryContext PortalContext;
# 73 "/products1/postgres/PG12.1/include/server/utils/memutils.h"
extern void MemoryContextInit(void);
extern void MemoryContextReset(MemoryContext context);
extern void MemoryContextDelete(MemoryContext context);
extern void MemoryContextResetOnly(MemoryContext context);
extern void MemoryContextResetChildren(MemoryContext context);
extern void MemoryContextDeleteChildren(MemoryContext context);
extern void MemoryContextSetIdentifier(MemoryContext context, const char *id);
extern void MemoryContextSetParent(MemoryContext context,
           MemoryContext new_parent);
extern Size GetMemoryChunkSpace(void *pointer);
extern MemoryContext MemoryContextGetParent(MemoryContext context);
extern _Bool MemoryContextIsEmpty(MemoryContext context);
extern void MemoryContextStats(MemoryContext context);
extern void MemoryContextStatsDetail(MemoryContext context, int max_children);
extern void MemoryContextAllowInCriticalSection(MemoryContext context,
            _Bool allow);




extern _Bool MemoryContextContains(MemoryContext context, void *pointer);
# 111 "/products1/postgres/PG12.1/include/server/utils/memutils.h"
static inline MemoryContext
GetMemoryChunkContext(void *pointer)
{
 MemoryContext context;






 ((void)1);
 ((void)1);




 context = *(MemoryContext *) (((char *) pointer) - sizeof(void *));

 ((void)1);

 return context;
}







extern void MemoryContextCreate(MemoryContext node,
        NodeTag tag,
        const MemoryContextMethods *methods,
        MemoryContext parent,
        const char *name);







extern MemoryContext AllocSetContextCreateInternal(MemoryContext parent,
               const char *name,
               Size minContextSize,
               Size initBlockSize,
               Size maxBlockSize);
# 174 "/products1/postgres/PG12.1/include/server/utils/memutils.h"
extern MemoryContext SlabContextCreate(MemoryContext parent,
            const char *name,
            Size blockSize,
            Size chunkSize);


extern MemoryContext GenerationContextCreate(MemoryContext parent,
            const char *name,
            Size blockSize);
# 21 "/products1/postgres/PG12.1/include/server/executor/executor.h" 2
# 64 "/products1/postgres/PG12.1/include/server/executor/executor.h"
typedef void (*ExecutorStart_hook_type) (QueryDesc *queryDesc, int eflags);
extern ExecutorStart_hook_type ExecutorStart_hook;


typedef void (*ExecutorRun_hook_type) (QueryDesc *queryDesc,
            ScanDirection direction,
            uint64 count,
            _Bool execute_once);
extern ExecutorRun_hook_type ExecutorRun_hook;


typedef void (*ExecutorFinish_hook_type) (QueryDesc *queryDesc);
extern ExecutorFinish_hook_type ExecutorFinish_hook;


typedef void (*ExecutorEnd_hook_type) (QueryDesc *queryDesc);
extern ExecutorEnd_hook_type ExecutorEnd_hook;


typedef _Bool (*ExecutorCheckPerms_hook_type) (List *, _Bool);
extern ExecutorCheckPerms_hook_type ExecutorCheckPerms_hook;





struct Path;

extern void ExecReScan(PlanState *node);
extern void ExecMarkPos(PlanState *node);
extern void ExecRestrPos(PlanState *node);
extern _Bool ExecSupportsMarkRestore(struct Path *pathnode);
extern _Bool ExecSupportsBackwardScan(Plan *node);
extern _Bool ExecMaterializesOutput(NodeTag plantype);




extern _Bool execCurrentOf(CurrentOfExpr *cexpr,
        ExprContext *econtext,
        Oid table_oid,
        ItemPointer current_tid);




extern ExprState *execTuplesMatchPrepare(TupleDesc desc,
           int numCols,
           const AttrNumber *keyColIdx,
           const Oid *eqOperators,
           const Oid *collations,
           PlanState *parent);
extern void execTuplesHashPrepare(int numCols,
          const Oid *eqOperators,
          Oid **eqFuncOids,
          FmgrInfo **hashFunctions);
extern TupleHashTable BuildTupleHashTable(PlanState *parent,
            TupleDesc inputDesc,
            int numCols, AttrNumber *keyColIdx,
            const Oid *eqfuncoids,
            FmgrInfo *hashfunctions,
            Oid *collations,
            long nbuckets, Size additionalsize,
            MemoryContext tablecxt,
            MemoryContext tempcxt, _Bool use_variable_hash_iv);
extern TupleHashTable BuildTupleHashTableExt(PlanState *parent,
            TupleDesc inputDesc,
            int numCols, AttrNumber *keyColIdx,
            const Oid *eqfuncoids,
            FmgrInfo *hashfunctions,
            Oid *collations,
            long nbuckets, Size additionalsize,
            MemoryContext metacxt,
            MemoryContext tablecxt,
            MemoryContext tempcxt, _Bool use_variable_hash_iv);
extern TupleHashEntry LookupTupleHashEntry(TupleHashTable hashtable,
             TupleTableSlot *slot,
             _Bool *isnew);
extern TupleHashEntry FindTupleHashEntry(TupleHashTable hashtable,
           TupleTableSlot *slot,
           ExprState *eqcomp,
           FmgrInfo *hashfunctions);
extern void ResetTupleHashTable(TupleHashTable hashtable);




extern JunkFilter *ExecInitJunkFilter(List *targetList,
           TupleTableSlot *slot);
extern JunkFilter *ExecInitJunkFilterConversion(List *targetList,
            TupleDesc cleanTupType,
            TupleTableSlot *slot);
extern AttrNumber ExecFindJunkAttribute(JunkFilter *junkfilter,
          const char *attrName);
extern AttrNumber ExecFindJunkAttributeInTlist(List *targetlist,
              const char *attrName);
extern Datum ExecGetJunkAttribute(TupleTableSlot *slot, AttrNumber attno,
          _Bool *isNull);
extern TupleTableSlot *ExecFilterJunk(JunkFilter *junkfilter,
           TupleTableSlot *slot);





extern void ExecutorStart(QueryDesc *queryDesc, int eflags);
extern void standard_ExecutorStart(QueryDesc *queryDesc, int eflags);
extern void ExecutorRun(QueryDesc *queryDesc,
      ScanDirection direction, uint64 count, _Bool execute_once);
extern void standard_ExecutorRun(QueryDesc *queryDesc,
         ScanDirection direction, uint64 count, _Bool execute_once);
extern void ExecutorFinish(QueryDesc *queryDesc);
extern void standard_ExecutorFinish(QueryDesc *queryDesc);
extern void ExecutorEnd(QueryDesc *queryDesc);
extern void standard_ExecutorEnd(QueryDesc *queryDesc);
extern void ExecutorRewind(QueryDesc *queryDesc);
extern _Bool ExecCheckRTPerms(List *rangeTable, _Bool ereport_on_violation);
extern void CheckValidResultRel(ResultRelInfo *resultRelInfo, CmdType operation);
extern void InitResultRelInfo(ResultRelInfo *resultRelInfo,
         Relation resultRelationDesc,
         Index resultRelationIndex,
         Relation partition_root,
         int instrument_options);
extern ResultRelInfo *ExecGetTriggerResultRel(EState *estate, Oid relid);
extern void ExecCleanUpTriggerState(EState *estate);
extern void ExecConstraints(ResultRelInfo *resultRelInfo,
       TupleTableSlot *slot, EState *estate);
extern _Bool ExecPartitionCheck(ResultRelInfo *resultRelInfo,
          TupleTableSlot *slot, EState *estate, _Bool emitError);
extern void ExecPartitionCheckEmitError(ResultRelInfo *resultRelInfo,
          TupleTableSlot *slot, EState *estate);
extern void ExecWithCheckOptions(WCOKind kind, ResultRelInfo *resultRelInfo,
         TupleTableSlot *slot, EState *estate);
extern LockTupleMode ExecUpdateLockMode(EState *estate, ResultRelInfo *relinfo);
extern ExecRowMark *ExecFindRowMark(EState *estate, Index rti, _Bool missing_ok);
extern ExecAuxRowMark *ExecBuildAuxRowMark(ExecRowMark *erm, List *targetlist);
extern TupleTableSlot *EvalPlanQual(EPQState *epqstate, Relation relation,
         Index rti, TupleTableSlot *testslot);
extern void EvalPlanQualInit(EPQState *epqstate, EState *parentestate,
        Plan *subplan, List *auxrowmarks, int epqParam);
extern void EvalPlanQualSetPlan(EPQState *epqstate,
        Plan *subplan, List *auxrowmarks);
extern TupleTableSlot *EvalPlanQualSlot(EPQState *epqstate,
          Relation relation, Index rti);


extern _Bool EvalPlanQualFetchRowMark(EPQState *epqstate, Index rti, TupleTableSlot *slot);
extern TupleTableSlot *EvalPlanQualNext(EPQState *epqstate);
extern void EvalPlanQualBegin(EPQState *epqstate);
extern void EvalPlanQualEnd(EPQState *epqstate);




extern PlanState *ExecInitNode(Plan *node, EState *estate, int eflags);
extern void ExecSetExecProcNode(PlanState *node, ExecProcNodeMtd function);
extern Node *MultiExecProcNode(PlanState *node);
extern void ExecEndNode(PlanState *node);
extern _Bool ExecShutdownNode(PlanState *node);
extern void ExecSetTupleBound(int64 tuples_needed, PlanState *child_node);
# 233 "/products1/postgres/PG12.1/include/server/executor/executor.h"
static inline TupleTableSlot *
ExecProcNode(PlanState *node)
{
 if (node->chgParam != ((void *)0))
  ExecReScan(node);

 return node->ExecProcNode(node);
}





extern ExprState *ExecInitExpr(Expr *node, PlanState *parent);
extern ExprState *ExecInitExprWithParams(Expr *node, ParamListInfo ext_params);
extern ExprState *ExecInitQual(List *qual, PlanState *parent);
extern ExprState *ExecInitCheck(List *qual, PlanState *parent);
extern List *ExecInitExprList(List *nodes, PlanState *parent);
extern ExprState *ExecBuildAggTrans(AggState *aggstate, struct AggStatePerPhaseData *phase,
         _Bool doSort, _Bool doHash);
extern ExprState *ExecBuildGroupingEqual(TupleDesc ldesc, TupleDesc rdesc,
           const TupleTableSlotOps *lops, const TupleTableSlotOps *rops,
           int numCols,
           const AttrNumber *keyColIdx,
           const Oid *eqfunctions,
           const Oid *collations,
           PlanState *parent);
extern ProjectionInfo *ExecBuildProjectionInfo(List *targetList,
              ExprContext *econtext,
              TupleTableSlot *slot,
              PlanState *parent,
              TupleDesc inputDesc);
extern ExprState *ExecPrepareExpr(Expr *node, EState *estate);
extern ExprState *ExecPrepareQual(List *qual, EState *estate);
extern ExprState *ExecPrepareCheck(List *qual, EState *estate);
extern List *ExecPrepareExprList(List *nodes, EState *estate);
# 283 "/products1/postgres/PG12.1/include/server/executor/executor.h"
static inline Datum
ExecEvalExpr(ExprState *state,
    ExprContext *econtext,
    _Bool *isNull)
{
 return state->evalfunc(state, econtext, isNull);
}
# 298 "/products1/postgres/PG12.1/include/server/executor/executor.h"
static inline Datum
ExecEvalExprSwitchContext(ExprState *state,
        ExprContext *econtext,
        _Bool *isNull)
{
 Datum retDatum;
 MemoryContext oldContext;

 oldContext = MemoryContextSwitchTo(econtext->ecxt_per_tuple_memory);
 retDatum = state->evalfunc(state, econtext, isNull);
 MemoryContextSwitchTo(oldContext);
 return retDatum;
}
# 326 "/products1/postgres/PG12.1/include/server/executor/executor.h"
static inline TupleTableSlot *
ExecProject(ProjectionInfo *projInfo)
{
 ExprContext *econtext = projInfo->pi_exprContext;
 ExprState *state = &projInfo->pi_state;
 TupleTableSlot *slot = state->resultslot;
 _Bool isnull;





 ExecClearTuple(slot);


 (void) ExecEvalExprSwitchContext(state, econtext, &isnull);





 slot->tts_flags &= ~(1 << 1);
 slot->tts_nvalid = slot->tts_tupleDescriptor->natts;

 return slot;
}
# 363 "/products1/postgres/PG12.1/include/server/executor/executor.h"
static inline _Bool
ExecQual(ExprState *state, ExprContext *econtext)
{
 Datum ret;
 _Bool isnull;


 if (state == ((void *)0))
  return 1;


 ((void)1);

 ret = ExecEvalExprSwitchContext(state, econtext, &isnull);


 ((void)1);

 return ((_Bool) ((ret) != 0));
}







static inline _Bool
ExecQualAndReset(ExprState *state, ExprContext *econtext)
{
 _Bool ret = ExecQual(state, econtext);


 MemoryContextReset(econtext->ecxt_per_tuple_memory);
 return ret;
}


extern _Bool ExecCheck(ExprState *state, ExprContext *context);




extern SetExprState *ExecInitTableFunctionResult(Expr *expr,
             ExprContext *econtext, PlanState *parent);
extern Tuplestorestate *ExecMakeTableFunctionResult(SetExprState *setexpr,
             ExprContext *econtext,
             MemoryContext argContext,
             TupleDesc expectedDesc,
             _Bool randomAccess);
extern SetExprState *ExecInitFunctionResultSet(Expr *expr,
              ExprContext *econtext, PlanState *parent);
extern Datum ExecMakeFunctionResultSet(SetExprState *fcache,
            ExprContext *econtext,
            MemoryContext argContext,
            _Bool *isNull,
            ExprDoneCond *isDone);




typedef TupleTableSlot *(*ExecScanAccessMtd) (ScanState *node);
typedef _Bool (*ExecScanRecheckMtd) (ScanState *node, TupleTableSlot *slot);

extern TupleTableSlot *ExecScan(ScanState *node, ExecScanAccessMtd accessMtd,
        ExecScanRecheckMtd recheckMtd);
extern void ExecAssignScanProjectionInfo(ScanState *node);
extern void ExecAssignScanProjectionInfoWithVarno(ScanState *node, Index varno);
extern void ExecScanReScan(ScanState *node);




extern void ExecInitResultTypeTL(PlanState *planstate);
extern void ExecInitResultSlot(PlanState *planstate,
          const TupleTableSlotOps *tts_ops);
extern void ExecInitResultTupleSlotTL(PlanState *planstate,
           const TupleTableSlotOps *tts_ops);
extern void ExecInitScanTupleSlot(EState *estate, ScanState *scanstate,
          TupleDesc tupleDesc,
          const TupleTableSlotOps *tts_ops);
extern TupleTableSlot *ExecInitExtraTupleSlot(EState *estate,
             TupleDesc tupledesc,
             const TupleTableSlotOps *tts_ops);
extern TupleTableSlot *ExecInitNullTupleSlot(EState *estate, TupleDesc tupType,
            const TupleTableSlotOps *tts_ops);
extern TupleDesc ExecTypeFromTL(List *targetList);
extern TupleDesc ExecCleanTypeFromTL(List *targetList);
extern TupleDesc ExecTypeFromExprList(List *exprList);
extern void ExecTypeSetColNames(TupleDesc typeInfo, List *namesList);
extern void UpdateChangedParamSet(PlanState *node, Bitmapset *newchg);

typedef struct TupOutputState
{
 TupleTableSlot *slot;
 DestReceiver *dest;
} TupOutputState;

extern TupOutputState *begin_tup_output_tupdesc(DestReceiver *dest,
            TupleDesc tupdesc,
            const TupleTableSlotOps *tts_ops);
extern void do_tup_output(TupOutputState *tstate, Datum *values, _Bool *isnull);
extern void do_text_output_multiline(TupOutputState *tstate, const char *txt);
extern void end_tup_output(TupOutputState *tstate);
# 487 "/products1/postgres/PG12.1/include/server/executor/executor.h"
extern EState *CreateExecutorState(void);
extern void FreeExecutorState(EState *estate);
extern ExprContext *CreateExprContext(EState *estate);
extern ExprContext *CreateStandaloneExprContext(void);
extern void FreeExprContext(ExprContext *econtext, _Bool isCommit);
extern void ReScanExprContext(ExprContext *econtext);




extern ExprContext *MakePerTupleExprContext(EState *estate);
# 515 "/products1/postgres/PG12.1/include/server/executor/executor.h"
extern void ExecAssignExprContext(EState *estate, PlanState *planstate);
extern TupleDesc ExecGetResultType(PlanState *planstate);
extern const TupleTableSlotOps *ExecGetResultSlotOps(PlanState *planstate,
              _Bool *isfixed);
extern void ExecAssignProjectionInfo(PlanState *planstate,
          TupleDesc inputDesc);
extern void ExecConditionalAssignProjectionInfo(PlanState *planstate,
            TupleDesc inputDesc, Index varno);
extern void ExecFreeExprContext(PlanState *planstate);
extern void ExecAssignScanType(ScanState *scanstate, TupleDesc tupDesc);
extern void ExecCreateScanSlotFromOuterPlan(EState *estate,
           ScanState *scanstate,
           const TupleTableSlotOps *tts_ops);

extern _Bool ExecRelationIsTargetRelation(EState *estate, Index scanrelid);

extern Relation ExecOpenScanRelation(EState *estate, Index scanrelid, int eflags);

extern void ExecInitRangeTable(EState *estate, List *rangeTable);

static inline RangeTblEntry *
exec_rt_fetch(Index rti, EState *estate)
{
 ((void)1);
 return estate->es_range_table_array[rti - 1];
}

extern Relation ExecGetRangeTableRelation(EState *estate, Index rti);

extern int executor_errposition(EState *estate, int location);

extern void RegisterExprContextCallback(ExprContext *econtext,
          ExprContextCallbackFunction function,
          Datum arg);
extern void UnregisterExprContextCallback(ExprContext *econtext,
            ExprContextCallbackFunction function,
            Datum arg);

extern Datum GetAttributeByName(HeapTupleHeader tuple, const char *attname,
        _Bool *isNull);
extern Datum GetAttributeByNum(HeapTupleHeader tuple, AttrNumber attrno,
          _Bool *isNull);

extern int ExecTargetListLength(List *targetlist);
extern int ExecCleanTargetListLength(List *targetlist);

extern TupleTableSlot *ExecGetTriggerOldSlot(EState *estate, ResultRelInfo *relInfo);
extern TupleTableSlot *ExecGetTriggerNewSlot(EState *estate, ResultRelInfo *relInfo);
extern TupleTableSlot *ExecGetReturningSlot(EState *estate, ResultRelInfo *relInfo);




extern void ExecOpenIndices(ResultRelInfo *resultRelInfo, _Bool speculative);
extern void ExecCloseIndices(ResultRelInfo *resultRelInfo);
extern List *ExecInsertIndexTuples(TupleTableSlot *slot, EState *estate, _Bool noDupErr,
           _Bool *specConflict, List *arbiterIndexes);
extern _Bool ExecCheckIndexConstraints(TupleTableSlot *slot, EState *estate,
           ItemPointer conflictTid, List *arbiterIndexes);
extern void check_exclusion_constraint(Relation heap, Relation index,
            IndexInfo *indexInfo,
            ItemPointer tupleid,
            Datum *values, _Bool *isnull,
            EState *estate, _Bool newIndex);




extern _Bool RelationFindReplTupleByIndex(Relation rel, Oid idxoid,
           LockTupleMode lockmode,
           TupleTableSlot *searchslot,
           TupleTableSlot *outslot);
extern _Bool RelationFindReplTupleSeq(Relation rel, LockTupleMode lockmode,
          TupleTableSlot *searchslot, TupleTableSlot *outslot);

extern void ExecSimpleRelationInsert(EState *estate, TupleTableSlot *slot);
extern void ExecSimpleRelationUpdate(EState *estate, EPQState *epqstate,
          TupleTableSlot *searchslot, TupleTableSlot *slot);
extern void ExecSimpleRelationDelete(EState *estate, EPQState *epqstate,
          TupleTableSlot *searchslot);
extern void CheckCmdReplicaIdentity(Relation rel, CmdType cmd);

extern void CheckSubscriptionRelkind(char relkind, const char *nspname,
          const char *relname);
# 17 "/products1/postgres/PG12.1/include/server/commands/explain.h" 2



typedef enum ExplainFormat
{
 EXPLAIN_FORMAT_TEXT,
 EXPLAIN_FORMAT_XML,
 EXPLAIN_FORMAT_JSON,
 EXPLAIN_FORMAT_YAML
} ExplainFormat;

typedef struct ExplainState
{
 StringInfo str;

 _Bool verbose;
 _Bool analyze;
 _Bool costs;
 _Bool buffers;
 _Bool timing;
 _Bool summary;
 _Bool settings;
 ExplainFormat format;

 int indent;
 List *grouping_stack;

 PlannedStmt *pstmt;
 List *rtable;
 List *rtable_names;
 List *deparse_cxt;
 Bitmapset *printed_subplans;
} ExplainState;


typedef void (*ExplainOneQuery_hook_type) (Query *query,
             int cursorOptions,
             IntoClause *into,
             ExplainState *es,
             const char *queryString,
             ParamListInfo params,
             QueryEnvironment *queryEnv);
extern ExplainOneQuery_hook_type ExplainOneQuery_hook;


typedef const char *(*explain_get_index_name_hook_type) (Oid indexId);
extern explain_get_index_name_hook_type explain_get_index_name_hook;


extern void ExplainQuery(ParseState *pstate, ExplainStmt *stmt, const char *queryString,
       ParamListInfo params, QueryEnvironment *queryEnv, DestReceiver *dest);

extern ExplainState *NewExplainState(void);

extern TupleDesc ExplainResultDesc(ExplainStmt *stmt);

extern void ExplainOneUtility(Node *utilityStmt, IntoClause *into,
         ExplainState *es, const char *queryString,
         ParamListInfo params, QueryEnvironment *queryEnv);

extern void ExplainOnePlan(PlannedStmt *plannedstmt, IntoClause *into,
         ExplainState *es, const char *queryString,
         ParamListInfo params, QueryEnvironment *queryEnv,
         const instr_time *planduration);

extern void ExplainPrintPlan(ExplainState *es, QueryDesc *queryDesc);
extern void ExplainPrintTriggers(ExplainState *es, QueryDesc *queryDesc);

extern void ExplainPrintJITSummary(ExplainState *es, QueryDesc *queryDesc);
extern void ExplainPrintJIT(ExplainState *es, int jit_flags,
       struct JitInstrumentation *jit_instr, int worker_i);

extern void ExplainQueryText(ExplainState *es, QueryDesc *queryDesc);

extern void ExplainBeginOutput(ExplainState *es);
extern void ExplainEndOutput(ExplainState *es);
extern void ExplainSeparatePlans(ExplainState *es);

extern void ExplainPropertyList(const char *qlabel, List *data,
        ExplainState *es);
extern void ExplainPropertyListNested(const char *qlabel, List *data,
           ExplainState *es);
extern void ExplainPropertyText(const char *qlabel, const char *value,
        ExplainState *es);
extern void ExplainPropertyInteger(const char *qlabel, const char *unit,
           int64 value, ExplainState *es);
extern void ExplainPropertyFloat(const char *qlabel, const char *unit,
         double value, int ndigits, ExplainState *es);
extern void ExplainPropertyBool(const char *qlabel, _Bool value,
        ExplainState *es);

extern void ExplainOpenGroup(const char *objtype, const char *labelname,
        _Bool labeled, ExplainState *es);
extern void ExplainCloseGroup(const char *objtype, const char *labelname,
         _Bool labeled, ExplainState *es);
# 29 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/commands/vacuum.h" 1
# 18 "/products1/postgres/PG12.1/include/server/commands/vacuum.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_class.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_class.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_class_d.h" 1
# 23 "/products1/postgres/PG12.1/include/server/catalog/pg_class.h" 2






typedef struct FormData_pg_class
{

 Oid oid;


 NameData relname;


 Oid relnamespace ;


 Oid reltype ;


 Oid reloftype ;


 Oid relowner ;


 Oid relam ;



 Oid relfilenode;


 Oid reltablespace ;


 int32 relpages;


 float4 reltuples;


 int32 relallvisible;


 Oid reltoastrelid;


 _Bool relhasindex;


 _Bool relisshared;


 char relpersistence;


 char relkind;


 int16 relnatts;
# 93 "/products1/postgres/PG12.1/include/server/catalog/pg_class.h"
 int16 relchecks;


 _Bool relhasrules;


 _Bool relhastriggers;


 _Bool relhassubclass;


 _Bool relrowsecurity;


 _Bool relforcerowsecurity;


 _Bool relispopulated;


 char relreplident;


 _Bool relispartition;


 Oid relrewrite ;


 TransactionId relfrozenxid;


 TransactionId relminmxid;
# 139 "/products1/postgres/PG12.1/include/server/catalog/pg_class.h"
} FormData_pg_class;
# 150 "/products1/postgres/PG12.1/include/server/catalog/pg_class.h"
typedef FormData_pg_class *Form_pg_class;
# 19 "/products1/postgres/PG12.1/include/server/commands/vacuum.h" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_statistic.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_statistic.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_statistic_d.h" 1
# 23 "/products1/postgres/PG12.1/include/server/catalog/pg_statistic.h" 2






typedef struct FormData_pg_statistic
{

 Oid starelid;
 int16 staattnum;
 _Bool stainherit;


 float4 stanullfrac;
# 49 "/products1/postgres/PG12.1/include/server/catalog/pg_statistic.h"
 int32 stawidth;
# 68 "/products1/postgres/PG12.1/include/server/catalog/pg_statistic.h"
 float4 stadistinct;
# 87 "/products1/postgres/PG12.1/include/server/catalog/pg_statistic.h"
 int16 stakind1;
 int16 stakind2;
 int16 stakind3;
 int16 stakind4;
 int16 stakind5;

 Oid staop1;
 Oid staop2;
 Oid staop3;
 Oid staop4;
 Oid staop5;

 Oid stacoll1;
 Oid stacoll2;
 Oid stacoll3;
 Oid stacoll4;
 Oid stacoll5;
# 124 "/products1/postgres/PG12.1/include/server/catalog/pg_statistic.h"
} FormData_pg_statistic;
# 134 "/products1/postgres/PG12.1/include/server/catalog/pg_statistic.h"
typedef FormData_pg_statistic *Form_pg_statistic;
# 20 "/products1/postgres/PG12.1/include/server/commands/vacuum.h" 2
# 62 "/products1/postgres/PG12.1/include/server/commands/vacuum.h"
typedef struct VacAttrStats *VacAttrStatsP;

typedef Datum (*AnalyzeAttrFetchFunc) (VacAttrStatsP stats, int rownum,
            _Bool *isNull);

typedef void (*AnalyzeAttrComputeStatsFunc) (VacAttrStatsP stats,
            AnalyzeAttrFetchFunc fetchfunc,
            int samplerows,
            double totalrows);

typedef struct VacAttrStats
{
# 85 "/products1/postgres/PG12.1/include/server/commands/vacuum.h"
 Form_pg_attribute attr;
 Oid attrtypid;
 int32 attrtypmod;
 Form_pg_type attrtype;
 Oid attrcollid;
 MemoryContext anl_context;





 AnalyzeAttrComputeStatsFunc compute_stats;
 int minrows;
 void *extra_data;





 _Bool stats_valid;
 float4 stanullfrac;
 int32 stawidth;
 float4 stadistinct;
 int16 stakind[5];
 Oid staop[5];
 Oid stacoll[5];
 int numnumbers[5];
 float4 *stanumbers[5];
 int numvalues[5];
 Datum *stavalues[5];







 Oid statypid[5];
 int16 statyplen[5];
 _Bool statypbyval[5];
 char statypalign[5];





 int tupattnum;
 HeapTuple *rows;
 TupleDesc tupDesc;
 Datum *exprvals;
 _Bool *exprnulls;
 int rowstride;
} VacAttrStats;

typedef enum VacuumOption
{
 VACOPT_VACUUM = 1 << 0,
 VACOPT_ANALYZE = 1 << 1,
 VACOPT_VERBOSE = 1 << 2,
 VACOPT_FREEZE = 1 << 3,
 VACOPT_FULL = 1 << 4,
 VACOPT_SKIP_LOCKED = 1 << 5,
 VACOPT_SKIPTOAST = 1 << 6,
 VACOPT_DISABLE_PAGE_SKIPPING = 1 << 7
} VacuumOption;







typedef enum VacOptTernaryValue
{
 VACOPT_TERNARY_DEFAULT = 0,
 VACOPT_TERNARY_DISABLED,
 VACOPT_TERNARY_ENABLED,
} VacOptTernaryValue;







typedef struct VacuumParams
{
 int options;
 int freeze_min_age;
 int freeze_table_age;
 int multixact_freeze_min_age;

 int multixact_freeze_table_age;

 _Bool is_wraparound;
 int log_min_duration;


 VacOptTernaryValue index_cleanup;

 VacOptTernaryValue truncate;

} VacuumParams;


extern int default_statistics_target;
extern int vacuum_freeze_min_age;
extern int vacuum_freeze_table_age;
extern int vacuum_multixact_freeze_min_age;
extern int vacuum_multixact_freeze_table_age;



extern void ExecVacuum(ParseState *pstate, VacuumStmt *vacstmt, _Bool isTopLevel);
extern void vacuum(List *relations, VacuumParams *params,
       BufferAccessStrategy bstrategy, _Bool isTopLevel);
extern void vac_open_indexes(Relation relation, LOCKMODE lockmode,
        int *nindexes, Relation **Irel);
extern void vac_close_indexes(int nindexes, Relation *Irel, LOCKMODE lockmode);
extern double vac_estimate_reltuples(Relation relation,
          BlockNumber total_pages,
          BlockNumber scanned_pages,
          double scanned_tuples);
extern void vac_update_relstats(Relation relation,
        BlockNumber num_pages,
        double num_tuples,
        BlockNumber num_all_visible_pages,
        _Bool hasindex,
        TransactionId frozenxid,
        MultiXactId minmulti,
        _Bool in_outer_xact);
extern void vacuum_set_xid_limits(Relation rel,
          int freeze_min_age, int freeze_table_age,
          int multixact_freeze_min_age,
          int multixact_freeze_table_age,
          TransactionId *oldestXmin,
          TransactionId *freezeLimit,
          TransactionId *xidFullScanLimit,
          MultiXactId *multiXactCutoff,
          MultiXactId *mxactFullScanLimit);
extern void vac_update_datfrozenxid(void);
extern void vacuum_delay_point(void);
extern _Bool vacuum_is_relation_owner(Oid relid, Form_pg_class reltuple,
          int options);
extern Relation vacuum_open_relation(Oid relid, RangeVar *relation,
          int options, _Bool verbose, LOCKMODE lmode);


extern void analyze_rel(Oid relid, RangeVar *relation,
      VacuumParams *params, List *va_cols, _Bool in_outer_xact,
      BufferAccessStrategy bstrategy);
extern _Bool std_typanalyze(VacAttrStats *stats);


extern double anl_random_fract(void);
extern double anl_init_selection_state(int n);
extern double anl_get_next_S(double t, int n, double *stateptr);
# 30 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/foreign/fdwapi.h" 1
# 15 "/products1/postgres/PG12.1/include/server/foreign/fdwapi.h"
# 1 "/products1/postgres/PG12.1/include/server/access/parallel.h" 1
# 18 "/products1/postgres/PG12.1/include/server/access/parallel.h"
# 1 "/products1/postgres/PG12.1/include/server/lib/ilist.h" 1
# 120 "/products1/postgres/PG12.1/include/server/lib/ilist.h"
typedef struct dlist_node dlist_node;
struct dlist_node
{
 dlist_node *prev;
 dlist_node *next;
};
# 135 "/products1/postgres/PG12.1/include/server/lib/ilist.h"
typedef struct dlist_head
{







 dlist_node head;
} dlist_head;
# 159 "/products1/postgres/PG12.1/include/server/lib/ilist.h"
typedef struct dlist_iter
{
 dlist_node *cur;
 dlist_node *end;
} dlist_iter;
# 178 "/products1/postgres/PG12.1/include/server/lib/ilist.h"
typedef struct dlist_mutable_iter
{
 dlist_node *cur;
 dlist_node *next;
 dlist_node *end;
} dlist_mutable_iter;






typedef struct slist_node slist_node;
struct slist_node
{
 slist_node *next;
};
# 203 "/products1/postgres/PG12.1/include/server/lib/ilist.h"
typedef struct slist_head
{
 slist_node head;
} slist_head;
# 224 "/products1/postgres/PG12.1/include/server/lib/ilist.h"
typedef struct slist_iter
{
 slist_node *cur;
} slist_iter;
# 239 "/products1/postgres/PG12.1/include/server/lib/ilist.h"
typedef struct slist_mutable_iter
{
 slist_node *cur;
 slist_node *next;
 slist_node *prev;
} slist_mutable_iter;
# 255 "/products1/postgres/PG12.1/include/server/lib/ilist.h"
extern void slist_delete(slist_head *head, slist_node *node);
# 277 "/products1/postgres/PG12.1/include/server/lib/ilist.h"
static inline void
dlist_init(dlist_head *head)
{
 head->head.next = head->head.prev = &head->head;
}






static inline _Bool
dlist_is_empty(dlist_head *head)
{
 ((void) (head));

 return head->head.next == ((void *)0) || head->head.next == &(head->head);
}




static inline void
dlist_push_head(dlist_head *head, dlist_node *node)
{
 if (head->head.next == ((void *)0))
  dlist_init(head);

 node->next = head->head.next;
 node->prev = &head->head;
 node->next->prev = node;
 head->head.next = node;

 ((void) (head));
}




static inline void
dlist_push_tail(dlist_head *head, dlist_node *node)
{
 if (head->head.next == ((void *)0))
  dlist_init(head);

 node->next = &head->head;
 node->prev = head->head.prev;
 node->prev->next = node;
 head->head.prev = node;

 ((void) (head));
}




static inline void
dlist_insert_after(dlist_node *after, dlist_node *node)
{
 node->prev = after;
 node->next = after->next;
 after->next = node;
 node->next->prev = node;
}




static inline void
dlist_insert_before(dlist_node *before, dlist_node *node)
{
 node->prev = before->prev;
 node->next = before;
 before->prev = node;
 node->prev->next = node;
}




static inline void
dlist_delete(dlist_node *node)
{
 node->prev->next = node->next;
 node->next->prev = node->prev;
}




static inline dlist_node *
dlist_pop_head_node(dlist_head *head)
{
 dlist_node *node;

 ((void)1);
 node = head->head.next;
 dlist_delete(node);
 return node;
}







static inline void
dlist_move_head(dlist_head *head, dlist_node *node)
{

 if (head->head.next == node)
  return;

 dlist_delete(node);
 dlist_push_head(head, node);

 ((void) (head));
}





static inline _Bool
dlist_has_next(dlist_head *head, dlist_node *node)
{
 return node->next != &head->head;
}





static inline _Bool
dlist_has_prev(dlist_head *head, dlist_node *node)
{
 return node->prev != &head->head;
}




static inline dlist_node *
dlist_next_node(dlist_head *head, dlist_node *node)
{
 ((void)1);
 return node->next;
}




static inline dlist_node *
dlist_prev_node(dlist_head *head, dlist_node *node)
{
 ((void)1);
 return node->prev;
}


static inline void *
dlist_head_element_off(dlist_head *head, size_t off)
{
 ((void)1);
 return (char *) head->head.next - off;
}




static inline dlist_node *
dlist_head_node(dlist_head *head)
{
 return (dlist_node *) dlist_head_element_off(head, 0);
}


static inline void *
dlist_tail_element_off(dlist_head *head, size_t off)
{
 ((void)1);
 return (char *) head->head.prev - off;
}




static inline dlist_node *
dlist_tail_node(dlist_head *head)
{
 return (dlist_node *) dlist_tail_element_off(head, 0);
}
# 553 "/products1/postgres/PG12.1/include/server/lib/ilist.h"
static inline void
slist_init(slist_head *head)
{
 head->head.next = ((void *)0);
}




static inline _Bool
slist_is_empty(slist_head *head)
{
 ((void) (head));

 return head->head.next == ((void *)0);
}




static inline void
slist_push_head(slist_head *head, slist_node *node)
{
 node->next = head->head.next;
 head->head.next = node;

 ((void) (head));
}




static inline void
slist_insert_after(slist_node *after, slist_node *node)
{
 node->next = after->next;
 after->next = node;
}




static inline slist_node *
slist_pop_head_node(slist_head *head)
{
 slist_node *node;

 ((void)1);
 node = head->head.next;
 head->head.next = node->next;
 ((void) (head));
 return node;
}




static inline _Bool
slist_has_next(slist_head *head, slist_node *node)
{
 ((void) (head));

 return node->next != ((void *)0);
}




static inline slist_node *
slist_next_node(slist_head *head, slist_node *node)
{
 ((void)1);
 return node->next;
}


static inline void *
slist_head_element_off(slist_head *head, size_t off)
{
 ((void)1);
 return (char *) head->head.next - off;
}




static inline slist_node *
slist_head_node(slist_head *head)
{
 return (slist_node *) slist_head_element_off(head, 0);
}







static inline void
slist_delete_current(slist_mutable_iter *iter)
{





 iter->prev->next = iter->next;





 iter->cur = iter->prev;
}
# 19 "/products1/postgres/PG12.1/include/server/access/parallel.h" 2
# 1 "/products1/postgres/PG12.1/include/server/postmaster/bgworker.h" 1
# 71 "/products1/postgres/PG12.1/include/server/postmaster/bgworker.h"
typedef void (*bgworker_main_type) (Datum main_arg);




typedef enum
{
 BgWorkerStart_PostmasterStart,
 BgWorkerStart_ConsistentState,
 BgWorkerStart_RecoveryFinished
} BgWorkerStartTime;






typedef struct BackgroundWorker
{
 char bgw_name[96];
 char bgw_type[96];
 int bgw_flags;
 BgWorkerStartTime bgw_start_time;
 int bgw_restart_time;
 char bgw_library_name[96];
 char bgw_function_name[96];
 Datum bgw_main_arg;
 char bgw_extra[128];
 pid_t bgw_notify_pid;
} BackgroundWorker;

typedef enum BgwHandleStatus
{
 BGWH_STARTED,
 BGWH_NOT_YET_STARTED,
 BGWH_STOPPED,
 BGWH_POSTMASTER_DIED
} BgwHandleStatus;

struct BackgroundWorkerHandle;
typedef struct BackgroundWorkerHandle BackgroundWorkerHandle;


extern void RegisterBackgroundWorker(BackgroundWorker *worker);


extern _Bool RegisterDynamicBackgroundWorker(BackgroundWorker *worker,
           BackgroundWorkerHandle **handle);


extern BgwHandleStatus GetBackgroundWorkerPid(BackgroundWorkerHandle *handle,
             pid_t *pidp);
extern BgwHandleStatus WaitForBackgroundWorkerStartup(BackgroundWorkerHandle *handle, pid_t *pid);
extern BgwHandleStatus
   WaitForBackgroundWorkerShutdown(BackgroundWorkerHandle *);
extern const char *GetBackgroundWorkerTypeByPid(pid_t pid);


extern void TerminateBackgroundWorker(BackgroundWorkerHandle *handle);


extern BackgroundWorker *MyBgworkerEntry;
# 143 "/products1/postgres/PG12.1/include/server/postmaster/bgworker.h"
extern void BackgroundWorkerInitializeConnection(const char *dbname, const char *username, uint32 flags);


extern void BackgroundWorkerInitializeConnectionByOid(Oid dboid, Oid useroid, uint32 flags);
# 158 "/products1/postgres/PG12.1/include/server/postmaster/bgworker.h"
extern void BackgroundWorkerBlockSignals(void);
extern void BackgroundWorkerUnblockSignals(void);
# 20 "/products1/postgres/PG12.1/include/server/access/parallel.h" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/shm_mq.h" 1
# 18 "/products1/postgres/PG12.1/include/server/storage/shm_mq.h"
# 1 "/products1/postgres/PG12.1/include/server/storage/proc.h" 1
# 17 "/products1/postgres/PG12.1/include/server/storage/proc.h"
# 1 "/products1/postgres/PG12.1/include/server/access/clog.h" 1
# 24 "/products1/postgres/PG12.1/include/server/access/clog.h"
typedef int XidStatus;






typedef struct xl_clog_truncate
{
 int pageno;
 TransactionId oldestXact;
 Oid oldestXactDb;
} xl_clog_truncate;

extern void TransactionIdSetTreeStatus(TransactionId xid, int nsubxids,
            TransactionId *subxids, XidStatus status, XLogRecPtr lsn);
extern XidStatus TransactionIdGetStatus(TransactionId xid, XLogRecPtr *lsn);

extern Size CLOGShmemBuffers(void);
extern Size CLOGShmemSize(void);
extern void CLOGShmemInit(void);
extern void BootStrapCLOG(void);
extern void StartupCLOG(void);
extern void TrimCLOG(void);
extern void ShutdownCLOG(void);
extern void CheckPointCLOG(void);
extern void ExtendCLOG(TransactionId newestXact);
extern void TruncateCLOG(TransactionId oldestXact, Oid oldestxid_datoid);





extern void clog_redo(XLogReaderState *record);
extern void clog_desc(StringInfo buf, XLogReaderState *record);
extern const char *clog_identify(uint8 info);
# 18 "/products1/postgres/PG12.1/include/server/storage/proc.h" 2


# 1 "/products1/postgres/PG12.1/include/server/storage/latch.h" 1
# 110 "/products1/postgres/PG12.1/include/server/storage/latch.h"
typedef struct Latch
{
 sig_atomic_t is_set;
 _Bool is_shared;
 int owner_pid;



} Latch;
# 141 "/products1/postgres/PG12.1/include/server/storage/latch.h"
typedef struct WaitEvent
{
 int pos;
 uint32 events;
 pgsocket fd;
 void *user_data;



} WaitEvent;


typedef struct WaitEventSet WaitEventSet;




extern void InitializeLatchSupport(void);
extern void InitLatch(Latch *latch);
extern void InitSharedLatch(Latch *latch);
extern void OwnLatch(Latch *latch);
extern void DisownLatch(Latch *latch);
extern void SetLatch(Latch *latch);
extern void ResetLatch(Latch *latch);

extern WaitEventSet *CreateWaitEventSet(MemoryContext context, int nevents);
extern void FreeWaitEventSet(WaitEventSet *set);
extern int AddWaitEventToSet(WaitEventSet *set, uint32 events, pgsocket fd,
         Latch *latch, void *user_data);
extern void ModifyWaitEvent(WaitEventSet *set, int pos, uint32 events, Latch *latch);

extern int WaitEventSetWait(WaitEventSet *set, long timeout,
        WaitEvent *occurred_events, int nevents,
        uint32 wait_event_info);
extern int WaitLatch(Latch *latch, int wakeEvents, long timeout,
       uint32 wait_event_info);
extern int WaitLatchOrSocket(Latch *latch, int wakeEvents,
         pgsocket sock, long timeout, uint32 wait_event_info);






extern void latch_sigusr1_handler(void);
# 21 "/products1/postgres/PG12.1/include/server/storage/proc.h" 2

# 1 "/products1/postgres/PG12.1/include/server/storage/pg_sema.h" 1
# 34 "/products1/postgres/PG12.1/include/server/storage/pg_sema.h"
typedef struct PGSemaphoreData *PGSemaphore;






extern Size PGSemaphoreShmemSize(int maxSemas);


extern void PGReserveSemaphores(int maxSemas, int port);


extern PGSemaphore PGSemaphoreCreate(void);


extern void PGSemaphoreReset(PGSemaphore sema);


extern void PGSemaphoreLock(PGSemaphore sema);


extern void PGSemaphoreUnlock(PGSemaphore sema);


extern _Bool PGSemaphoreTryLock(PGSemaphore sema);
# 23 "/products1/postgres/PG12.1/include/server/storage/proc.h" 2
# 38 "/products1/postgres/PG12.1/include/server/storage/proc.h"
struct XidCache
{
 TransactionId xids[64];
};
# 95 "/products1/postgres/PG12.1/include/server/storage/proc.h"
struct PGPROC
{

 SHM_QUEUE links;
 PGPROC **procgloballist;

 PGSemaphore sem;
 int waitStatus;

 Latch procLatch;

 LocalTransactionId lxid;


 int pid;
 int pgprocno;


 BackendId backendId;
 Oid databaseId;
 Oid roleId;

 Oid tempNamespaceId;


 _Bool isBackgroundWorker;






 _Bool recoveryConflictPending;


 _Bool lwWaiting;
 uint8 lwWaitMode;
 proclist_node lwWaitLink;


 proclist_node cvWaitLink;



 LOCK *waitLock;
 PROCLOCK *waitProcLock;
 LOCKMODE waitLockMode;
 LOCKMASK heldLocks;
# 151 "/products1/postgres/PG12.1/include/server/storage/proc.h"
 XLogRecPtr waitLSN;
 int syncRepState;
 SHM_QUEUE syncRepLinks;






 SHM_QUEUE myProcLocks[(1 << 4)];

 struct XidCache subxids;



 _Bool procArrayGroupMember;

 pg_atomic_uint32 procArrayGroupNext;





 TransactionId procArrayGroupMemberXid;

 uint32 wait_event_info;


 _Bool clogGroupMember;
 pg_atomic_uint32 clogGroupNext;
 TransactionId clogGroupMemberXid;
 XidStatus clogGroupMemberXidStatus;

 int clogGroupMemberPage;

 XLogRecPtr clogGroupMemberLsn;



 LWLock backendLock;


 uint64 fpLockBits;
 Oid fpRelId[16];
 _Bool fpVXIDLock;
 LocalTransactionId fpLocalTransactionId;






 PGPROC *lockGroupLeader;
 dlist_head lockGroupMembers;
 dlist_node lockGroupLink;
};




extern PGPROC *MyProc;
extern struct PGXACT *MyPgXact;
# 222 "/products1/postgres/PG12.1/include/server/storage/proc.h"
typedef struct PGXACT
{
 TransactionId xid;



 TransactionId xmin;




 uint8 vacuumFlags;
 _Bool overflowed;
 _Bool delayChkpt;


 uint8 nxids;
} PGXACT;




typedef struct PROC_HDR
{

 PGPROC *allProcs;

 PGXACT *allPgXact;

 uint32 allProcCount;

 PGPROC *freeProcs;

 PGPROC *autovacFreeProcs;

 PGPROC *bgworkerFreeProcs;

 PGPROC *walsenderFreeProcs;

 pg_atomic_uint32 procArrayGroupFirst;

 pg_atomic_uint32 clogGroupFirst;

 Latch *walwriterLatch;

 Latch *checkpointerLatch;

 int spins_per_delay;

 PGPROC *startupProc;
 int startupProcPid;

 int startupBufferPinWaitBufId;
} PROC_HDR;

extern PROC_HDR *ProcGlobal;

extern PGPROC *PreparedXactProcs;
# 295 "/products1/postgres/PG12.1/include/server/storage/proc.h"
extern int DeadlockTimeout;
extern int StatementTimeout;
extern int LockTimeout;
extern int IdleInTransactionSessionTimeout;
extern _Bool log_lock_waits;





extern int ProcGlobalSemas(void);
extern Size ProcGlobalShmemSize(void);
extern void InitProcGlobal(void);
extern void InitProcess(void);
extern void InitProcessPhase2(void);
extern void InitAuxiliaryProcess(void);

extern void PublishStartupProcessInformation(void);
extern void SetStartupBufferPinWaitBufId(int bufid);
extern int GetStartupBufferPinWaitBufId(void);

extern _Bool HaveNFreeProcs(int n);
extern void ProcReleaseLocks(_Bool isCommit);

extern void ProcQueueInit(PROC_QUEUE *queue);
extern int ProcSleep(LOCALLOCK *locallock, LockMethod lockMethodTable);
extern PGPROC *ProcWakeup(PGPROC *proc, int waitStatus);
extern void ProcLockWakeup(LockMethod lockMethodTable, LOCK *lock);
extern void CheckDeadLockAlert(void);
extern _Bool IsWaitingForLock(void);
extern void LockErrorCleanup(void);

extern void ProcWaitForSignal(uint32 wait_event_info);
extern void ProcSendSignal(int pid);

extern PGPROC *AuxiliaryPidGetProc(int pid);

extern void BecomeLockGroupLeader(void);
extern _Bool BecomeLockGroupMember(PGPROC *leader, int pid);
# 19 "/products1/postgres/PG12.1/include/server/storage/shm_mq.h" 2


struct shm_mq;
typedef struct shm_mq shm_mq;


struct shm_mq_handle;
typedef struct shm_mq_handle shm_mq_handle;


typedef struct
{
 const char *data;
 Size len;
} shm_mq_iovec;


typedef enum
{
 SHM_MQ_SUCCESS,
 SHM_MQ_WOULD_BLOCK,
 SHM_MQ_DETACHED
} shm_mq_result;
# 50 "/products1/postgres/PG12.1/include/server/storage/shm_mq.h"
extern shm_mq *shm_mq_create(void *address, Size size);
extern void shm_mq_set_receiver(shm_mq *mq, PGPROC *);
extern void shm_mq_set_sender(shm_mq *mq, PGPROC *);


extern PGPROC *shm_mq_get_receiver(shm_mq *);
extern PGPROC *shm_mq_get_sender(shm_mq *);


extern shm_mq_handle *shm_mq_attach(shm_mq *mq, dsm_segment *seg,
         BackgroundWorkerHandle *handle);


extern void shm_mq_set_handle(shm_mq_handle *, BackgroundWorkerHandle *);


extern void shm_mq_detach(shm_mq_handle *mqh);


extern shm_mq *shm_mq_get_queue(shm_mq_handle *mqh);


extern shm_mq_result shm_mq_send(shm_mq_handle *mqh,
         Size nbytes, const void *data, _Bool nowait);
extern shm_mq_result shm_mq_sendv(shm_mq_handle *mqh,
          shm_mq_iovec *iov, int iovcnt, _Bool nowait);
extern shm_mq_result shm_mq_receive(shm_mq_handle *mqh,
         Size *nbytesp, void **datap, _Bool nowait);


extern shm_mq_result shm_mq_wait_for_attach(shm_mq_handle *mqh);


extern const Size shm_mq_minimum_size;
# 21 "/products1/postgres/PG12.1/include/server/access/parallel.h" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/shm_toc.h" 1
# 28 "/products1/postgres/PG12.1/include/server/storage/shm_toc.h"
typedef struct shm_toc shm_toc;

extern shm_toc *shm_toc_create(uint64 magic, void *address, Size nbytes);
extern shm_toc *shm_toc_attach(uint64 magic, void *address);
extern void *shm_toc_allocate(shm_toc *toc, Size nbytes);
extern Size shm_toc_freespace(shm_toc *toc);
extern void shm_toc_insert(shm_toc *toc, uint64 key, void *address);
extern void *shm_toc_lookup(shm_toc *toc, uint64 key, _Bool noError);







typedef struct
{
 Size space_for_chunks;
 Size number_of_keys;
} shm_toc_estimator;
# 56 "/products1/postgres/PG12.1/include/server/storage/shm_toc.h"
extern Size shm_toc_estimate(shm_toc_estimator *e);
# 22 "/products1/postgres/PG12.1/include/server/access/parallel.h" 2

typedef void (*parallel_worker_main_type) (dsm_segment *seg, shm_toc *toc);

typedef struct ParallelWorkerInfo
{
 BackgroundWorkerHandle *bgwhandle;
 shm_mq_handle *error_mqh;
 int32 pid;
} ParallelWorkerInfo;

typedef struct ParallelContext
{
 dlist_node node;
 SubTransactionId subid;
 int nworkers;
 int nworkers_launched;
 char *library_name;
 char *function_name;
 ErrorContextCallback *error_context_stack;
 shm_toc_estimator estimator;
 dsm_segment *seg;
 void *private_memory;
 shm_toc *toc;
 ParallelWorkerInfo *worker;
 int nknown_attached_workers;
 _Bool *known_attached_workers;
} ParallelContext;

typedef struct ParallelWorkerContext
{
 dsm_segment *seg;
 shm_toc *toc;
} ParallelWorkerContext;

extern volatile _Bool ParallelMessagePending;
extern int ParallelWorkerNumber;
extern _Bool InitializingParallelWorker;



extern ParallelContext *CreateParallelContext(const char *library_name,
             const char *function_name, int nworkers);
extern void InitializeParallelDSM(ParallelContext *pcxt);
extern void ReinitializeParallelDSM(ParallelContext *pcxt);
extern void LaunchParallelWorkers(ParallelContext *pcxt);
extern void WaitForParallelWorkersToAttach(ParallelContext *pcxt);
extern void WaitForParallelWorkersToFinish(ParallelContext *pcxt);
extern void DestroyParallelContext(ParallelContext *pcxt);
extern _Bool ParallelContextActive(void);

extern void HandleParallelMessageInterrupt(void);
extern void HandleParallelMessages(void);
extern void AtEOXact_Parallel(_Bool isCommit);
extern void AtEOSubXact_Parallel(_Bool isCommit, SubTransactionId mySubId);
extern void ParallelWorkerReportLastRecEnd(XLogRecPtr last_xlog_end);

extern void ParallelWorkerMain(Datum main_arg);
# 16 "/products1/postgres/PG12.1/include/server/foreign/fdwapi.h" 2

# 1 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h" 1
# 29 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef Bitmapset *Relids;





typedef enum CostSelector
{
 STARTUP_COST, TOTAL_COST
} CostSelector;





typedef struct QualCost
{
 Cost startup;
 Cost per_tuple;
} QualCost;
# 57 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct AggClauseCosts
{
 int numAggs;
 int numOrderedAggs;
 _Bool hasNonPartial;
 _Bool hasNonSerial;
 QualCost transCost;
 QualCost finalCost;
 Size transitionSpace;
} AggClauseCosts;





typedef enum UpperRelationKind
{
 UPPERREL_SETOP,
 UPPERREL_PARTIAL_GROUP_AGG,

 UPPERREL_GROUP_AGG,
 UPPERREL_WINDOW,
 UPPERREL_DISTINCT,
 UPPERREL_ORDERED,
 UPPERREL_FINAL

} UpperRelationKind;






typedef enum InheritanceKind
{
 INHKIND_NONE,
 INHKIND_INHERITED,
 INHKIND_PARTITIONED
} InheritanceKind;
# 106 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct PlannerGlobal
{
 NodeTag type;

 ParamListInfo boundParams;

 List *subplans;

 List *subroots;

 Bitmapset *rewindPlanIDs;

 List *finalrtable;

 List *finalrowmarks;

 List *resultRelations;

 List *rootResultRelations;

 List *relationOids;

 List *invalItems;

 List *paramExecTypes;

 Index lastPHId;

 Index lastRowMarkId;

 int lastPlanNodeId;

 _Bool transientPlan;

 _Bool dependsOnRole;

 _Bool parallelModeOK;

 _Bool parallelModeNeeded;

 char maxParallelHazard;

 PartitionDirectory partition_directory;
} PlannerGlobal;
# 170 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct PlannerInfo PlannerInfo;



struct PlannerInfo
{
 NodeTag type;

 Query *parse;

 PlannerGlobal *glob;

 Index query_level;

 PlannerInfo *parent_root;







 List *plan_params;
 Bitmapset *outer_params;
# 202 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
 struct RelOptInfo **simple_rel_array;
 int simple_rel_array_size;







 RangeTblEntry **simple_rte_array;







 struct AppendRelInfo **append_rel_array;







 Relids all_baserels;







 Relids nullable_baserels;
# 246 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
 List *join_rel_list;
 struct HTAB *join_rel_hash;
# 256 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
 List **join_rel_level;
 int join_cur_level;

 List *init_plans;

 List *cte_plan_ids;

 List *multiexpr_params;


 List *eq_classes;

 List *canon_pathkeys;

 List *left_join_clauses;



 List *right_join_clauses;



 List *full_join_clauses;


 List *join_info_list;






 List *append_rel_list;

 List *rowMarks;

 List *placeholder_list;

 List *fkey_list;

 List *query_pathkeys;

 List *group_pathkeys;
 List *window_pathkeys;
 List *distinct_pathkeys;
 List *sort_pathkeys;

 List *part_schemes;


 List *initial_rels;


 List *upper_rels[UPPERREL_FINAL + 1];


 struct PathTarget *upper_targets[UPPERREL_FINAL + 1];
# 323 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
 List *processed_tlist;


 AttrNumber *grouping_map;
 List *minmax_aggs;

 MemoryContext planner_cxt;

 double total_table_pages;


 double tuple_fraction;
 double limit_tuples;

 Index qual_security_level;


 InheritanceKind inhTargetKind;


 _Bool hasJoinRTEs;
 _Bool hasLateralRTEs;
 _Bool hasHavingQual;
 _Bool hasPseudoConstantQuals;

 _Bool hasRecursion;


 int wt_param_id;
 struct Path *non_recursive_path;


 Relids curOuterRels;
 List *curOuterParams;


 void *join_search_private;


 _Bool partColsUpdated;
};
# 389 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct PartitionSchemeData
{
 char strategy;
 int16 partnatts;
 Oid *partopfamily;
 Oid *partopcintype;
 Oid *partcollation;


 int16 *parttyplen;
 _Bool *parttypbyval;


 FmgrInfo *partsupfunc;
} PartitionSchemeData;

typedef struct PartitionSchemeData *PartitionScheme;
# 597 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef enum RelOptKind
{
 RELOPT_BASEREL,
 RELOPT_JOINREL,
 RELOPT_OTHER_MEMBER_REL,
 RELOPT_OTHER_JOINREL,
 RELOPT_UPPER_REL,
 RELOPT_OTHER_UPPER_REL,
 RELOPT_DEADREL
} RelOptKind;
# 632 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct RelOptInfo
{
 NodeTag type;

 RelOptKind reloptkind;


 Relids relids;


 double rows;


 _Bool consider_startup;
 _Bool consider_param_startup;
 _Bool consider_parallel;


 struct PathTarget *reltarget;


 List *pathlist;
 List *ppilist;
 List *partial_pathlist;
 struct Path *cheapest_startup_path;
 struct Path *cheapest_total_path;
 struct Path *cheapest_unique_path;
 List *cheapest_parameterized_paths;



 Relids direct_lateral_relids;
 Relids lateral_relids;


 Index relid;
 Oid reltablespace;
 RTEKind rtekind;
 AttrNumber min_attr;
 AttrNumber max_attr;
 Relids *attr_needed;
 int32 *attr_widths;
 List *lateral_vars;
 Relids lateral_referencers;
 List *indexlist;
 List *statlist;
 BlockNumber pages;
 double tuples;
 double allvisfrac;
 PlannerInfo *subroot;
 List *subplan_params;
 int rel_parallel_workers;


 Oid serverid;
 Oid userid;
 _Bool useridiscurrent;

 struct FdwRoutine *fdwroutine;
 void *fdw_private;


 List *unique_for_rels;

 List *non_unique_for_rels;


 List *baserestrictinfo;
 QualCost baserestrictcost;
 Index baserestrict_min_security;

 List *joininfo;

 _Bool has_eclass_joins;


 _Bool consider_partitionwise_join;

 Relids top_parent_relids;



 PartitionScheme part_scheme;
 int nparts;
 struct PartitionBoundInfoData *boundinfo;
 List *partition_qual;
 struct RelOptInfo **part_rels;

 List **partexprs;
 List **nullable_partexprs;
 List *partitioned_child_rels;
} RelOptInfo;
# 777 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct IndexOptInfo IndexOptInfo;



struct IndexOptInfo
{
 NodeTag type;

 Oid indexoid;
 Oid reltablespace;
 RelOptInfo *rel;


 BlockNumber pages;
 double tuples;
 int tree_height;


 int ncolumns;
 int nkeycolumns;
 int *indexkeys;

 Oid *indexcollations;
 Oid *opfamily;
 Oid *opcintype;
 Oid *sortopfamily;
 _Bool *reverse_sort;
 _Bool *nulls_first;
 _Bool *canreturn;

 Oid relam;

 List *indexprs;
 List *indpred;

 List *indextlist;

 List *indrestrictinfo;





 _Bool predOK;
 _Bool unique;
 _Bool immediate;
 _Bool hypothetical;


 _Bool amcanorderbyop;
 _Bool amoptionalkey;
 _Bool amsearcharray;
 _Bool amsearchnulls;
 _Bool amhasgettuple;
 _Bool amhasgetbitmap;
 _Bool amcanparallel;

 void (*amcostestimate) ();
};
# 845 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct ForeignKeyOptInfo
{
 NodeTag type;


 Index con_relid;
 Index ref_relid;
 int nkeys;
 AttrNumber conkey[32];
 AttrNumber confkey[32];
 Oid conpfeqop[32];


 int nmatched_ec;
 int nmatched_rcols;
 int nmatched_ri;

 struct EquivalenceClass *eclass[32];

 List *rinfos[32];
} ForeignKeyOptInfo;
# 874 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct StatisticExtInfo
{
 NodeTag type;

 Oid statOid;
 RelOptInfo *rel;
 char kind;
 Bitmapset *keys;
} StatisticExtInfo;
# 924 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct EquivalenceClass
{
 NodeTag type;

 List *ec_opfamilies;
 Oid ec_collation;
 List *ec_members;
 List *ec_sources;
 List *ec_derives;
 Relids ec_relids;

 _Bool ec_has_const;
 _Bool ec_has_volatile;
 _Bool ec_below_outer_join;
 _Bool ec_broken;
 Index ec_sortref;
 Index ec_min_security;
 Index ec_max_security;
 struct EquivalenceClass *ec_merged;
} EquivalenceClass;
# 974 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct EquivalenceMember
{
 NodeTag type;

 Expr *em_expr;
 Relids em_relids;
 Relids em_nullable_relids;
 _Bool em_is_const;
 _Bool em_is_child;
 Oid em_datatype;
} EquivalenceMember;
# 1003 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct PathKey
{
 NodeTag type;

 EquivalenceClass *pk_eclass;
 Oid pk_opfamily;
 int pk_strategy;
 _Bool pk_nulls_first;
} PathKey;
# 1037 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct PathTarget
{
 NodeTag type;
 List *exprs;
 Index *sortgrouprefs;
 QualCost cost;
 int width;
} PathTarget;
# 1065 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct ParamPathInfo
{
 NodeTag type;

 Relids ppi_req_outer;
 double ppi_rows;
 List *ppi_clauses;
} ParamPathInfo;
# 1104 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct Path
{
 NodeTag type;

 NodeTag pathtype;

 RelOptInfo *parent;
 PathTarget *pathtarget;

 ParamPathInfo *param_info;

 _Bool parallel_aware;
 _Bool parallel_safe;
 int parallel_workers;


 double rows;
 Cost startup_cost;
 Cost total_cost;

 List *pathkeys;

} Path;
# 1170 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct IndexPath
{
 Path path;
 IndexOptInfo *indexinfo;
 List *indexclauses;
 List *indexorderbys;
 List *indexorderbycols;
 ScanDirection indexscandir;
 Cost indextotalcost;
 Selectivity indexselectivity;
} IndexPath;
# 1216 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct IndexClause
{
 NodeTag type;
 struct RestrictInfo *rinfo;
 List *indexquals;
 _Bool lossy;
 AttrNumber indexcol;
 List *indexcols;
} IndexClause;
# 1243 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct BitmapHeapPath
{
 Path path;
 Path *bitmapqual;
} BitmapHeapPath;







typedef struct BitmapAndPath
{
 Path path;
 List *bitmapquals;
 Selectivity bitmapselectivity;
} BitmapAndPath;







typedef struct BitmapOrPath
{
 Path path;
 List *bitmapquals;
 Selectivity bitmapselectivity;
} BitmapOrPath;
# 1282 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct TidPath
{
 Path path;
 List *tidquals;
} TidPath;
# 1296 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct SubqueryScanPath
{
 Path path;
 Path *subpath;
} SubqueryScanPath;
# 1312 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct ForeignPath
{
 Path path;
 Path *fdw_outerpath;
 List *fdw_private;
} ForeignPath;
# 1338 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
struct CustomPathMethods;

typedef struct CustomPath
{
 Path path;
 uint32 flags;

 List *custom_paths;
 List *custom_private;
 const struct CustomPathMethods *methods;
} CustomPath;
# 1365 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct AppendPath
{
 Path path;

 List *partitioned_rels;
 List *subpaths;

 int first_partial_path;
 double limit_tuples;
} AppendPath;
# 1385 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
extern _Bool is_dummy_rel(RelOptInfo *rel);





typedef struct MergeAppendPath
{
 Path path;

 List *partitioned_rels;
 List *subpaths;
 double limit_tuples;
} MergeAppendPath;
# 1407 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct GroupResultPath
{
 Path path;
 List *quals;
} GroupResultPath;







typedef struct MaterialPath
{
 Path path;
 Path *subpath;
} MaterialPath;
# 1437 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef enum
{
 UNIQUE_PATH_NOOP,
 UNIQUE_PATH_HASH,
 UNIQUE_PATH_SORT
} UniquePathMethod;

typedef struct UniquePath
{
 Path path;
 Path *subpath;
 UniquePathMethod umethod;
 List *in_operators;
 List *uniq_exprs;
} UniquePath;






typedef struct GatherPath
{
 Path path;
 Path *subpath;
 _Bool single_copy;
 int num_workers;
} GatherPath;





typedef struct GatherMergePath
{
 Path path;
 Path *subpath;
 int num_workers;
} GatherMergePath;






typedef struct JoinPath
{
 Path path;

 JoinType jointype;

 _Bool inner_unique;


 Path *outerjoinpath;
 Path *innerjoinpath;

 List *joinrestrictinfo;






} JoinPath;





typedef JoinPath NestPath;
# 1544 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct MergePath
{
 JoinPath jpath;
 List *path_mergeclauses;
 List *outersortkeys;
 List *innersortkeys;
 _Bool skip_mark_restore;
 _Bool materialize_inner;
} MergePath;
# 1563 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct HashPath
{
 JoinPath jpath;
 List *path_hashclauses;
 int num_batches;
 double inner_rows_total;
} HashPath;
# 1585 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct ProjectionPath
{
 Path path;
 Path *subpath;
 _Bool dummypp;
} ProjectionPath;






typedef struct ProjectSetPath
{
 Path path;
 Path *subpath;
} ProjectSetPath;
# 1611 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct SortPath
{
 Path path;
 Path *subpath;
} SortPath;
# 1625 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct GroupPath
{
 Path path;
 Path *subpath;
 List *groupClause;
 List *qual;
} GroupPath;







typedef struct UpperUniquePath
{
 Path path;
 Path *subpath;
 int numkeys;
} UpperUniquePath;
# 1653 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct AggPath
{
 Path path;
 Path *subpath;
 AggStrategy aggstrategy;
 AggSplit aggsplit;
 double numGroups;
 List *groupClause;
 List *qual;
} AggPath;





typedef struct GroupingSetData
{
 NodeTag type;
 List *set;
 double numGroups;
} GroupingSetData;

typedef struct RollupData
{
 NodeTag type;
 List *groupClause;
 List *gsets;
 List *gsets_data;
 double numGroups;
 _Bool hashable;
 _Bool is_hashed;
} RollupData;





typedef struct GroupingSetsPath
{
 Path path;
 Path *subpath;
 AggStrategy aggstrategy;
 List *rollups;
 List *qual;
} GroupingSetsPath;




typedef struct MinMaxAggPath
{
 Path path;
 List *mmaggregates;
 List *quals;
} MinMaxAggPath;




typedef struct WindowAggPath
{
 Path path;
 Path *subpath;
 WindowClause *winclause;
} WindowAggPath;




typedef struct SetOpPath
{
 Path path;
 Path *subpath;
 SetOpCmd cmd;
 SetOpStrategy strategy;
 List *distinctList;
 AttrNumber flagColIdx;
 int firstFlag;
 double numGroups;
} SetOpPath;




typedef struct RecursiveUnionPath
{
 Path path;
 Path *leftpath;
 Path *rightpath;
 List *distinctList;
 int wtParam;
 double numGroups;
} RecursiveUnionPath;




typedef struct LockRowsPath
{
 Path path;
 Path *subpath;
 List *rowMarks;
 int epqParam;
} LockRowsPath;
# 1765 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct ModifyTablePath
{
 Path path;
 CmdType operation;
 _Bool canSetTag;
 Index nominalRelation;
 Index rootRelation;
 _Bool partColsUpdated;
 List *resultRelations;
 List *subpaths;
 List *subroots;
 List *withCheckOptionLists;
 List *returningLists;
 List *rowMarks;
 OnConflictExpr *onconflict;
 int epqParam;
} ModifyTablePath;




typedef struct LimitPath
{
 Path path;
 Path *subpath;
 Node *limitOffset;
 Node *limitCount;
} LimitPath;
# 1935 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct RestrictInfo
{
 NodeTag type;

 Expr *clause;

 _Bool is_pushed_down;

 _Bool outerjoin_delayed;

 _Bool can_join;

 _Bool pseudoconstant;

 _Bool leakproof;

 Index security_level;


 Relids clause_relids;


 Relids required_relids;


 Relids outer_relids;


 Relids nullable_relids;


 Relids left_relids;
 Relids right_relids;


 Expr *orclause;


 EquivalenceClass *parent_ec;


 QualCost eval_cost;
 Selectivity norm_selec;


 Selectivity outer_selec;



 List *mergeopfamilies;


 EquivalenceClass *left_ec;
 EquivalenceClass *right_ec;
 EquivalenceMember *left_em;
 EquivalenceMember *right_em;
 List *scansel_cache;


 _Bool outer_is_left;


 Oid hashjoinoperator;


 Selectivity left_bucketsize;
 Selectivity right_bucketsize;
 Selectivity left_mcvfreq;
 Selectivity right_mcvfreq;
} RestrictInfo;
# 2027 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct MergeScanSelCache
{

 Oid opfamily;
 Oid collation;
 int strategy;
 _Bool nulls_first;

 Selectivity leftstartsel;
 Selectivity leftendsel;
 Selectivity rightstartsel;
 Selectivity rightendsel;
} MergeScanSelCache;
# 2055 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct PlaceHolderVar
{
 Expr xpr;
 Expr *phexpr;
 Relids phrels;
 Index phid;
 Index phlevelsup;
} PlaceHolderVar;
# 2122 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct SpecialJoinInfo SpecialJoinInfo;



struct SpecialJoinInfo
{
 NodeTag type;
 Relids min_lefthand;
 Relids min_righthand;
 Relids syn_lefthand;
 Relids syn_righthand;
 JoinType jointype;
 _Bool lhs_strict;
 _Bool delay_upper_joins;

 _Bool semi_can_btree;
 _Bool semi_can_hash;
 List *semi_operators;
 List *semi_rhs_exprs;
};
# 2177 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct AppendRelInfo
{
 NodeTag type;







 Index parent_relid;
 Index child_relid;







 Oid parent_reltype;
 Oid child_reltype;
# 2215 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
 List *translated_vars;






 Oid parent_reloid;
} AppendRelInfo;
# 2251 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct PlaceHolderInfo
{
 NodeTag type;

 Index phid;
 PlaceHolderVar *ph_var;
 Relids ph_eval_at;
 Relids ph_lateral;
 Relids ph_needed;
 int32 ph_width;
} PlaceHolderInfo;






typedef struct MinMaxAggInfo
{
 NodeTag type;

 Oid aggfnoid;
 Oid aggsortop;
 Expr *target;
 PlannerInfo *subroot;
 Path *path;
 Cost pathcost;
 Param *param;
} MinMaxAggInfo;
# 2328 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct PlannerParamItem
{
 NodeTag type;

 Node *item;
 int paramId;
} PlannerParamItem;
# 2352 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct SemiAntiJoinFactors
{
 Selectivity outer_match_frac;
 Selectivity match_count;
} SemiAntiJoinFactors;
# 2371 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct JoinPathExtraData
{
 List *restrictlist;
 List *mergeclause_list;
 _Bool inner_unique;
 SpecialJoinInfo *sjinfo;
 SemiAntiJoinFactors semifactors;
 Relids param_source_rels;
} JoinPathExtraData;
# 2411 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef enum
{
 PARTITIONWISE_AGGREGATE_NONE,
 PARTITIONWISE_AGGREGATE_FULL,
 PARTITIONWISE_AGGREGATE_PARTIAL
} PartitionwiseAggregateType;
# 2431 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct
{

 int flags;
 _Bool partial_costs_set;
 AggClauseCosts agg_partial_costs;
 AggClauseCosts agg_final_costs;


 _Bool target_parallel_safe;
 Node *havingQual;
 List *targetList;
 PartitionwiseAggregateType patype;
} GroupPathExtraData;
# 2456 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct
{
 _Bool limit_needed;
 double limit_tuples;
 int64 count_est;
 int64 offset_est;
} FinalPathExtraData;
# 2476 "/products1/postgres/PG12.1/include/server/nodes/pathnodes.h"
typedef struct JoinCostWorkspace
{

 Cost startup_cost;
 Cost total_cost;


 Cost run_cost;


 Cost inner_run_cost;
 Cost inner_rescan_run_cost;


 double outer_rows;
 double inner_rows;
 double outer_skip_rows;
 double inner_skip_rows;


 int numbuckets;
 int numbatches;
 double inner_rows_total;
} JoinCostWorkspace;
# 18 "/products1/postgres/PG12.1/include/server/foreign/fdwapi.h" 2


struct ExplainState;






typedef void (*GetForeignRelSize_function) (PlannerInfo *root,
           RelOptInfo *baserel,
           Oid foreigntableid);

typedef void (*GetForeignPaths_function) (PlannerInfo *root,
            RelOptInfo *baserel,
            Oid foreigntableid);

typedef ForeignScan *(*GetForeignPlan_function) (PlannerInfo *root,
             RelOptInfo *baserel,
             Oid foreigntableid,
             ForeignPath *best_path,
             List *tlist,
             List *scan_clauses,
             Plan *outer_plan);

typedef void (*BeginForeignScan_function) (ForeignScanState *node,
             int eflags);

typedef TupleTableSlot *(*IterateForeignScan_function) (ForeignScanState *node);

typedef _Bool (*RecheckForeignScan_function) (ForeignScanState *node,
            TupleTableSlot *slot);

typedef void (*ReScanForeignScan_function) (ForeignScanState *node);

typedef void (*EndForeignScan_function) (ForeignScanState *node);

typedef void (*GetForeignJoinPaths_function) (PlannerInfo *root,
             RelOptInfo *joinrel,
             RelOptInfo *outerrel,
             RelOptInfo *innerrel,
             JoinType jointype,
             JoinPathExtraData *extra);

typedef void (*GetForeignUpperPaths_function) (PlannerInfo *root,
              UpperRelationKind stage,
              RelOptInfo *input_rel,
              RelOptInfo *output_rel,
              void *extra);

typedef void (*AddForeignUpdateTargets_function) (Query *parsetree,
              RangeTblEntry *target_rte,
              Relation target_relation);

typedef List *(*PlanForeignModify_function) (PlannerInfo *root,
            ModifyTable *plan,
            Index resultRelation,
            int subplan_index);

typedef void (*BeginForeignModify_function) (ModifyTableState *mtstate,
            ResultRelInfo *rinfo,
            List *fdw_private,
            int subplan_index,
            int eflags);

typedef TupleTableSlot *(*ExecForeignInsert_function) (EState *estate,
                ResultRelInfo *rinfo,
                TupleTableSlot *slot,
                TupleTableSlot *planSlot);

typedef TupleTableSlot *(*ExecForeignUpdate_function) (EState *estate,
                ResultRelInfo *rinfo,
                TupleTableSlot *slot,
                TupleTableSlot *planSlot);

typedef TupleTableSlot *(*ExecForeignDelete_function) (EState *estate,
                ResultRelInfo *rinfo,
                TupleTableSlot *slot,
                TupleTableSlot *planSlot);

typedef void (*EndForeignModify_function) (EState *estate,
             ResultRelInfo *rinfo);

typedef void (*BeginForeignInsert_function) (ModifyTableState *mtstate,
            ResultRelInfo *rinfo);

typedef void (*EndForeignInsert_function) (EState *estate,
             ResultRelInfo *rinfo);

typedef int (*IsForeignRelUpdatable_function) (Relation rel);

typedef _Bool (*PlanDirectModify_function) (PlannerInfo *root,
             ModifyTable *plan,
             Index resultRelation,
             int subplan_index);

typedef void (*BeginDirectModify_function) (ForeignScanState *node,
           int eflags);

typedef TupleTableSlot *(*IterateDirectModify_function) (ForeignScanState *node);

typedef void (*EndDirectModify_function) (ForeignScanState *node);

typedef RowMarkType (*GetForeignRowMarkType_function) (RangeTblEntry *rte,
                LockClauseStrength strength);

typedef void (*RefetchForeignRow_function) (EState *estate,
           ExecRowMark *erm,
           Datum rowid,
           TupleTableSlot *slot,
           _Bool *updated);

typedef void (*ExplainForeignScan_function) (ForeignScanState *node,
            struct ExplainState *es);

typedef void (*ExplainForeignModify_function) (ModifyTableState *mtstate,
              ResultRelInfo *rinfo,
              List *fdw_private,
              int subplan_index,
              struct ExplainState *es);

typedef void (*ExplainDirectModify_function) (ForeignScanState *node,
             struct ExplainState *es);

typedef int (*AcquireSampleRowsFunc) (Relation relation, int elevel,
           HeapTuple *rows, int targrows,
           double *totalrows,
           double *totaldeadrows);

typedef _Bool (*AnalyzeForeignTable_function) (Relation relation,
             AcquireSampleRowsFunc *func,
             BlockNumber *totalpages);

typedef List *(*ImportForeignSchema_function) (ImportForeignSchemaStmt *stmt,
              Oid serverOid);

typedef Size (*EstimateDSMForeignScan_function) (ForeignScanState *node,
             ParallelContext *pcxt);
typedef void (*InitializeDSMForeignScan_function) (ForeignScanState *node,
               ParallelContext *pcxt,
               void *coordinate);
typedef void (*ReInitializeDSMForeignScan_function) (ForeignScanState *node,
              ParallelContext *pcxt,
              void *coordinate);
typedef void (*InitializeWorkerForeignScan_function) (ForeignScanState *node,
               shm_toc *toc,
               void *coordinate);
typedef void (*ShutdownForeignScan_function) (ForeignScanState *node);
typedef _Bool (*IsForeignScanParallelSafe_function) (PlannerInfo *root,
             RelOptInfo *rel,
             RangeTblEntry *rte);
typedef List *(*ReparameterizeForeignPathByChild_function) (PlannerInfo *root,
               List *fdw_private,
               RelOptInfo *child_rel);
# 183 "/products1/postgres/PG12.1/include/server/foreign/fdwapi.h"
typedef struct FdwRoutine
{
 NodeTag type;


 GetForeignRelSize_function GetForeignRelSize;
 GetForeignPaths_function GetForeignPaths;
 GetForeignPlan_function GetForeignPlan;
 BeginForeignScan_function BeginForeignScan;
 IterateForeignScan_function IterateForeignScan;
 ReScanForeignScan_function ReScanForeignScan;
 EndForeignScan_function EndForeignScan;







 GetForeignJoinPaths_function GetForeignJoinPaths;


 GetForeignUpperPaths_function GetForeignUpperPaths;


 AddForeignUpdateTargets_function AddForeignUpdateTargets;
 PlanForeignModify_function PlanForeignModify;
 BeginForeignModify_function BeginForeignModify;
 ExecForeignInsert_function ExecForeignInsert;
 ExecForeignUpdate_function ExecForeignUpdate;
 ExecForeignDelete_function ExecForeignDelete;
 EndForeignModify_function EndForeignModify;
 BeginForeignInsert_function BeginForeignInsert;
 EndForeignInsert_function EndForeignInsert;
 IsForeignRelUpdatable_function IsForeignRelUpdatable;
 PlanDirectModify_function PlanDirectModify;
 BeginDirectModify_function BeginDirectModify;
 IterateDirectModify_function IterateDirectModify;
 EndDirectModify_function EndDirectModify;


 GetForeignRowMarkType_function GetForeignRowMarkType;
 RefetchForeignRow_function RefetchForeignRow;
 RecheckForeignScan_function RecheckForeignScan;


 ExplainForeignScan_function ExplainForeignScan;
 ExplainForeignModify_function ExplainForeignModify;
 ExplainDirectModify_function ExplainDirectModify;


 AnalyzeForeignTable_function AnalyzeForeignTable;


 ImportForeignSchema_function ImportForeignSchema;


 IsForeignScanParallelSafe_function IsForeignScanParallelSafe;
 EstimateDSMForeignScan_function EstimateDSMForeignScan;
 InitializeDSMForeignScan_function InitializeDSMForeignScan;
 ReInitializeDSMForeignScan_function ReInitializeDSMForeignScan;
 InitializeWorkerForeignScan_function InitializeWorkerForeignScan;
 ShutdownForeignScan_function ShutdownForeignScan;


 ReparameterizeForeignPathByChild_function ReparameterizeForeignPathByChild;
} FdwRoutine;



extern FdwRoutine *GetFdwRoutine(Oid fdwhandler);
extern Oid GetForeignServerIdByRelId(Oid relid);
extern FdwRoutine *GetFdwRoutineByServerId(Oid serverid);
extern FdwRoutine *GetFdwRoutineByRelId(Oid relid);
extern FdwRoutine *GetFdwRoutineForRelation(Relation relation, _Bool makecopy);
extern _Bool IsImportableForeignTable(const char *tablename,
          ImportForeignSchemaStmt *stmt);
extern Path *GetExistingLocalJoinPath(RelOptInfo *joinrel);
# 31 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/foreign/foreign.h" 1
# 28 "/products1/postgres/PG12.1/include/server/foreign/foreign.h"
typedef enum
{
 ServerOpt = 1,
 UserMappingOpt = 2,
 FdwOpt = 4
} GenericOptionFlags;

typedef struct ForeignDataWrapper
{
 Oid fdwid;
 Oid owner;
 char *fdwname;
 Oid fdwhandler;
 Oid fdwvalidator;
 List *options;
} ForeignDataWrapper;

typedef struct ForeignServer
{
 Oid serverid;
 Oid fdwid;
 Oid owner;
 char *servername;
 char *servertype;
 char *serverversion;
 List *options;
} ForeignServer;

typedef struct UserMapping
{
 Oid umid;
 Oid userid;
 Oid serverid;
 List *options;
} UserMapping;

typedef struct ForeignTable
{
 Oid relid;
 Oid serverid;
 List *options;
} ForeignTable;
# 78 "/products1/postgres/PG12.1/include/server/foreign/foreign.h"
extern ForeignServer *GetForeignServer(Oid serverid);
extern ForeignServer *GetForeignServerExtended(Oid serverid,
              bits16 flags);
extern ForeignServer *GetForeignServerByName(const char *name, _Bool missing_ok);
extern UserMapping *GetUserMapping(Oid userid, Oid serverid);
extern ForeignDataWrapper *GetForeignDataWrapper(Oid fdwid);
extern ForeignDataWrapper *GetForeignDataWrapperExtended(Oid fdwid,
               bits16 flags);
extern ForeignDataWrapper *GetForeignDataWrapperByName(const char *name,
                _Bool missing_ok);
extern ForeignTable *GetForeignTable(Oid relid);

extern List *GetForeignColumnOptions(Oid relid, AttrNumber attnum);

extern Oid get_foreign_data_wrapper_oid(const char *fdwname, _Bool missing_ok);
extern Oid get_foreign_server_oid(const char *servername, _Bool missing_ok);
# 32 "db2_fdw.c" 2



# 1 "/products1/postgres/PG12.1/include/server/common/md5.h" 1
# 22 "/products1/postgres/PG12.1/include/server/common/md5.h"
extern _Bool pg_md5_hash(const void *buff, size_t len, char *hexsum);
extern _Bool pg_md5_binary(const void *buff, size_t len, void *outbuf);
extern _Bool pg_md5_encrypt(const char *passwd, const char *salt,
         size_t salt_len, char *buf);
# 36 "db2_fdw.c" 2

# 1 "/products1/postgres/PG12.1/include/server/libpq/pqsignal.h" 1
# 33 "/products1/postgres/PG12.1/include/server/libpq/pqsignal.h"
extern sigset_t UnBlockSig,
   BlockSig,
   StartupBlockSig;

extern void pqinitmask(void);
# 38 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/mb/pg_wchar.h" 1
# 25 "/products1/postgres/PG12.1/include/server/mb/pg_wchar.h"
typedef unsigned int pg_wchar;
# 238 "/products1/postgres/PG12.1/include/server/mb/pg_wchar.h"
typedef enum pg_enc
{
 PG_SQL_ASCII = 0,
 PG_EUC_JP,
 PG_EUC_CN,
 PG_EUC_KR,
 PG_EUC_TW,
 PG_EUC_JIS_2004,
 PG_UTF8,
 PG_MULE_INTERNAL,
 PG_LATIN1,
 PG_LATIN2,
 PG_LATIN3,
 PG_LATIN4,
 PG_LATIN5,
 PG_LATIN6,
 PG_LATIN7,
 PG_LATIN8,
 PG_LATIN9,
 PG_LATIN10,
 PG_WIN1256,
 PG_WIN1258,
 PG_WIN866,
 PG_WIN874,
 PG_KOI8R,
 PG_WIN1251,
 PG_WIN1252,
 PG_ISO_8859_5,
 PG_ISO_8859_6,
 PG_ISO_8859_7,
 PG_ISO_8859_8,
 PG_WIN1250,
 PG_WIN1253,
 PG_WIN1254,
 PG_WIN1255,
 PG_WIN1257,
 PG_KOI8U,



 PG_SJIS,
 PG_BIG5,
 PG_GBK,
 PG_UHC,
 PG_GB18030,
 PG_JOHAB,
 PG_SHIFT_JIS_2004,
 _PG_LAST_ENCODING_

} pg_enc;
# 326 "/products1/postgres/PG12.1/include/server/mb/pg_wchar.h"
typedef struct pg_enc2name
{
 const char *name;
 pg_enc encoding;



} pg_enc2name;

extern const pg_enc2name pg_enc2name_tbl[];




typedef struct pg_enc2gettext
{
 pg_enc encoding;
 const char *name;
} pg_enc2gettext;

extern const pg_enc2gettext pg_enc2gettext_tbl[];




extern _Bool is_encoding_supported_by_icu(int encoding);
extern const char *get_encoding_name_for_icu(int encoding);




typedef int (*mb2wchar_with_len_converter) (const unsigned char *from,
           pg_wchar *to,
           int len);

typedef int (*wchar2mb_with_len_converter) (const pg_wchar *from,
           unsigned char *to,
           int len);

typedef int (*mblen_converter) (const unsigned char *mbstr);

typedef int (*mbdisplaylen_converter) (const unsigned char *mbstr);

typedef _Bool (*mbcharacter_incrementer) (unsigned char *mbstr, int len);

typedef int (*mbverifier) (const unsigned char *mbstr, int len);

typedef struct
{
 mb2wchar_with_len_converter mb2wchar_with_len;

 wchar2mb_with_len_converter wchar2mb_with_len;

 mblen_converter mblen;
 mbdisplaylen_converter dsplen;
 mbverifier mbverify;
 int maxmblen;
} pg_wchar_tbl;

extern const pg_wchar_tbl pg_wchar_table[];
# 427 "/products1/postgres/PG12.1/include/server/mb/pg_wchar.h"
typedef struct
{




 const uint16 *chars16;
 const uint32 *chars32;


 uint32 b1root;
 uint8 b1_lower;
 uint8 b1_upper;


 uint32 b2root;
 uint8 b2_1_lower;
 uint8 b2_1_upper;
 uint8 b2_2_lower;
 uint8 b2_2_upper;


 uint32 b3root;
 uint8 b3_1_lower;
 uint8 b3_1_upper;
 uint8 b3_2_lower;
 uint8 b3_2_upper;
 uint8 b3_3_lower;
 uint8 b3_3_upper;


 uint32 b4root;
 uint8 b4_1_lower;
 uint8 b4_1_upper;
 uint8 b4_2_lower;
 uint8 b4_2_upper;
 uint8 b4_3_lower;
 uint8 b4_3_upper;
 uint8 b4_4_lower;
 uint8 b4_4_upper;

} pg_mb_radix_tree;




typedef struct
{
 uint32 utf1;
 uint32 utf2;
 uint32 code;
} pg_utf_to_local_combined;




typedef struct
{
 uint32 code;
 uint32 utf1;
 uint32 utf2;
} pg_local_to_utf_combined;






typedef uint32 (*utf_local_conversion_func) (uint32 code);
# 515 "/products1/postgres/PG12.1/include/server/mb/pg_wchar.h"
extern int pg_char_to_encoding(const char *name);
extern const char *pg_encoding_to_char(int encoding);
extern int pg_valid_server_encoding_id(int encoding);





extern int pg_mb2wchar(const char *from, pg_wchar *to);
extern int pg_mb2wchar_with_len(const char *from, pg_wchar *to, int len);
extern int pg_encoding_mb2wchar_with_len(int encoding,
            const char *from, pg_wchar *to, int len);
extern int pg_wchar2mb(const pg_wchar *from, char *to);
extern int pg_wchar2mb_with_len(const pg_wchar *from, char *to, int len);
extern int pg_encoding_wchar2mb_with_len(int encoding,
            const pg_wchar *from, char *to, int len);
extern int pg_char_and_wchar_strcmp(const char *s1, const pg_wchar *s2);
extern int pg_wchar_strncmp(const pg_wchar *s1, const pg_wchar *s2, size_t n);
extern int pg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n);
extern size_t pg_wchar_strlen(const pg_wchar *wstr);
extern int pg_mblen(const char *mbstr);
extern int pg_dsplen(const char *mbstr);
extern int pg_encoding_mblen(int encoding, const char *mbstr);
extern int pg_encoding_dsplen(int encoding, const char *mbstr);
extern int pg_encoding_verifymb(int encoding, const char *mbstr, int len);
extern int pg_mule_mblen(const unsigned char *mbstr);
extern int pg_mic_mblen(const unsigned char *mbstr);
extern int pg_mbstrlen(const char *mbstr);
extern int pg_mbstrlen_with_len(const char *mbstr, int len);
extern int pg_mbcliplen(const char *mbstr, int len, int limit);
extern int pg_encoding_mbcliplen(int encoding, const char *mbstr,
          int len, int limit);
extern int pg_mbcharcliplen(const char *mbstr, int len, int imit);
extern int pg_encoding_max_length(int encoding);
extern int pg_database_encoding_max_length(void);
extern mbcharacter_incrementer pg_database_encoding_character_incrementer(void);

extern int PrepareClientEncoding(int encoding);
extern int SetClientEncoding(int encoding);
extern void InitializeClientEncoding(void);
extern int pg_get_client_encoding(void);
extern const char *pg_get_client_encoding_name(void);

extern void SetDatabaseEncoding(int encoding);
extern int GetDatabaseEncoding(void);
extern const char *GetDatabaseEncodingName(void);
extern void SetMessageEncoding(int encoding);
extern int GetMessageEncoding(void);





extern int pg_valid_client_encoding(const char *name);
extern int pg_valid_server_encoding(const char *name);

extern unsigned char *unicode_to_utf8(pg_wchar c, unsigned char *utf8string);
extern pg_wchar utf8_to_unicode(const unsigned char *c);
extern int pg_utf_mblen(const unsigned char *);
extern unsigned char *pg_do_encoding_conversion(unsigned char *src, int len,
            int src_encoding,
            int dest_encoding);

extern char *pg_client_to_server(const char *s, int len);
extern char *pg_server_to_client(const char *s, int len);
extern char *pg_any_to_server(const char *s, int len, int encoding);
extern char *pg_server_to_any(const char *s, int len, int encoding);

extern unsigned short BIG5toCNS(unsigned short big5, unsigned char *lc);
extern unsigned short CNStoBIG5(unsigned short cns, unsigned char lc);

extern void UtfToLocal(const unsigned char *utf, int len,
        unsigned char *iso,
        const pg_mb_radix_tree *map,
        const pg_utf_to_local_combined *cmap, int cmapsize,
        utf_local_conversion_func conv_func,
        int encoding);
extern void LocalToUtf(const unsigned char *iso, int len,
        unsigned char *utf,
        const pg_mb_radix_tree *map,
        const pg_local_to_utf_combined *cmap, int cmapsize,
        utf_local_conversion_func conv_func,
        int encoding);

extern _Bool pg_verifymbstr(const char *mbstr, int len, _Bool noError);
extern _Bool pg_verify_mbstr(int encoding, const char *mbstr, int len,
       _Bool noError);
extern int pg_verify_mbstr_len(int encoding, const char *mbstr, int len,
        _Bool noError);

extern void check_encoding_conversion_args(int src_encoding,
             int dest_encoding,
             int len,
             int expected_src_encoding,
             int expected_dest_encoding);

extern void report_invalid_encoding(int encoding, const char *mbstr, int len) __attribute__((noreturn));
extern void report_untranslatable_char(int src_encoding, int dest_encoding,
            const char *mbstr, int len) __attribute__((noreturn));

extern void local2local(const unsigned char *l, unsigned char *p, int len,
      int src_encoding, int dest_encoding, const unsigned char *tab);
extern void pg_ascii2mic(const unsigned char *l, unsigned char *p, int len);
extern void pg_mic2ascii(const unsigned char *mic, unsigned char *p, int len);
extern void latin2mic(const unsigned char *l, unsigned char *p, int len,
       int lc, int encoding);
extern void mic2latin(const unsigned char *mic, unsigned char *p, int len,
       int lc, int encoding);
extern void latin2mic_with_table(const unsigned char *l, unsigned char *p,
         int len, int lc, int encoding,
         const unsigned char *tab);
extern void mic2latin_with_table(const unsigned char *mic, unsigned char *p,
         int len, int lc, int encoding,
         const unsigned char *tab);

extern _Bool pg_utf8_islegal(const unsigned char *source, int length);
# 39 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/miscadmin.h" 1
# 28 "/products1/postgres/PG12.1/include/server/miscadmin.h"
# 1 "/products1/postgres/PG12.1/include/server/datatype/timestamp.h" 1
# 29 "/products1/postgres/PG12.1/include/server/miscadmin.h" 2
# 1 "/products1/postgres/PG12.1/include/server/pgtime.h" 1
# 30 "/products1/postgres/PG12.1/include/server/miscadmin.h" 2
# 81 "/products1/postgres/PG12.1/include/server/miscadmin.h"
extern volatile sig_atomic_t InterruptPending;
extern volatile sig_atomic_t QueryCancelPending;
extern volatile sig_atomic_t ProcDiePending;
extern volatile sig_atomic_t IdleInTransactionSessionTimeoutPending;
extern volatile sig_atomic_t ConfigReloadPending;

extern volatile sig_atomic_t ClientConnectionLost;


extern volatile uint32 InterruptHoldoffCount;
extern volatile uint32 QueryCancelHoldoffCount;
extern volatile uint32 CritSectionCount;


extern void ProcessInterrupts(void);
# 148 "/products1/postgres/PG12.1/include/server/miscadmin.h"
extern pid_t PostmasterPid;
extern _Bool IsPostmasterEnvironment;
extern _Bool IsUnderPostmaster;
extern _Bool IsBackgroundWorker;
extern _Bool IsBinaryUpgrade;

extern _Bool ExitOnAnyError;

extern char *DataDir;
extern int data_directory_mode;

extern int NBuffers;
extern int MaxBackends;
extern int MaxConnections;
extern int max_worker_processes;
extern int max_parallel_workers;

extern int MyProcPid;
extern pg_time_t MyStartTime;
extern TimestampTz MyStartTimestamp;
extern struct Port *MyProcPort;
extern struct Latch *MyLatch;
extern int32 MyCancelKey;
extern int MyPMChildSlot;

extern char OutputFileName[];
extern char my_exec_path[];
extern char pkglib_path[];
# 186 "/products1/postgres/PG12.1/include/server/miscadmin.h"
extern Oid MyDatabaseId;

extern Oid MyDatabaseTableSpace;
# 224 "/products1/postgres/PG12.1/include/server/miscadmin.h"
extern int DateStyle;
extern int DateOrder;
# 239 "/products1/postgres/PG12.1/include/server/miscadmin.h"
extern int IntervalStyle;



extern _Bool enableFsync;
extern _Bool allowSystemTableMods;
extern int work_mem;
extern int maintenance_work_mem;
extern int max_parallel_maintenance_workers;

extern int VacuumCostPageHit;
extern int VacuumCostPageMiss;
extern int VacuumCostPageDirty;
extern int VacuumCostLimit;
extern double VacuumCostDelay;

extern int VacuumPageHit;
extern int VacuumPageMiss;
extern int VacuumPageDirty;

extern int VacuumCostBalance;
extern _Bool VacuumCostActive;

extern double vacuum_cleanup_index_scale_factor;
# 274 "/products1/postgres/PG12.1/include/server/miscadmin.h"
typedef char *pg_stack_base_t;


extern pg_stack_base_t set_stack_base(void);
extern void restore_stack_base(pg_stack_base_t base);
extern void check_stack_depth(void);
extern _Bool stack_is_too_deep(void);

extern void PostgresSigHupHandler(int postgres_signal_arg);


extern void PreventCommandIfReadOnly(const char *cmdname);
extern void PreventCommandIfParallelMode(const char *cmdname);
extern void PreventCommandDuringRecovery(const char *cmdname);


extern int trace_recovery_messages;
extern int trace_recovery(int trace_level);
# 303 "/products1/postgres/PG12.1/include/server/miscadmin.h"
extern char *DatabasePath;


extern void InitPostmasterChild(void);
extern void InitStandaloneProcess(const char *argv0);

extern void SetDatabasePath(const char *path);

extern char *GetUserNameFromId(Oid roleid, _Bool noerr);
extern Oid GetUserId(void);
extern Oid GetOuterUserId(void);
extern Oid GetSessionUserId(void);
extern Oid GetAuthenticatedUserId(void);
extern void GetUserIdAndSecContext(Oid *userid, int *sec_context);
extern void SetUserIdAndSecContext(Oid userid, int sec_context);
extern _Bool InLocalUserIdChange(void);
extern _Bool InSecurityRestrictedOperation(void);
extern _Bool InNoForceRLSOperation(void);
extern void GetUserIdAndContext(Oid *userid, _Bool *sec_def_context);
extern void SetUserIdAndContext(Oid userid, _Bool sec_def_context);
extern void InitializeSessionUserId(const char *rolename, Oid useroid);
extern void InitializeSessionUserIdStandalone(void);
extern void SetSessionAuthorization(Oid userid, _Bool is_superuser);
extern Oid GetCurrentRoleId(void);
extern void SetCurrentRoleId(Oid roleid, _Bool is_superuser);

extern void checkDataDir(void);
extern void SetDataDir(const char *dir);
extern void ChangeToDataDir(void);

extern void SwitchToSharedLatch(void);
extern void SwitchBackToLocalLatch(void);


extern _Bool superuser(void);
extern _Bool superuser_arg(Oid roleid);
# 365 "/products1/postgres/PG12.1/include/server/miscadmin.h"
typedef enum ProcessingMode
{
 BootstrapProcessing,
 InitProcessing,
 NormalProcessing
} ProcessingMode;

extern ProcessingMode Mode;
# 395 "/products1/postgres/PG12.1/include/server/miscadmin.h"
typedef enum
{
 NotAnAuxProcess = -1,
 CheckerProcess = 0,
 BootstrapProcess,
 StartupProcess,
 BgWriterProcess,
 CheckpointerProcess,
 WalWriterProcess,
 WalReceiverProcess,

 NUM_AUXPROCTYPES
} AuxProcType;

extern AuxProcType MyAuxProcType;
# 425 "/products1/postgres/PG12.1/include/server/miscadmin.h"
extern void pg_split_opts(char **argv, int *argcp, const char *optstr);
extern void InitializeMaxBackends(void);
extern void InitPostgres(const char *in_dbname, Oid dboid, const char *username,
       Oid useroid, char *out_dbname, _Bool override_allow_connections);
extern void BaseInit(void);


extern _Bool IgnoreSystemIndexes;
extern _Bool process_shared_preload_libraries_in_progress;
extern char *session_preload_libraries_string;
extern char *shared_preload_libraries_string;
extern char *local_preload_libraries_string;

extern void CreateDataDirLockFile(_Bool amPostmaster);
extern void CreateSocketLockFile(const char *socketfile, _Bool amPostmaster,
         const char *socketDir);
extern void TouchSocketLockFiles(void);
extern void AddToDataDirLockFile(int target_line, const char *str);
extern _Bool RecheckDataDirLockFile(void);
extern void ValidatePgVersion(const char *path);
extern void process_shared_preload_libraries(void);
extern void process_session_preload_libraries(void);
extern void pg_bindtextdomain(const char *domain);
extern _Bool has_rolreplication(Oid roleid);


extern _Bool BackupInProgress(void);
extern void CancelBackup(void);
# 40 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/nodes/makefuncs.h" 1
# 21 "/products1/postgres/PG12.1/include/server/nodes/makefuncs.h"
extern A_Expr *makeA_Expr(A_Expr_Kind kind, List *name,
        Node *lexpr, Node *rexpr, int location);

extern A_Expr *makeSimpleA_Expr(A_Expr_Kind kind, char *name,
        Node *lexpr, Node *rexpr, int location);

extern Var *makeVar(Index varno,
     AttrNumber varattno,
     Oid vartype,
     int32 vartypmod,
     Oid varcollid,
     Index varlevelsup);

extern Var *makeVarFromTargetEntry(Index varno,
           TargetEntry *tle);

extern Var *makeWholeRowVar(RangeTblEntry *rte,
       Index varno,
       Index varlevelsup,
       _Bool allowScalar);

extern TargetEntry *makeTargetEntry(Expr *expr,
         AttrNumber resno,
         char *resname,
         _Bool resjunk);

extern TargetEntry *flatCopyTargetEntry(TargetEntry *src_tle);

extern FromExpr *makeFromExpr(List *fromlist, Node *quals);

extern Const *makeConst(Oid consttype,
      int32 consttypmod,
      Oid constcollid,
      int constlen,
      Datum constvalue,
      _Bool constisnull,
      _Bool constbyval);

extern Const *makeNullConst(Oid consttype, int32 consttypmod, Oid constcollid);

extern Node *makeBoolConst(_Bool value, _Bool isnull);

extern Expr *makeBoolExpr(BoolExprType boolop, List *args, int location);

extern Alias *makeAlias(const char *aliasname, List *colnames);

extern RelabelType *makeRelabelType(Expr *arg, Oid rtype, int32 rtypmod,
         Oid rcollid, CoercionForm rformat);

extern RangeVar *makeRangeVar(char *schemaname, char *relname, int location);

extern TypeName *makeTypeName(char *typnam);
extern TypeName *makeTypeNameFromNameList(List *names);
extern TypeName *makeTypeNameFromOid(Oid typeOid, int32 typmod);

extern ColumnDef *makeColumnDef(const char *colname,
        Oid typeOid, int32 typmod, Oid collOid);

extern FuncExpr *makeFuncExpr(Oid funcid, Oid rettype, List *args,
         Oid funccollid, Oid inputcollid, CoercionForm fformat);

extern FuncCall *makeFuncCall(List *name, List *args, int location);

extern Expr *make_opclause(Oid opno, Oid opresulttype, _Bool opretset,
         Expr *leftop, Expr *rightop,
         Oid opcollid, Oid inputcollid);

extern Expr *make_andclause(List *andclauses);
extern Expr *make_orclause(List *orclauses);
extern Expr *make_notclause(Expr *notclause);

extern Node *make_and_qual(Node *qual1, Node *qual2);
extern Expr *make_ands_explicit(List *andclauses);
extern List *make_ands_implicit(Expr *clause);

extern IndexInfo *makeIndexInfo(int numattrs, int numkeyattrs, Oid amoid,
        List *expressions, List *predicates,
        _Bool unique, _Bool isready, _Bool concurrent);

extern DefElem *makeDefElem(char *name, Node *arg, int location);
extern DefElem *makeDefElemExtended(char *nameSpace, char *name, Node *arg,
         DefElemAction defaction, int location);

extern GroupingSet *makeGroupingSet(GroupingSetKind kind, List *content, int location);

extern VacuumRelation *makeVacuumRelation(RangeVar *relation, Oid oid, List *va_cols);
# 41 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/nodes/nodeFuncs.h" 1
# 33 "/products1/postgres/PG12.1/include/server/nodes/nodeFuncs.h"
typedef _Bool (*check_function_callback) (Oid func_id, void *context);


extern Oid exprType(const Node *expr);
extern int32 exprTypmod(const Node *expr);
extern _Bool exprIsLengthCoercion(const Node *expr, int32 *coercedTypmod);
extern Node *relabel_to_typmod(Node *expr, int32 typmod);
extern Node *strip_implicit_coercions(Node *node);
extern _Bool expression_returns_set(Node *clause);

extern Oid exprCollation(const Node *expr);
extern Oid exprInputCollation(const Node *expr);
extern void exprSetCollation(Node *expr, Oid collation);
extern void exprSetInputCollation(Node *expr, Oid inputcollation);

extern int exprLocation(const Node *expr);

extern void fix_opfuncids(Node *node);
extern void set_opfuncid(OpExpr *opexpr);
extern void set_sa_opfuncid(ScalarArrayOpExpr *opexpr);


static inline _Bool
is_funcclause(const void *clause)
{
 return clause != ((void *)0) && ((((const Node*)(clause))->type) == T_FuncExpr);
}


static inline _Bool
is_opclause(const void *clause)
{
 return clause != ((void *)0) && ((((const Node*)(clause))->type) == T_OpExpr);
}


static inline Node *
get_leftop(const void *clause)
{
 const OpExpr *expr = (const OpExpr *) clause;

 if (expr->args != ((List *) ((void *)0)))
  return (Node *) ((list_head(expr->args))->data.ptr_value);
 else
  return ((void *)0);
}


static inline Node *
get_rightop(const void *clause)
{
 const OpExpr *expr = (const OpExpr *) clause;

 if (list_length(expr->args) >= 2)
  return (Node *) ((((list_head(expr->args))->next))->data.ptr_value);
 else
  return ((void *)0);
}


static inline _Bool
is_andclause(const void *clause)
{
 return (clause != ((void *)0) &&
   ((((const Node*)(clause))->type) == T_BoolExpr) &&
   ((const BoolExpr *) clause)->boolop == AND_EXPR);
}


static inline _Bool
is_orclause(const void *clause)
{
 return (clause != ((void *)0) &&
   ((((const Node*)(clause))->type) == T_BoolExpr) &&
   ((const BoolExpr *) clause)->boolop == OR_EXPR);
}


static inline _Bool
is_notclause(const void *clause)
{
 return (clause != ((void *)0) &&
   ((((const Node*)(clause))->type) == T_BoolExpr) &&
   ((const BoolExpr *) clause)->boolop == NOT_EXPR);
}


static inline Expr *
get_notclausearg(const void *notclause)
{
 return (Expr *) ((list_head(((const BoolExpr *) notclause)->args))->data.ptr_value);
}

extern _Bool check_functions_in_node(Node *node, check_function_callback checker,
         void *context);

extern _Bool expression_tree_walker(Node *node, _Bool (*walker) (),
           void *context);
extern Node *expression_tree_mutator(Node *node, Node *(*mutator) (),
          void *context);

extern _Bool query_tree_walker(Query *query, _Bool (*walker) (),
         void *context, int flags);
extern Query *query_tree_mutator(Query *query, Node *(*mutator) (),
         void *context, int flags);

extern _Bool range_table_walker(List *rtable, _Bool (*walker) (),
          void *context, int flags);
extern List *range_table_mutator(List *rtable, Node *(*mutator) (),
         void *context, int flags);

extern _Bool query_or_expression_tree_walker(Node *node, _Bool (*walker) (),
           void *context, int flags);
extern Node *query_or_expression_tree_mutator(Node *node, Node *(*mutator) (),
             void *context, int flags);

extern _Bool raw_expression_tree_walker(Node *node, _Bool (*walker) (),
            void *context);

struct PlanState;
extern _Bool planstate_tree_walker(struct PlanState *planstate, _Bool (*walker) (),
          void *context);
# 42 "db2_fdw.c" 2


# 1 "/products1/postgres/PG12.1/include/server/optimizer/cost.h" 1
# 34 "/products1/postgres/PG12.1/include/server/optimizer/cost.h"
typedef enum
{
 CONSTRAINT_EXCLUSION_OFF,
 CONSTRAINT_EXCLUSION_ON,
 CONSTRAINT_EXCLUSION_PARTITION
} ConstraintExclusionType;
# 48 "/products1/postgres/PG12.1/include/server/optimizer/cost.h"
extern Cost disable_cost;
extern int max_parallel_workers_per_gather;
extern _Bool enable_seqscan;
extern _Bool enable_indexscan;
extern _Bool enable_indexonlyscan;
extern _Bool enable_bitmapscan;
extern _Bool enable_tidscan;
extern _Bool enable_sort;
extern _Bool enable_hashagg;
extern _Bool enable_nestloop;
extern _Bool enable_material;
extern _Bool enable_mergejoin;
extern _Bool enable_hashjoin;
extern _Bool enable_gathermerge;
extern _Bool enable_partitionwise_join;
extern _Bool enable_partitionwise_aggregate;
extern _Bool enable_parallel_append;
extern _Bool enable_parallel_hash;
extern _Bool enable_partition_pruning;
extern int constraint_exclusion;

extern double index_pages_fetched(double tuples_fetched, BlockNumber pages,
          double index_pages, PlannerInfo *root);
extern void cost_seqscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
       ParamPathInfo *param_info);
extern void cost_samplescan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
       ParamPathInfo *param_info);
extern void cost_index(IndexPath *path, PlannerInfo *root,
        double loop_count, _Bool partial_path);
extern void cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
          ParamPathInfo *param_info,
          Path *bitmapqual, double loop_count);
extern void cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root);
extern void cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root);
extern void cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec);
extern void cost_tidscan(Path *path, PlannerInfo *root,
       RelOptInfo *baserel, List *tidquals, ParamPathInfo *param_info);
extern void cost_subqueryscan(SubqueryScanPath *path, PlannerInfo *root,
         RelOptInfo *baserel, ParamPathInfo *param_info);
extern void cost_functionscan(Path *path, PlannerInfo *root,
         RelOptInfo *baserel, ParamPathInfo *param_info);
extern void cost_valuesscan(Path *path, PlannerInfo *root,
       RelOptInfo *baserel, ParamPathInfo *param_info);
extern void cost_tablefuncscan(Path *path, PlannerInfo *root,
          RelOptInfo *baserel, ParamPathInfo *param_info);
extern void cost_ctescan(Path *path, PlannerInfo *root,
       RelOptInfo *baserel, ParamPathInfo *param_info);
extern void cost_namedtuplestorescan(Path *path, PlannerInfo *root,
          RelOptInfo *baserel, ParamPathInfo *param_info);
extern void cost_resultscan(Path *path, PlannerInfo *root,
       RelOptInfo *baserel, ParamPathInfo *param_info);
extern void cost_recursive_union(Path *runion, Path *nrterm, Path *rterm);
extern void cost_sort(Path *path, PlannerInfo *root,
       List *pathkeys, Cost input_cost, double tuples, int width,
       Cost comparison_cost, int sort_mem,
       double limit_tuples);
extern void cost_append(AppendPath *path);
extern void cost_merge_append(Path *path, PlannerInfo *root,
         List *pathkeys, int n_streams,
         Cost input_startup_cost, Cost input_total_cost,
         double tuples);
extern void cost_material(Path *path,
        Cost input_startup_cost, Cost input_total_cost,
        double tuples, int width);
extern void cost_agg(Path *path, PlannerInfo *root,
      AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
      int numGroupCols, double numGroups,
      List *quals,
      Cost input_startup_cost, Cost input_total_cost,
      double input_tuples);
extern void cost_windowagg(Path *path, PlannerInfo *root,
         List *windowFuncs, int numPartCols, int numOrderCols,
         Cost input_startup_cost, Cost input_total_cost,
         double input_tuples);
extern void cost_group(Path *path, PlannerInfo *root,
        int numGroupCols, double numGroups,
        List *quals,
        Cost input_startup_cost, Cost input_total_cost,
        double input_tuples);
extern void initial_cost_nestloop(PlannerInfo *root,
          JoinCostWorkspace *workspace,
          JoinType jointype,
          Path *outer_path, Path *inner_path,
          JoinPathExtraData *extra);
extern void final_cost_nestloop(PlannerInfo *root, NestPath *path,
        JoinCostWorkspace *workspace,
        JoinPathExtraData *extra);
extern void initial_cost_mergejoin(PlannerInfo *root,
           JoinCostWorkspace *workspace,
           JoinType jointype,
           List *mergeclauses,
           Path *outer_path, Path *inner_path,
           List *outersortkeys, List *innersortkeys,
           JoinPathExtraData *extra);
extern void final_cost_mergejoin(PlannerInfo *root, MergePath *path,
         JoinCostWorkspace *workspace,
         JoinPathExtraData *extra);
extern void initial_cost_hashjoin(PlannerInfo *root,
          JoinCostWorkspace *workspace,
          JoinType jointype,
          List *hashclauses,
          Path *outer_path, Path *inner_path,
          JoinPathExtraData *extra,
          _Bool parallel_hash);
extern void final_cost_hashjoin(PlannerInfo *root, HashPath *path,
        JoinCostWorkspace *workspace,
        JoinPathExtraData *extra);
extern void cost_gather(GatherPath *path, PlannerInfo *root,
      RelOptInfo *baserel, ParamPathInfo *param_info, double *rows);
extern void cost_gather_merge(GatherMergePath *path, PlannerInfo *root,
         RelOptInfo *rel, ParamPathInfo *param_info,
         Cost input_startup_cost, Cost input_total_cost,
         double *rows);
extern void cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan);
extern void cost_qual_eval(QualCost *cost, List *quals, PlannerInfo *root);
extern void cost_qual_eval_node(QualCost *cost, Node *qual, PlannerInfo *root);
extern void compute_semi_anti_join_factors(PlannerInfo *root,
             RelOptInfo *joinrel,
             RelOptInfo *outerrel,
             RelOptInfo *innerrel,
             JoinType jointype,
             SpecialJoinInfo *sjinfo,
             List *restrictlist,
             SemiAntiJoinFactors *semifactors);
extern void set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel);
extern double get_parameterized_baserel_size(PlannerInfo *root,
            RelOptInfo *rel,
            List *param_clauses);
extern double get_parameterized_joinrel_size(PlannerInfo *root,
            RelOptInfo *rel,
            Path *outer_path,
            Path *inner_path,
            SpecialJoinInfo *sjinfo,
            List *restrict_clauses);
extern void set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
            RelOptInfo *outer_rel,
            RelOptInfo *inner_rel,
            SpecialJoinInfo *sjinfo,
            List *restrictlist);
extern void set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel);
extern void set_function_size_estimates(PlannerInfo *root, RelOptInfo *rel);
extern void set_values_size_estimates(PlannerInfo *root, RelOptInfo *rel);
extern void set_cte_size_estimates(PlannerInfo *root, RelOptInfo *rel,
           double cte_rows);
extern void set_tablefunc_size_estimates(PlannerInfo *root, RelOptInfo *rel);
extern void set_namedtuplestore_size_estimates(PlannerInfo *root, RelOptInfo *rel);
extern void set_result_size_estimates(PlannerInfo *root, RelOptInfo *rel);
extern void set_foreign_size_estimates(PlannerInfo *root, RelOptInfo *rel);
extern PathTarget *set_pathtarget_cost_width(PlannerInfo *root, PathTarget *target);
extern double compute_bitmap_pages(PlannerInfo *root, RelOptInfo *baserel,
           Path *bitmapqual, int loop_count, Cost *cost, double *tuple);
# 45 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/optimizer/pathnode.h" 1
# 24 "/products1/postgres/PG12.1/include/server/optimizer/pathnode.h"
extern int compare_path_costs(Path *path1, Path *path2,
          CostSelector criterion);
extern int compare_fractional_path_costs(Path *path1, Path *path2,
            double fraction);
extern void set_cheapest(RelOptInfo *parent_rel);
extern void add_path(RelOptInfo *parent_rel, Path *new_path);
extern _Bool add_path_precheck(RelOptInfo *parent_rel,
         Cost startup_cost, Cost total_cost,
         List *pathkeys, Relids required_outer);
extern void add_partial_path(RelOptInfo *parent_rel, Path *new_path);
extern _Bool add_partial_path_precheck(RelOptInfo *parent_rel,
           Cost total_cost, List *pathkeys);

extern Path *create_seqscan_path(PlannerInfo *root, RelOptInfo *rel,
         Relids required_outer, int parallel_workers);
extern Path *create_samplescan_path(PlannerInfo *root, RelOptInfo *rel,
         Relids required_outer);
extern IndexPath *create_index_path(PlannerInfo *root,
         IndexOptInfo *index,
         List *indexclauses,
         List *indexorderbys,
         List *indexorderbycols,
         List *pathkeys,
         ScanDirection indexscandir,
         _Bool indexonly,
         Relids required_outer,
         double loop_count,
         _Bool partial_path);
extern BitmapHeapPath *create_bitmap_heap_path(PlannerInfo *root,
              RelOptInfo *rel,
              Path *bitmapqual,
              Relids required_outer,
              double loop_count,
              int parallel_degree);
extern BitmapAndPath *create_bitmap_and_path(PlannerInfo *root,
            RelOptInfo *rel,
            List *bitmapquals);
extern BitmapOrPath *create_bitmap_or_path(PlannerInfo *root,
             RelOptInfo *rel,
             List *bitmapquals);
extern TidPath *create_tidscan_path(PlannerInfo *root, RelOptInfo *rel,
         List *tidquals, Relids required_outer);
extern AppendPath *create_append_path(PlannerInfo *root, RelOptInfo *rel,
           List *subpaths, List *partial_subpaths,
           List *pathkeys, Relids required_outer,
           int parallel_workers, _Bool parallel_aware,
           List *partitioned_rels, double rows);
extern MergeAppendPath *create_merge_append_path(PlannerInfo *root,
             RelOptInfo *rel,
             List *subpaths,
             List *pathkeys,
             Relids required_outer,
             List *partitioned_rels);
extern GroupResultPath *create_group_result_path(PlannerInfo *root,
             RelOptInfo *rel,
             PathTarget *target,
             List *havingqual);
extern MaterialPath *create_material_path(RelOptInfo *rel, Path *subpath);
extern UniquePath *create_unique_path(PlannerInfo *root, RelOptInfo *rel,
           Path *subpath, SpecialJoinInfo *sjinfo);
extern GatherPath *create_gather_path(PlannerInfo *root,
           RelOptInfo *rel, Path *subpath, PathTarget *target,
           Relids required_outer, double *rows);
extern GatherMergePath *create_gather_merge_path(PlannerInfo *root,
             RelOptInfo *rel,
             Path *subpath,
             PathTarget *target,
             List *pathkeys,
             Relids required_outer,
             double *rows);
extern SubqueryScanPath *create_subqueryscan_path(PlannerInfo *root,
              RelOptInfo *rel, Path *subpath,
              List *pathkeys, Relids required_outer);
extern Path *create_functionscan_path(PlannerInfo *root, RelOptInfo *rel,
           List *pathkeys, Relids required_outer);
extern Path *create_valuesscan_path(PlannerInfo *root, RelOptInfo *rel,
         Relids required_outer);
extern Path *create_tablefuncscan_path(PlannerInfo *root, RelOptInfo *rel,
            Relids required_outer);
extern Path *create_ctescan_path(PlannerInfo *root, RelOptInfo *rel,
         Relids required_outer);
extern Path *create_namedtuplestorescan_path(PlannerInfo *root, RelOptInfo *rel,
            Relids required_outer);
extern Path *create_resultscan_path(PlannerInfo *root, RelOptInfo *rel,
         Relids required_outer);
extern Path *create_worktablescan_path(PlannerInfo *root, RelOptInfo *rel,
            Relids required_outer);
extern ForeignPath *create_foreignscan_path(PlannerInfo *root, RelOptInfo *rel,
           PathTarget *target,
           double rows, Cost startup_cost, Cost total_cost,
           List *pathkeys,
           Relids required_outer,
           Path *fdw_outerpath,
           List *fdw_private);
extern ForeignPath *create_foreign_join_path(PlannerInfo *root, RelOptInfo *rel,
            PathTarget *target,
            double rows, Cost startup_cost, Cost total_cost,
            List *pathkeys,
            Relids required_outer,
            Path *fdw_outerpath,
            List *fdw_private);
extern ForeignPath *create_foreign_upper_path(PlannerInfo *root, RelOptInfo *rel,
             PathTarget *target,
             double rows, Cost startup_cost, Cost total_cost,
             List *pathkeys,
             Path *fdw_outerpath,
             List *fdw_private);

extern Relids calc_nestloop_required_outer(Relids outerrelids,
             Relids outer_paramrels,
             Relids innerrelids,
             Relids inner_paramrels);
extern Relids calc_non_nestloop_required_outer(Path *outer_path, Path *inner_path);

extern NestPath *create_nestloop_path(PlannerInfo *root,
           RelOptInfo *joinrel,
           JoinType jointype,
           JoinCostWorkspace *workspace,
           JoinPathExtraData *extra,
           Path *outer_path,
           Path *inner_path,
           List *restrict_clauses,
           List *pathkeys,
           Relids required_outer);

extern MergePath *create_mergejoin_path(PlannerInfo *root,
          RelOptInfo *joinrel,
          JoinType jointype,
          JoinCostWorkspace *workspace,
          JoinPathExtraData *extra,
          Path *outer_path,
          Path *inner_path,
          List *restrict_clauses,
          List *pathkeys,
          Relids required_outer,
          List *mergeclauses,
          List *outersortkeys,
          List *innersortkeys);

extern HashPath *create_hashjoin_path(PlannerInfo *root,
           RelOptInfo *joinrel,
           JoinType jointype,
           JoinCostWorkspace *workspace,
           JoinPathExtraData *extra,
           Path *outer_path,
           Path *inner_path,
           _Bool parallel_hash,
           List *restrict_clauses,
           Relids required_outer,
           List *hashclauses);

extern ProjectionPath *create_projection_path(PlannerInfo *root,
             RelOptInfo *rel,
             Path *subpath,
             PathTarget *target);
extern Path *apply_projection_to_path(PlannerInfo *root,
           RelOptInfo *rel,
           Path *path,
           PathTarget *target);
extern ProjectSetPath *create_set_projection_path(PlannerInfo *root,
              RelOptInfo *rel,
              Path *subpath,
              PathTarget *target);
extern SortPath *create_sort_path(PlannerInfo *root,
          RelOptInfo *rel,
          Path *subpath,
          List *pathkeys,
          double limit_tuples);
extern GroupPath *create_group_path(PlannerInfo *root,
         RelOptInfo *rel,
         Path *subpath,
         List *groupClause,
         List *qual,
         double numGroups);
extern UpperUniquePath *create_upper_unique_path(PlannerInfo *root,
             RelOptInfo *rel,
             Path *subpath,
             int numCols,
             double numGroups);
extern AggPath *create_agg_path(PlannerInfo *root,
        RelOptInfo *rel,
        Path *subpath,
        PathTarget *target,
        AggStrategy aggstrategy,
        AggSplit aggsplit,
        List *groupClause,
        List *qual,
        const AggClauseCosts *aggcosts,
        double numGroups);
extern GroupingSetsPath *create_groupingsets_path(PlannerInfo *root,
              RelOptInfo *rel,
              Path *subpath,
              List *having_qual,
              AggStrategy aggstrategy,
              List *rollups,
              const AggClauseCosts *agg_costs,
              double numGroups);
extern MinMaxAggPath *create_minmaxagg_path(PlannerInfo *root,
           RelOptInfo *rel,
           PathTarget *target,
           List *mmaggregates,
           List *quals);
extern WindowAggPath *create_windowagg_path(PlannerInfo *root,
           RelOptInfo *rel,
           Path *subpath,
           PathTarget *target,
           List *windowFuncs,
           WindowClause *winclause);
extern SetOpPath *create_setop_path(PlannerInfo *root,
         RelOptInfo *rel,
         Path *subpath,
         SetOpCmd cmd,
         SetOpStrategy strategy,
         List *distinctList,
         AttrNumber flagColIdx,
         int firstFlag,
         double numGroups,
         double outputRows);
extern RecursiveUnionPath *create_recursiveunion_path(PlannerInfo *root,
               RelOptInfo *rel,
               Path *leftpath,
               Path *rightpath,
               PathTarget *target,
               List *distinctList,
               int wtParam,
               double numGroups);
extern LockRowsPath *create_lockrows_path(PlannerInfo *root, RelOptInfo *rel,
            Path *subpath, List *rowMarks, int epqParam);
extern ModifyTablePath *create_modifytable_path(PlannerInfo *root,
            RelOptInfo *rel,
            CmdType operation, _Bool canSetTag,
            Index nominalRelation, Index rootRelation,
            _Bool partColsUpdated,
            List *resultRelations, List *subpaths,
            List *subroots,
            List *withCheckOptionLists, List *returningLists,
            List *rowMarks, OnConflictExpr *onconflict,
            int epqParam);
extern LimitPath *create_limit_path(PlannerInfo *root, RelOptInfo *rel,
         Path *subpath,
         Node *limitOffset, Node *limitCount,
         int64 offset_est, int64 count_est);
extern void adjust_limit_rows_costs(double *rows,
         Cost *startup_cost, Cost *total_cost,
         int64 offset_est, int64 count_est);

extern Path *reparameterize_path(PlannerInfo *root, Path *path,
         Relids required_outer,
         double loop_count);
extern Path *reparameterize_path_by_child(PlannerInfo *root, Path *path,
            RelOptInfo *child_rel);




extern void setup_simple_rel_arrays(PlannerInfo *root);
extern void setup_append_rel_array(PlannerInfo *root);
extern void expand_planner_arrays(PlannerInfo *root, int add_size);
extern RelOptInfo *build_simple_rel(PlannerInfo *root, int relid,
         RelOptInfo *parent);
extern RelOptInfo *find_base_rel(PlannerInfo *root, int relid);
extern RelOptInfo *find_join_rel(PlannerInfo *root, Relids relids);
extern RelOptInfo *build_join_rel(PlannerInfo *root,
          Relids joinrelids,
          RelOptInfo *outer_rel,
          RelOptInfo *inner_rel,
          SpecialJoinInfo *sjinfo,
          List **restrictlist_ptr);
extern Relids min_join_parameterization(PlannerInfo *root,
          Relids joinrelids,
          RelOptInfo *outer_rel,
          RelOptInfo *inner_rel);
extern RelOptInfo *fetch_upper_rel(PlannerInfo *root, UpperRelationKind kind,
           Relids relids);
extern Relids find_childrel_parents(PlannerInfo *root, RelOptInfo *rel);
extern ParamPathInfo *get_baserel_parampathinfo(PlannerInfo *root,
            RelOptInfo *baserel,
            Relids required_outer);
extern ParamPathInfo *get_joinrel_parampathinfo(PlannerInfo *root,
            RelOptInfo *joinrel,
            Path *outer_path,
            Path *inner_path,
            SpecialJoinInfo *sjinfo,
            Relids required_outer,
            List **restrict_clauses);
extern ParamPathInfo *get_appendrel_parampathinfo(RelOptInfo *appendrel,
              Relids required_outer);
extern ParamPathInfo *find_param_path_info(RelOptInfo *rel,
             Relids required_outer);
extern RelOptInfo *build_child_join_rel(PlannerInfo *root,
          RelOptInfo *outer_rel, RelOptInfo *inner_rel,
          RelOptInfo *parent_joinrel, List *restrictlist,
          SpecialJoinInfo *sjinfo, JoinType jointype);
# 46 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/optimizer/planmain.h" 1
# 22 "/products1/postgres/PG12.1/include/server/optimizer/planmain.h"
extern double cursor_tuple_fraction;


typedef void (*query_pathkeys_callback) (PlannerInfo *root, void *extra);




extern RelOptInfo *query_planner(PlannerInfo *root,
         query_pathkeys_callback qp_callback, void *qp_extra);




extern void preprocess_minmax_aggregates(PlannerInfo *root);




extern Plan *create_plan(PlannerInfo *root, Path *best_path);
extern ForeignScan *make_foreignscan(List *qptlist, List *qpqual,
          Index scanrelid, List *fdw_exprs, List *fdw_private,
          List *fdw_scan_tlist, List *fdw_recheck_quals,
          Plan *outer_plan);
extern Plan *change_plan_targetlist(Plan *subplan, List *tlist,
         _Bool tlist_parallel_safe);
extern Plan *materialize_finished_plan(Plan *subplan);
extern _Bool is_projection_capable_path(Path *path);
extern _Bool is_projection_capable_plan(Plan *plan);


extern Sort *make_sort_from_sortclauses(List *sortcls, Plan *lefttree);
extern Agg *make_agg(List *tlist, List *qual,
      AggStrategy aggstrategy, AggSplit aggsplit,
      int numGroupCols, AttrNumber *grpColIdx, Oid *grpOperators, Oid *grpCollations,
      List *groupingSets, List *chain,
      double dNumGroups, Plan *lefttree);
extern Limit *make_limit(Plan *lefttree, Node *limitOffset, Node *limitCount);




extern int from_collapse_limit;
extern int join_collapse_limit;

extern void add_base_rels_to_query(PlannerInfo *root, Node *jtnode);
extern void add_other_rels_to_query(PlannerInfo *root);
extern void build_base_rel_tlists(PlannerInfo *root, List *final_tlist);
extern void add_vars_to_targetlist(PlannerInfo *root, List *vars,
           Relids where_needed, _Bool create_new_ph);
extern void find_lateral_references(PlannerInfo *root);
extern void create_lateral_join_info(PlannerInfo *root);
extern List *deconstruct_jointree(PlannerInfo *root);
extern void distribute_restrictinfo_to_rels(PlannerInfo *root,
           RestrictInfo *restrictinfo);
extern void process_implied_equality(PlannerInfo *root,
          Oid opno,
          Oid collation,
          Expr *item1,
          Expr *item2,
          Relids qualscope,
          Relids nullable_relids,
          Index security_level,
          _Bool below_outer_join,
          _Bool both_const);
extern RestrictInfo *build_implied_join_equality(Oid opno,
             Oid collation,
             Expr *item1,
             Expr *item2,
             Relids qualscope,
             Relids nullable_relids,
             Index security_level);
extern void match_foreign_keys_to_quals(PlannerInfo *root);




extern List *remove_useless_joins(PlannerInfo *root, List *joinlist);
extern void reduce_unique_semijoins(PlannerInfo *root);
extern _Bool query_supports_distinctness(Query *query);
extern _Bool query_is_distinct_for(Query *query, List *colnos, List *opids);
extern _Bool innerrel_is_unique(PlannerInfo *root,
          Relids joinrelids, Relids outerrelids, RelOptInfo *innerrel,
          JoinType jointype, List *restrictlist, _Bool force_cache);




extern Plan *set_plan_references(PlannerInfo *root, Plan *plan);
extern void record_plan_function_dependency(PlannerInfo *root, Oid funcid);
extern void record_plan_type_dependency(PlannerInfo *root, Oid typid);
extern _Bool extract_query_dependencies_walker(Node *node, PlannerInfo *root);
# 47 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/optimizer/restrictinfo.h" 1
# 24 "/products1/postgres/PG12.1/include/server/optimizer/restrictinfo.h"
extern RestrictInfo *make_restrictinfo(Expr *clause,
            _Bool is_pushed_down,
            _Bool outerjoin_delayed,
            _Bool pseudoconstant,
            Index security_level,
            Relids required_relids,
            Relids outer_relids,
            Relids nullable_relids);
extern RestrictInfo *commute_restrictinfo(RestrictInfo *rinfo, Oid comm_op);
extern _Bool restriction_is_or_clause(RestrictInfo *restrictinfo);
extern _Bool restriction_is_securely_promotable(RestrictInfo *restrictinfo,
              RelOptInfo *rel);
extern List *get_actual_clauses(List *restrictinfo_list);
extern List *extract_actual_clauses(List *restrictinfo_list,
         _Bool pseudoconstant);
extern void extract_actual_join_clauses(List *restrictinfo_list,
          Relids joinrelids,
          List **joinquals,
          List **otherquals);
extern _Bool join_clause_is_movable_to(RestrictInfo *rinfo, RelOptInfo *baserel);
extern _Bool join_clause_is_movable_into(RestrictInfo *rinfo,
          Relids currentrelids,
          Relids current_and_outer);
# 48 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/optimizer/tlist.h" 1
# 20 "/products1/postgres/PG12.1/include/server/optimizer/tlist.h"
extern TargetEntry *tlist_member(Expr *node, List *targetlist);
extern TargetEntry *tlist_member_ignore_relabel(Expr *node, List *targetlist);

extern List *add_to_flat_tlist(List *tlist, List *exprs);

extern List *get_tlist_exprs(List *tlist, _Bool includeJunk);

extern _Bool tlist_same_exprs(List *tlist1, List *tlist2);

extern _Bool tlist_same_datatypes(List *tlist, List *colTypes, _Bool junkOK);
extern _Bool tlist_same_collations(List *tlist, List *colCollations, _Bool junkOK);

extern void apply_tlist_labeling(List *dest_tlist, List *src_tlist);

extern Oid *extract_grouping_ops(List *groupClause);
extern Oid *extract_grouping_collations(List *groupClause, List *tlist);
extern AttrNumber *extract_grouping_cols(List *groupClause, List *tlist);
extern _Bool grouping_is_sortable(List *groupClause);
extern _Bool grouping_is_hashable(List *groupClause);

extern PathTarget *make_pathtarget_from_tlist(List *tlist);
extern List *make_tlist_from_pathtarget(PathTarget *target);
extern PathTarget *copy_pathtarget(PathTarget *src);
extern PathTarget *create_empty_pathtarget(void);
extern void add_column_to_pathtarget(PathTarget *target,
          Expr *expr, Index sortgroupref);
extern void add_new_column_to_pathtarget(PathTarget *target, Expr *expr);
extern void add_new_columns_to_pathtarget(PathTarget *target, List *exprs);
extern void apply_pathtarget_labeling_to_tlist(List *tlist, PathTarget *target);
extern void split_pathtarget_at_srfs(PlannerInfo *root,
          PathTarget *target, PathTarget *input_target,
          List **targets, List **targets_contain_srfs);
# 49 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/optimizer/optimizer.h" 1
# 49 "/products1/postgres/PG12.1/include/server/optimizer/optimizer.h"
struct PlannedStmt;
struct ParamListInfoData;
struct HeapTupleData;




extern Selectivity clause_selectivity(PlannerInfo *root,
           Node *clause,
           int varRelid,
           JoinType jointype,
           SpecialJoinInfo *sjinfo);
extern Selectivity clauselist_selectivity_simple(PlannerInfo *root,
             List *clauses,
             int varRelid,
             JoinType jointype,
             SpecialJoinInfo *sjinfo,
             Bitmapset *estimatedclauses);
extern Selectivity clauselist_selectivity(PlannerInfo *root,
            List *clauses,
            int varRelid,
            JoinType jointype,
            SpecialJoinInfo *sjinfo);




extern double seq_page_cost;
extern double random_page_cost;
extern double cpu_tuple_cost;
extern double cpu_index_tuple_cost;
extern double cpu_operator_cost;
extern double parallel_tuple_cost;
extern double parallel_setup_cost;
extern int effective_cache_size;

extern double clamp_row_est(double nrows);



extern _Bool is_pseudo_constant_for_index(Node *expr, IndexOptInfo *index);




typedef enum
{
 FORCE_PARALLEL_OFF,
 FORCE_PARALLEL_ON,
 FORCE_PARALLEL_REGRESS
} ForceParallelMode;


extern int force_parallel_mode;
extern _Bool parallel_leader_participation;

extern struct PlannedStmt *planner(Query *parse, int cursorOptions,
           struct ParamListInfoData *boundParams);

extern Expr *expression_planner(Expr *expr);
extern Expr *expression_planner_with_deps(Expr *expr,
            List **relationOids,
            List **invalItems);

extern _Bool plan_cluster_use_sort(Oid tableOid, Oid indexOid);
extern int plan_create_index_workers(Oid tableOid, Oid indexOid);



extern void extract_query_dependencies(Node *query,
            List **relationOids,
            List **invalItems,
            _Bool *hasRowSecurity);



extern Node *negate_clause(Node *node);
extern Expr *canonicalize_qual(Expr *qual, _Bool is_check);



extern _Bool contain_mutable_functions(Node *clause);
extern _Bool contain_volatile_functions(Node *clause);
extern _Bool contain_volatile_functions_not_nextval(Node *clause);

extern Node *eval_const_expressions(PlannerInfo *root, Node *node);

extern Node *estimate_expression_value(PlannerInfo *root, Node *node);

extern Expr *evaluate_expr(Expr *expr, Oid result_type, int32 result_typmod,
         Oid result_collation);

extern List *expand_function_arguments(List *args, Oid result_type,
            struct HeapTupleData *func_tuple);



extern _Bool predicate_implied_by(List *predicate_list, List *clause_list,
         _Bool weak);
extern _Bool predicate_refuted_by(List *predicate_list, List *clause_list,
         _Bool weak);



extern int count_nonjunk_tlist_entries(List *tlist);
extern TargetEntry *get_sortgroupref_tle(Index sortref,
           List *targetList);
extern TargetEntry *get_sortgroupclause_tle(SortGroupClause *sgClause,
           List *targetList);
extern Node *get_sortgroupclause_expr(SortGroupClause *sgClause,
           List *targetList);
extern List *get_sortgrouplist_exprs(List *sgClauses,
          List *targetList);
extern SortGroupClause *get_sortgroupref_clause(Index sortref,
            List *clauses);
extern SortGroupClause *get_sortgroupref_clause_noerr(Index sortref,
               List *clauses);
# 179 "/products1/postgres/PG12.1/include/server/optimizer/optimizer.h"
extern Bitmapset *pull_varnos(Node *node);
extern Bitmapset *pull_varnos_of_level(Node *node, int levelsup);
extern void pull_varattnos(Node *node, Index varno, Bitmapset **varattnos);
extern List *pull_vars_of_level(Node *node, int levelsup);
extern _Bool contain_var_clause(Node *node);
extern _Bool contain_vars_of_level(Node *node, int levelsup);
extern int locate_var_of_level(Node *node, int levelsup);
extern List *pull_var_clause(Node *node, int flags);
extern Node *flatten_join_alias_vars(Query *query, Node *node);
# 50 "db2_fdw.c" 2

# 1 "/products1/postgres/PG12.1/include/server/parser/parse_relation.h" 1
# 27 "/products1/postgres/PG12.1/include/server/parser/parse_relation.h"
typedef struct
{
 int distance;
 RangeTblEntry *rfirst;
 AttrNumber first;
 RangeTblEntry *rsecond;
 AttrNumber second;
} FuzzyAttrMatchState;


extern RangeTblEntry *refnameRangeTblEntry(ParseState *pstate,
             const char *schemaname,
             const char *refname,
             int location,
             int *sublevels_up);
extern CommonTableExpr *scanNameSpaceForCTE(ParseState *pstate,
           const char *refname,
           Index *ctelevelsup);
extern _Bool scanNameSpaceForENR(ParseState *pstate, const char *refname);
extern void checkNameSpaceConflicts(ParseState *pstate, List *namespace1,
         List *namespace2);
extern int RTERangeTablePosn(ParseState *pstate,
         RangeTblEntry *rte,
         int *sublevels_up);
extern RangeTblEntry *GetRTEByRangeTablePosn(ParseState *pstate,
            int varno,
            int sublevels_up);
extern CommonTableExpr *GetCTEForRTE(ParseState *pstate, RangeTblEntry *rte,
          int rtelevelsup);
extern Node *scanRTEForColumn(ParseState *pstate, RangeTblEntry *rte,
         const char *colname, int location,
         int fuzzy_rte_penalty, FuzzyAttrMatchState *fuzzystate);
extern Node *colNameToVar(ParseState *pstate, const char *colname, _Bool localonly,
        int location);
extern void markVarForSelectPriv(ParseState *pstate, Var *var,
         RangeTblEntry *rte);
extern Relation parserOpenTable(ParseState *pstate, const RangeVar *relation,
        int lockmode);
extern RangeTblEntry *addRangeTableEntry(ParseState *pstate,
           RangeVar *relation,
           Alias *alias,
           _Bool inh,
           _Bool inFromCl);
extern RangeTblEntry *addRangeTableEntryForRelation(ParseState *pstate,
             Relation rel,
             int lockmode,
             Alias *alias,
             _Bool inh,
             _Bool inFromCl);
extern RangeTblEntry *addRangeTableEntryForSubquery(ParseState *pstate,
             Query *subquery,
             Alias *alias,
             _Bool lateral,
             _Bool inFromCl);
extern RangeTblEntry *addRangeTableEntryForFunction(ParseState *pstate,
             List *funcnames,
             List *funcexprs,
             List *coldeflists,
             RangeFunction *rangefunc,
             _Bool lateral,
             _Bool inFromCl);
extern RangeTblEntry *addRangeTableEntryForValues(ParseState *pstate,
              List *exprs,
              List *coltypes,
              List *coltypmods,
              List *colcollations,
              Alias *alias,
              _Bool lateral,
              _Bool inFromCl);
extern RangeTblEntry *addRangeTableEntryForTableFunc(ParseState *pstate,
              TableFunc *tf,
              Alias *alias,
              _Bool lateral,
              _Bool inFromCl);
extern RangeTblEntry *addRangeTableEntryForJoin(ParseState *pstate,
            List *colnames,
            JoinType jointype,
            List *aliasvars,
            Alias *alias,
            _Bool inFromCl);
extern RangeTblEntry *addRangeTableEntryForCTE(ParseState *pstate,
              CommonTableExpr *cte,
              Index levelsup,
              RangeVar *rv,
              _Bool inFromCl);
extern RangeTblEntry *addRangeTableEntryForENR(ParseState *pstate,
              RangeVar *rv,
              _Bool inFromCl);
extern _Bool isLockedRefname(ParseState *pstate, const char *refname);
extern void addRTEtoQuery(ParseState *pstate, RangeTblEntry *rte,
        _Bool addToJoinList,
        _Bool addToRelNameSpace, _Bool addToVarNameSpace);
extern void errorMissingRTE(ParseState *pstate, RangeVar *relation) __attribute__((noreturn));
extern void errorMissingColumn(ParseState *pstate,
          const char *relname, const char *colname, int location) __attribute__((noreturn));
extern void expandRTE(RangeTblEntry *rte, int rtindex, int sublevels_up,
       int location, _Bool include_dropped,
       List **colnames, List **colvars);
extern List *expandRelAttrs(ParseState *pstate, RangeTblEntry *rte,
       int rtindex, int sublevels_up, int location);
extern int attnameAttNum(Relation rd, const char *attname, _Bool sysColOK);
extern const NameData *attnumAttName(Relation rd, int attid);
extern Oid attnumTypeId(Relation rd, int attid);
extern Oid attnumCollationId(Relation rd, int attid);
extern _Bool isQueryUsingTempRelation(Query *query);
# 52 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/parser/parsetree.h" 1
# 38 "/products1/postgres/PG12.1/include/server/parser/parsetree.h"
extern char *get_rte_attribute_name(RangeTblEntry *rte, AttrNumber attnum);





extern void get_rte_attribute_type(RangeTblEntry *rte, AttrNumber attnum,
           Oid *vartype, int32 *vartypmod, Oid *varcollid);





extern _Bool get_rte_attribute_is_dropped(RangeTblEntry *rte,
           AttrNumber attnum);







extern TargetEntry *get_tle_by_resno(List *tlist, AttrNumber resno);






extern RowMarkClause *get_parse_rowmark(Query *qry, Index rtindex);
# 53 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/port.h" 1
# 54 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/storage/ipc.h" 1
# 21 "/products1/postgres/PG12.1/include/server/storage/ipc.h"
typedef void (*pg_on_exit_callback) (int code, Datum arg);
typedef void (*shmem_startup_hook_type) (void);
# 65 "/products1/postgres/PG12.1/include/server/storage/ipc.h"
extern _Bool proc_exit_inprogress;
extern _Bool shmem_exit_inprogress;

extern void proc_exit(int code) __attribute__((noreturn));
extern void shmem_exit(int code);
extern void on_proc_exit(pg_on_exit_callback function, Datum arg);
extern void on_shmem_exit(pg_on_exit_callback function, Datum arg);
extern void before_shmem_exit(pg_on_exit_callback function, Datum arg);
extern void cancel_before_shmem_exit(pg_on_exit_callback function, Datum arg);
extern void on_exit_reset(void);


extern shmem_startup_hook_type shmem_startup_hook;

extern void CreateSharedMemoryAndSemaphores(int port);
# 55 "db2_fdw.c" 2

# 1 "/products1/postgres/PG12.1/include/server/tcop/tcopprot.h" 1
# 20 "/products1/postgres/PG12.1/include/server/tcop/tcopprot.h"
# 1 "/products1/postgres/PG12.1/include/server/storage/procsignal.h" 1
# 30 "/products1/postgres/PG12.1/include/server/storage/procsignal.h"
typedef enum
{
 PROCSIG_CATCHUP_INTERRUPT,
 PROCSIG_NOTIFY_INTERRUPT,
 PROCSIG_PARALLEL_MESSAGE,
 PROCSIG_WALSND_INIT_STOPPING,


 PROCSIG_RECOVERY_CONFLICT_DATABASE,
 PROCSIG_RECOVERY_CONFLICT_TABLESPACE,
 PROCSIG_RECOVERY_CONFLICT_LOCK,
 PROCSIG_RECOVERY_CONFLICT_SNAPSHOT,
 PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,
 PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK,

 NUM_PROCSIGNALS
} ProcSignalReason;




extern Size ProcSignalShmemSize(void);
extern void ProcSignalShmemInit(void);

extern void ProcSignalInit(int pss_idx);
extern int SendProcSignal(pid_t pid, ProcSignalReason reason,
         BackendId backendId);

extern void procsignal_sigusr1_handler(int postgres_signal_arg);
# 21 "/products1/postgres/PG12.1/include/server/tcop/tcopprot.h" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/guc.h" 1
# 68 "/products1/postgres/PG12.1/include/server/utils/guc.h"
typedef enum
{
 PGC_INTERNAL,
 PGC_POSTMASTER,
 PGC_SIGHUP,
 PGC_SU_BACKEND,
 PGC_BACKEND,
 PGC_SUSET,
 PGC_USERSET
} GucContext;
# 105 "/products1/postgres/PG12.1/include/server/utils/guc.h"
typedef enum
{
 PGC_S_DEFAULT,
 PGC_S_DYNAMIC_DEFAULT,
 PGC_S_ENV_VAR,
 PGC_S_FILE,
 PGC_S_ARGV,
 PGC_S_GLOBAL,
 PGC_S_DATABASE,
 PGC_S_USER,
 PGC_S_DATABASE_USER,
 PGC_S_CLIENT,
 PGC_S_OVERRIDE,
 PGC_S_INTERACTIVE,
 PGC_S_TEST,
 PGC_S_SESSION
} GucSource;
# 133 "/products1/postgres/PG12.1/include/server/utils/guc.h"
typedef struct ConfigVariable
{
 char *name;
 char *value;
 char *errmsg;
 char *filename;
 int sourceline;
 _Bool ignore;
 _Bool applied;
 struct ConfigVariable *next;
} ConfigVariable;

extern _Bool ParseConfigFile(const char *config_file, _Bool strict,
       const char *calling_file, int calling_lineno,
       int depth, int elevel,
       ConfigVariable **head_p, ConfigVariable **tail_p);
extern _Bool ParseConfigFp(FILE *fp, const char *config_file,
        int depth, int elevel,
        ConfigVariable **head_p, ConfigVariable **tail_p);
extern _Bool ParseConfigDirectory(const char *includedir,
         const char *calling_file, int calling_lineno,
         int depth, int elevel,
         ConfigVariable **head_p,
         ConfigVariable **tail_p);
extern void FreeConfigVariables(ConfigVariable *list);






struct config_enum_entry
{
 const char *name;
 int val;
 _Bool hidden;
};




typedef _Bool (*GucBoolCheckHook) (_Bool *newval, void **extra, GucSource source);
typedef _Bool (*GucIntCheckHook) (int *newval, void **extra, GucSource source);
typedef _Bool (*GucRealCheckHook) (double *newval, void **extra, GucSource source);
typedef _Bool (*GucStringCheckHook) (char **newval, void **extra, GucSource source);
typedef _Bool (*GucEnumCheckHook) (int *newval, void **extra, GucSource source);

typedef void (*GucBoolAssignHook) (_Bool newval, void *extra);
typedef void (*GucIntAssignHook) (int newval, void *extra);
typedef void (*GucRealAssignHook) (double newval, void *extra);
typedef void (*GucStringAssignHook) (const char *newval, void *extra);
typedef void (*GucEnumAssignHook) (int newval, void *extra);

typedef const char *(*GucShowHook) (void);




typedef enum
{

 GUC_ACTION_SET,
 GUC_ACTION_LOCAL,
 GUC_ACTION_SAVE
} GucAction;
# 236 "/products1/postgres/PG12.1/include/server/utils/guc.h"
extern _Bool log_duration;
extern _Bool Debug_print_plan;
extern _Bool Debug_print_parse;
extern _Bool Debug_print_rewritten;
extern _Bool Debug_pretty_print;

extern _Bool log_parser_stats;
extern _Bool log_planner_stats;
extern _Bool log_executor_stats;
extern _Bool log_statement_stats;
extern _Bool log_btree_build_stats;

extern _Bool check_function_bodies;
extern _Bool session_auth_is_superuser;

extern int log_min_error_statement;
extern int log_min_messages;
extern int client_min_messages;
extern int log_min_duration_statement;
extern int log_temp_files;
extern double log_xact_sample_rate;

extern int temp_file_limit;

extern int num_temp_buffers;

extern char *cluster_name;
extern char *ConfigFileName;
extern char *HbaFileName;
extern char *IdentFileName;
extern char *external_pid_file;

extern char *application_name;

extern int tcp_keepalives_idle;
extern int tcp_keepalives_interval;
extern int tcp_keepalives_count;
extern int tcp_user_timeout;


extern _Bool trace_sort;





extern void SetConfigOption(const char *name, const char *value,
       GucContext context, GucSource source);

extern void DefineCustomBoolVariable(const char *name,
          const char *short_desc,
          const char *long_desc,
          _Bool *valueAddr,
          _Bool bootValue,
          GucContext context,
          int flags,
          GucBoolCheckHook check_hook,
          GucBoolAssignHook assign_hook,
          GucShowHook show_hook);

extern void DefineCustomIntVariable(const char *name,
         const char *short_desc,
         const char *long_desc,
         int *valueAddr,
         int bootValue,
         int minValue,
         int maxValue,
         GucContext context,
         int flags,
         GucIntCheckHook check_hook,
         GucIntAssignHook assign_hook,
         GucShowHook show_hook);

extern void DefineCustomRealVariable(const char *name,
          const char *short_desc,
          const char *long_desc,
          double *valueAddr,
          double bootValue,
          double minValue,
          double maxValue,
          GucContext context,
          int flags,
          GucRealCheckHook check_hook,
          GucRealAssignHook assign_hook,
          GucShowHook show_hook);

extern void DefineCustomStringVariable(const char *name,
            const char *short_desc,
            const char *long_desc,
            char **valueAddr,
            const char *bootValue,
            GucContext context,
            int flags,
            GucStringCheckHook check_hook,
            GucStringAssignHook assign_hook,
            GucShowHook show_hook);

extern void DefineCustomEnumVariable(const char *name,
          const char *short_desc,
          const char *long_desc,
          int *valueAddr,
          int bootValue,
          const struct config_enum_entry *options,
          GucContext context,
          int flags,
          GucEnumCheckHook check_hook,
          GucEnumAssignHook assign_hook,
          GucShowHook show_hook);

extern void EmitWarningsOnPlaceholders(const char *className);

extern const char *GetConfigOption(const char *name, _Bool missing_ok,
           _Bool restrict_privileged);
extern const char *GetConfigOptionResetString(const char *name);
extern int GetConfigOptionFlags(const char *name, _Bool missing_ok);
extern void ProcessConfigFile(GucContext context);
extern void InitializeGUCOptions(void);
extern _Bool SelectConfigFiles(const char *userDoption, const char *progname);
extern void ResetAllOptions(void);
extern void AtStart_GUC(void);
extern int NewGUCNestLevel(void);
extern void AtEOXact_GUC(_Bool isCommit, int nestLevel);
extern void BeginReportingGUCOptions(void);
extern void ParseLongOption(const char *string, char **name, char **value);
extern _Bool parse_int(const char *value, int *result, int flags,
       const char **hintmsg);
extern _Bool parse_real(const char *value, double *result, int flags,
        const char **hintmsg);
extern int set_config_option(const char *name, const char *value,
         GucContext context, GucSource source,
         GucAction action, _Bool changeVal, int elevel,
         _Bool is_reload);
extern void AlterSystemSetConfigFile(AlterSystemStmt *setstmt);
extern char *GetConfigOptionByName(const char *name, const char **varname,
           _Bool missing_ok);
extern void GetConfigOptionByNum(int varnum, const char **values, _Bool *noshow);
extern int GetNumConfigOptions(void);

extern void SetPGVariable(const char *name, List *args, _Bool is_local);
extern void GetPGVariable(const char *name, DestReceiver *dest);
extern TupleDesc GetPGVariableResultDesc(const char *name);

extern void ExecSetVariableStmt(VariableSetStmt *stmt, _Bool isTopLevel);
extern char *ExtractSetVariableArgs(VariableSetStmt *stmt);

extern void ProcessGUCArray(ArrayType *array,
       GucContext context, GucSource source, GucAction action);
extern ArrayType *GUCArrayAdd(ArrayType *array, const char *name, const char *value);
extern ArrayType *GUCArrayDelete(ArrayType *array, const char *name);
extern ArrayType *GUCArrayReset(ArrayType *array);







extern Size EstimateGUCStateSpace(void);
extern void SerializeGUCState(Size maxsize, char *start_address);
extern void RestoreGUCState(void *gucstate);



extern char *GUC_check_errmsg_string;
extern char *GUC_check_errdetail_string;
extern char *GUC_check_errhint_string;

extern void GUC_check_errcode(int sqlerrcode);
# 425 "/products1/postgres/PG12.1/include/server/utils/guc.h"
extern _Bool check_default_tablespace(char **newval, void **extra, GucSource source);
extern _Bool check_temp_tablespaces(char **newval, void **extra, GucSource source);
extern void assign_temp_tablespaces(const char *newval, void *extra);


extern _Bool check_search_path(char **newval, void **extra, GucSource source);
extern void assign_search_path(const char *newval, void *extra);


extern _Bool check_wal_buffers(int *newval, void **extra, GucSource source);
extern void assign_xlog_sync_method(int new_sync_method, void *extra);
# 22 "/products1/postgres/PG12.1/include/server/tcop/tcopprot.h" 2






extern CommandDest whereToSendOutput;
extern const char *debug_query_string;
extern int max_stack_depth;
extern int PostAuthDelay;



typedef enum
{
 LOGSTMT_NONE,
 LOGSTMT_DDL,
 LOGSTMT_MOD,
 LOGSTMT_ALL
} LogStmtLevel;

extern int log_statement;

extern List *pg_parse_query(const char *query_string);
extern List *pg_analyze_and_rewrite(RawStmt *parsetree,
         const char *query_string,
         Oid *paramTypes, int numParams,
         QueryEnvironment *queryEnv);
extern List *pg_analyze_and_rewrite_params(RawStmt *parsetree,
             const char *query_string,
             ParserSetupHook parserSetup,
             void *parserSetupArg,
             QueryEnvironment *queryEnv);
extern PlannedStmt *pg_plan_query(Query *querytree, int cursorOptions,
          ParamListInfo boundParams);
extern List *pg_plan_queries(List *querytrees, int cursorOptions,
        ParamListInfo boundParams);

extern _Bool check_max_stack_depth(int *newval, void **extra, GucSource source);
extern void assign_max_stack_depth(int newval, void *extra);

extern void die(int postgres_signal_arg);
extern void quickdie(int postgres_signal_arg) __attribute__((noreturn));
extern void StatementCancelHandler(int postgres_signal_arg);
extern void FloatExceptionHandler(int postgres_signal_arg) __attribute__((noreturn));
extern void RecoveryConflictInterrupt(ProcSignalReason reason);

extern void ProcessClientReadInterrupt(_Bool blocked);
extern void ProcessClientWriteInterrupt(_Bool blocked);

extern void process_postgres_switches(int argc, char *argv[],
           GucContext ctx, const char **dbname);
extern void PostgresMain(int argc, char *argv[],
       const char *dbname,
       const char *username) __attribute__((noreturn));
extern long get_stack_depth_rlimit(void);
extern void ResetUsage(void);
extern void ShowUsage(const char *title);
extern int check_log_duration(char *msec_str, _Bool was_logged);
extern void set_debug_options(int debug_flag,
         GucContext context, GucSource source);
extern _Bool set_plan_disabling_options(const char *arg,
            GucContext context, GucSource source);
extern const char *get_stats_option_name(const char *arg);
# 57 "db2_fdw.c" 2

# 1 "/products1/postgres/PG12.1/include/server/utils/builtins.h" 1
# 19 "/products1/postgres/PG12.1/include/server/utils/builtins.h"
# 1 "/products1/postgres/PG12.1/include/server/utils/fmgrprotos.h" 1
# 24 "/products1/postgres/PG12.1/include/server/utils/fmgrprotos.h"
extern Datum heap_tableam_handler(FunctionCallInfo fcinfo);
extern Datum byteaout(FunctionCallInfo fcinfo);
extern Datum charout(FunctionCallInfo fcinfo);
extern Datum namein(FunctionCallInfo fcinfo);
extern Datum nameout(FunctionCallInfo fcinfo);
extern Datum int2in(FunctionCallInfo fcinfo);
extern Datum int2out(FunctionCallInfo fcinfo);
extern Datum int2vectorin(FunctionCallInfo fcinfo);
extern Datum int2vectorout(FunctionCallInfo fcinfo);
extern Datum int4in(FunctionCallInfo fcinfo);
extern Datum int4out(FunctionCallInfo fcinfo);
extern Datum regprocin(FunctionCallInfo fcinfo);
extern Datum regprocout(FunctionCallInfo fcinfo);
extern Datum textin(FunctionCallInfo fcinfo);
extern Datum textout(FunctionCallInfo fcinfo);
extern Datum tidin(FunctionCallInfo fcinfo);
extern Datum tidout(FunctionCallInfo fcinfo);
extern Datum xidin(FunctionCallInfo fcinfo);
extern Datum xidout(FunctionCallInfo fcinfo);
extern Datum cidin(FunctionCallInfo fcinfo);
extern Datum cidout(FunctionCallInfo fcinfo);
extern Datum oidvectorin(FunctionCallInfo fcinfo);
extern Datum oidvectorout(FunctionCallInfo fcinfo);
extern Datum boollt(FunctionCallInfo fcinfo);
extern Datum boolgt(FunctionCallInfo fcinfo);
extern Datum booleq(FunctionCallInfo fcinfo);
extern Datum chareq(FunctionCallInfo fcinfo);
extern Datum nameeq(FunctionCallInfo fcinfo);
extern Datum int2eq(FunctionCallInfo fcinfo);
extern Datum int2lt(FunctionCallInfo fcinfo);
extern Datum int4eq(FunctionCallInfo fcinfo);
extern Datum int4lt(FunctionCallInfo fcinfo);
extern Datum texteq(FunctionCallInfo fcinfo);
extern Datum xideq(FunctionCallInfo fcinfo);
extern Datum cideq(FunctionCallInfo fcinfo);
extern Datum charne(FunctionCallInfo fcinfo);
extern Datum charle(FunctionCallInfo fcinfo);
extern Datum chargt(FunctionCallInfo fcinfo);
extern Datum charge(FunctionCallInfo fcinfo);
extern Datum chartoi4(FunctionCallInfo fcinfo);
extern Datum i4tochar(FunctionCallInfo fcinfo);
extern Datum nameregexeq(FunctionCallInfo fcinfo);
extern Datum boolne(FunctionCallInfo fcinfo);
extern Datum pg_ddl_command_in(FunctionCallInfo fcinfo);
extern Datum pg_ddl_command_out(FunctionCallInfo fcinfo);
extern Datum pg_ddl_command_recv(FunctionCallInfo fcinfo);
extern Datum pgsql_version(FunctionCallInfo fcinfo);
extern Datum pg_ddl_command_send(FunctionCallInfo fcinfo);
extern Datum eqsel(FunctionCallInfo fcinfo);
extern Datum neqsel(FunctionCallInfo fcinfo);
extern Datum scalarltsel(FunctionCallInfo fcinfo);
extern Datum scalargtsel(FunctionCallInfo fcinfo);
extern Datum eqjoinsel(FunctionCallInfo fcinfo);
extern Datum neqjoinsel(FunctionCallInfo fcinfo);
extern Datum scalarltjoinsel(FunctionCallInfo fcinfo);
extern Datum scalargtjoinsel(FunctionCallInfo fcinfo);
extern Datum unknownin(FunctionCallInfo fcinfo);
extern Datum unknownout(FunctionCallInfo fcinfo);
extern Datum numeric_fac(FunctionCallInfo fcinfo);
extern Datum box_above_eq(FunctionCallInfo fcinfo);
extern Datum box_below_eq(FunctionCallInfo fcinfo);
extern Datum point_in(FunctionCallInfo fcinfo);
extern Datum point_out(FunctionCallInfo fcinfo);
extern Datum lseg_in(FunctionCallInfo fcinfo);
extern Datum lseg_out(FunctionCallInfo fcinfo);
extern Datum path_in(FunctionCallInfo fcinfo);
extern Datum path_out(FunctionCallInfo fcinfo);
extern Datum box_in(FunctionCallInfo fcinfo);
extern Datum box_out(FunctionCallInfo fcinfo);
extern Datum box_overlap(FunctionCallInfo fcinfo);
extern Datum box_ge(FunctionCallInfo fcinfo);
extern Datum box_gt(FunctionCallInfo fcinfo);
extern Datum box_eq(FunctionCallInfo fcinfo);
extern Datum box_lt(FunctionCallInfo fcinfo);
extern Datum box_le(FunctionCallInfo fcinfo);
extern Datum point_above(FunctionCallInfo fcinfo);
extern Datum point_left(FunctionCallInfo fcinfo);
extern Datum point_right(FunctionCallInfo fcinfo);
extern Datum point_below(FunctionCallInfo fcinfo);
extern Datum point_eq(FunctionCallInfo fcinfo);
extern Datum on_pb(FunctionCallInfo fcinfo);
extern Datum on_ppath(FunctionCallInfo fcinfo);
extern Datum box_center(FunctionCallInfo fcinfo);
extern Datum areasel(FunctionCallInfo fcinfo);
extern Datum areajoinsel(FunctionCallInfo fcinfo);
extern Datum int4mul(FunctionCallInfo fcinfo);
extern Datum int4ne(FunctionCallInfo fcinfo);
extern Datum int2ne(FunctionCallInfo fcinfo);
extern Datum int2gt(FunctionCallInfo fcinfo);
extern Datum int4gt(FunctionCallInfo fcinfo);
extern Datum int2le(FunctionCallInfo fcinfo);
extern Datum int4le(FunctionCallInfo fcinfo);
extern Datum int4ge(FunctionCallInfo fcinfo);
extern Datum int2ge(FunctionCallInfo fcinfo);
extern Datum int2mul(FunctionCallInfo fcinfo);
extern Datum int2div(FunctionCallInfo fcinfo);
extern Datum int4div(FunctionCallInfo fcinfo);
extern Datum int2mod(FunctionCallInfo fcinfo);
extern Datum int4mod(FunctionCallInfo fcinfo);
extern Datum textne(FunctionCallInfo fcinfo);
extern Datum int24eq(FunctionCallInfo fcinfo);
extern Datum int42eq(FunctionCallInfo fcinfo);
extern Datum int24lt(FunctionCallInfo fcinfo);
extern Datum int42lt(FunctionCallInfo fcinfo);
extern Datum int24gt(FunctionCallInfo fcinfo);
extern Datum int42gt(FunctionCallInfo fcinfo);
extern Datum int24ne(FunctionCallInfo fcinfo);
extern Datum int42ne(FunctionCallInfo fcinfo);
extern Datum int24le(FunctionCallInfo fcinfo);
extern Datum int42le(FunctionCallInfo fcinfo);
extern Datum int24ge(FunctionCallInfo fcinfo);
extern Datum int42ge(FunctionCallInfo fcinfo);
extern Datum int24mul(FunctionCallInfo fcinfo);
extern Datum int42mul(FunctionCallInfo fcinfo);
extern Datum int24div(FunctionCallInfo fcinfo);
extern Datum int42div(FunctionCallInfo fcinfo);
extern Datum int2pl(FunctionCallInfo fcinfo);
extern Datum int4pl(FunctionCallInfo fcinfo);
extern Datum int24pl(FunctionCallInfo fcinfo);
extern Datum int42pl(FunctionCallInfo fcinfo);
extern Datum int2mi(FunctionCallInfo fcinfo);
extern Datum int4mi(FunctionCallInfo fcinfo);
extern Datum int24mi(FunctionCallInfo fcinfo);
extern Datum int42mi(FunctionCallInfo fcinfo);
extern Datum oideq(FunctionCallInfo fcinfo);
extern Datum oidne(FunctionCallInfo fcinfo);
extern Datum box_same(FunctionCallInfo fcinfo);
extern Datum box_contain(FunctionCallInfo fcinfo);
extern Datum box_left(FunctionCallInfo fcinfo);
extern Datum box_overleft(FunctionCallInfo fcinfo);
extern Datum box_overright(FunctionCallInfo fcinfo);
extern Datum box_right(FunctionCallInfo fcinfo);
extern Datum box_contained(FunctionCallInfo fcinfo);
extern Datum box_contain_pt(FunctionCallInfo fcinfo);
extern Datum pg_node_tree_in(FunctionCallInfo fcinfo);
extern Datum pg_node_tree_out(FunctionCallInfo fcinfo);
extern Datum pg_node_tree_recv(FunctionCallInfo fcinfo);
extern Datum pg_node_tree_send(FunctionCallInfo fcinfo);
extern Datum float4in(FunctionCallInfo fcinfo);
extern Datum float4out(FunctionCallInfo fcinfo);
extern Datum float4mul(FunctionCallInfo fcinfo);
extern Datum float4div(FunctionCallInfo fcinfo);
extern Datum float4pl(FunctionCallInfo fcinfo);
extern Datum float4mi(FunctionCallInfo fcinfo);
extern Datum float4um(FunctionCallInfo fcinfo);
extern Datum float4abs(FunctionCallInfo fcinfo);
extern Datum float4_accum(FunctionCallInfo fcinfo);
extern Datum float4larger(FunctionCallInfo fcinfo);
extern Datum float4smaller(FunctionCallInfo fcinfo);
extern Datum int4um(FunctionCallInfo fcinfo);
extern Datum int2um(FunctionCallInfo fcinfo);
extern Datum float8in(FunctionCallInfo fcinfo);
extern Datum float8out(FunctionCallInfo fcinfo);
extern Datum float8mul(FunctionCallInfo fcinfo);
extern Datum float8div(FunctionCallInfo fcinfo);
extern Datum float8pl(FunctionCallInfo fcinfo);
extern Datum float8mi(FunctionCallInfo fcinfo);
extern Datum float8um(FunctionCallInfo fcinfo);
extern Datum float8abs(FunctionCallInfo fcinfo);
extern Datum float8_accum(FunctionCallInfo fcinfo);
extern Datum float8larger(FunctionCallInfo fcinfo);
extern Datum float8smaller(FunctionCallInfo fcinfo);
extern Datum lseg_center(FunctionCallInfo fcinfo);
extern Datum path_center(FunctionCallInfo fcinfo);
extern Datum poly_center(FunctionCallInfo fcinfo);
extern Datum dround(FunctionCallInfo fcinfo);
extern Datum dtrunc(FunctionCallInfo fcinfo);
extern Datum dsqrt(FunctionCallInfo fcinfo);
extern Datum dcbrt(FunctionCallInfo fcinfo);
extern Datum dpow(FunctionCallInfo fcinfo);
extern Datum dexp(FunctionCallInfo fcinfo);
extern Datum dlog1(FunctionCallInfo fcinfo);
extern Datum i2tod(FunctionCallInfo fcinfo);
extern Datum i2tof(FunctionCallInfo fcinfo);
extern Datum dtoi2(FunctionCallInfo fcinfo);
extern Datum ftoi2(FunctionCallInfo fcinfo);
extern Datum line_distance(FunctionCallInfo fcinfo);
extern Datum nameeqtext(FunctionCallInfo fcinfo);
extern Datum namelttext(FunctionCallInfo fcinfo);
extern Datum nameletext(FunctionCallInfo fcinfo);
extern Datum namegetext(FunctionCallInfo fcinfo);
extern Datum namegttext(FunctionCallInfo fcinfo);
extern Datum namenetext(FunctionCallInfo fcinfo);
extern Datum btnametextcmp(FunctionCallInfo fcinfo);
extern Datum texteqname(FunctionCallInfo fcinfo);
extern Datum textltname(FunctionCallInfo fcinfo);
extern Datum textlename(FunctionCallInfo fcinfo);
extern Datum textgename(FunctionCallInfo fcinfo);
extern Datum textgtname(FunctionCallInfo fcinfo);
extern Datum textnename(FunctionCallInfo fcinfo);
extern Datum bttextnamecmp(FunctionCallInfo fcinfo);
extern Datum nameconcatoid(FunctionCallInfo fcinfo);
extern Datum table_am_handler_in(FunctionCallInfo fcinfo);
extern Datum table_am_handler_out(FunctionCallInfo fcinfo);
extern Datum timeofday(FunctionCallInfo fcinfo);
extern Datum pg_nextoid(FunctionCallInfo fcinfo);
extern Datum float8_combine(FunctionCallInfo fcinfo);
extern Datum inter_sl(FunctionCallInfo fcinfo);
extern Datum inter_lb(FunctionCallInfo fcinfo);
extern Datum float48mul(FunctionCallInfo fcinfo);
extern Datum float48div(FunctionCallInfo fcinfo);
extern Datum float48pl(FunctionCallInfo fcinfo);
extern Datum float48mi(FunctionCallInfo fcinfo);
extern Datum float84mul(FunctionCallInfo fcinfo);
extern Datum float84div(FunctionCallInfo fcinfo);
extern Datum float84pl(FunctionCallInfo fcinfo);
extern Datum float84mi(FunctionCallInfo fcinfo);
extern Datum float4eq(FunctionCallInfo fcinfo);
extern Datum float4ne(FunctionCallInfo fcinfo);
extern Datum float4lt(FunctionCallInfo fcinfo);
extern Datum float4le(FunctionCallInfo fcinfo);
extern Datum float4gt(FunctionCallInfo fcinfo);
extern Datum float4ge(FunctionCallInfo fcinfo);
extern Datum float8eq(FunctionCallInfo fcinfo);
extern Datum float8ne(FunctionCallInfo fcinfo);
extern Datum float8lt(FunctionCallInfo fcinfo);
extern Datum float8le(FunctionCallInfo fcinfo);
extern Datum float8gt(FunctionCallInfo fcinfo);
extern Datum float8ge(FunctionCallInfo fcinfo);
extern Datum float48eq(FunctionCallInfo fcinfo);
extern Datum float48ne(FunctionCallInfo fcinfo);
extern Datum float48lt(FunctionCallInfo fcinfo);
extern Datum float48le(FunctionCallInfo fcinfo);
extern Datum float48gt(FunctionCallInfo fcinfo);
extern Datum float48ge(FunctionCallInfo fcinfo);
extern Datum float84eq(FunctionCallInfo fcinfo);
extern Datum float84ne(FunctionCallInfo fcinfo);
extern Datum float84lt(FunctionCallInfo fcinfo);
extern Datum float84le(FunctionCallInfo fcinfo);
extern Datum float84gt(FunctionCallInfo fcinfo);
extern Datum float84ge(FunctionCallInfo fcinfo);
extern Datum ftod(FunctionCallInfo fcinfo);
extern Datum dtof(FunctionCallInfo fcinfo);
extern Datum i2toi4(FunctionCallInfo fcinfo);
extern Datum i4toi2(FunctionCallInfo fcinfo);
extern Datum pg_jit_available(FunctionCallInfo fcinfo);
extern Datum i4tod(FunctionCallInfo fcinfo);
extern Datum dtoi4(FunctionCallInfo fcinfo);
extern Datum i4tof(FunctionCallInfo fcinfo);
extern Datum ftoi4(FunctionCallInfo fcinfo);
extern Datum width_bucket_float8(FunctionCallInfo fcinfo);
extern Datum json_in(FunctionCallInfo fcinfo);
extern Datum json_out(FunctionCallInfo fcinfo);
extern Datum json_recv(FunctionCallInfo fcinfo);
extern Datum json_send(FunctionCallInfo fcinfo);
extern Datum index_am_handler_in(FunctionCallInfo fcinfo);
extern Datum index_am_handler_out(FunctionCallInfo fcinfo);
extern Datum hashmacaddr8(FunctionCallInfo fcinfo);
extern Datum hash_aclitem(FunctionCallInfo fcinfo);
extern Datum bthandler(FunctionCallInfo fcinfo);
extern Datum hashhandler(FunctionCallInfo fcinfo);
extern Datum gisthandler(FunctionCallInfo fcinfo);
extern Datum ginhandler(FunctionCallInfo fcinfo);
extern Datum spghandler(FunctionCallInfo fcinfo);
extern Datum brinhandler(FunctionCallInfo fcinfo);
extern Datum scalarlesel(FunctionCallInfo fcinfo);
extern Datum scalargesel(FunctionCallInfo fcinfo);
extern Datum amvalidate(FunctionCallInfo fcinfo);
extern Datum poly_same(FunctionCallInfo fcinfo);
extern Datum poly_contain(FunctionCallInfo fcinfo);
extern Datum poly_left(FunctionCallInfo fcinfo);
extern Datum poly_overleft(FunctionCallInfo fcinfo);
extern Datum poly_overright(FunctionCallInfo fcinfo);
extern Datum poly_right(FunctionCallInfo fcinfo);
extern Datum poly_contained(FunctionCallInfo fcinfo);
extern Datum poly_overlap(FunctionCallInfo fcinfo);
extern Datum poly_in(FunctionCallInfo fcinfo);
extern Datum poly_out(FunctionCallInfo fcinfo);
extern Datum btint2cmp(FunctionCallInfo fcinfo);
extern Datum btint4cmp(FunctionCallInfo fcinfo);
extern Datum btfloat4cmp(FunctionCallInfo fcinfo);
extern Datum btfloat8cmp(FunctionCallInfo fcinfo);
extern Datum btoidcmp(FunctionCallInfo fcinfo);
extern Datum btcharcmp(FunctionCallInfo fcinfo);
extern Datum btnamecmp(FunctionCallInfo fcinfo);
extern Datum bttextcmp(FunctionCallInfo fcinfo);
extern Datum lseg_distance(FunctionCallInfo fcinfo);
extern Datum lseg_interpt(FunctionCallInfo fcinfo);
extern Datum dist_ps(FunctionCallInfo fcinfo);
extern Datum dist_pb(FunctionCallInfo fcinfo);
extern Datum dist_sb(FunctionCallInfo fcinfo);
extern Datum close_ps(FunctionCallInfo fcinfo);
extern Datum close_pb(FunctionCallInfo fcinfo);
extern Datum close_sb(FunctionCallInfo fcinfo);
extern Datum on_ps(FunctionCallInfo fcinfo);
extern Datum path_distance(FunctionCallInfo fcinfo);
extern Datum dist_ppath(FunctionCallInfo fcinfo);
extern Datum on_sb(FunctionCallInfo fcinfo);
extern Datum inter_sb(FunctionCallInfo fcinfo);
extern Datum text_to_array_null(FunctionCallInfo fcinfo);
extern Datum cash_cmp(FunctionCallInfo fcinfo);
extern Datum array_append(FunctionCallInfo fcinfo);
extern Datum array_prepend(FunctionCallInfo fcinfo);
extern Datum btarraycmp(FunctionCallInfo fcinfo);
extern Datum array_cat(FunctionCallInfo fcinfo);
extern Datum array_to_text_null(FunctionCallInfo fcinfo);
extern Datum scalarlejoinsel(FunctionCallInfo fcinfo);
extern Datum array_ne(FunctionCallInfo fcinfo);
extern Datum array_lt(FunctionCallInfo fcinfo);
extern Datum array_gt(FunctionCallInfo fcinfo);
extern Datum array_le(FunctionCallInfo fcinfo);
extern Datum text_to_array(FunctionCallInfo fcinfo);
extern Datum array_to_text(FunctionCallInfo fcinfo);
extern Datum array_ge(FunctionCallInfo fcinfo);
extern Datum scalargejoinsel(FunctionCallInfo fcinfo);
extern Datum hashmacaddr(FunctionCallInfo fcinfo);
extern Datum hashtext(FunctionCallInfo fcinfo);
extern Datum rtrim1(FunctionCallInfo fcinfo);
extern Datum btoidvectorcmp(FunctionCallInfo fcinfo);
extern Datum name_text(FunctionCallInfo fcinfo);
extern Datum text_name(FunctionCallInfo fcinfo);
extern Datum name_bpchar(FunctionCallInfo fcinfo);
extern Datum bpchar_name(FunctionCallInfo fcinfo);
extern Datum hashinet(FunctionCallInfo fcinfo);
extern Datum hashint4extended(FunctionCallInfo fcinfo);
extern Datum hash_numeric(FunctionCallInfo fcinfo);
extern Datum macaddr_in(FunctionCallInfo fcinfo);
extern Datum macaddr_out(FunctionCallInfo fcinfo);
extern Datum pg_num_nulls(FunctionCallInfo fcinfo);
extern Datum pg_num_nonnulls(FunctionCallInfo fcinfo);
extern Datum hashint2extended(FunctionCallInfo fcinfo);
extern Datum hashint8extended(FunctionCallInfo fcinfo);
extern Datum hashfloat4extended(FunctionCallInfo fcinfo);
extern Datum hashfloat8extended(FunctionCallInfo fcinfo);
extern Datum hashoidextended(FunctionCallInfo fcinfo);
extern Datum hashcharextended(FunctionCallInfo fcinfo);
extern Datum hashnameextended(FunctionCallInfo fcinfo);
extern Datum hashtextextended(FunctionCallInfo fcinfo);
extern Datum hashint2(FunctionCallInfo fcinfo);
extern Datum hashint4(FunctionCallInfo fcinfo);
extern Datum hashfloat4(FunctionCallInfo fcinfo);
extern Datum hashfloat8(FunctionCallInfo fcinfo);
extern Datum hashoid(FunctionCallInfo fcinfo);
extern Datum hashchar(FunctionCallInfo fcinfo);
extern Datum hashname(FunctionCallInfo fcinfo);
extern Datum hashvarlena(FunctionCallInfo fcinfo);
extern Datum hashoidvector(FunctionCallInfo fcinfo);
extern Datum text_larger(FunctionCallInfo fcinfo);
extern Datum text_smaller(FunctionCallInfo fcinfo);
extern Datum int8in(FunctionCallInfo fcinfo);
extern Datum int8out(FunctionCallInfo fcinfo);
extern Datum int8um(FunctionCallInfo fcinfo);
extern Datum int8pl(FunctionCallInfo fcinfo);
extern Datum int8mi(FunctionCallInfo fcinfo);
extern Datum int8mul(FunctionCallInfo fcinfo);
extern Datum int8div(FunctionCallInfo fcinfo);
extern Datum int8eq(FunctionCallInfo fcinfo);
extern Datum int8ne(FunctionCallInfo fcinfo);
extern Datum int8lt(FunctionCallInfo fcinfo);
extern Datum int8gt(FunctionCallInfo fcinfo);
extern Datum int8le(FunctionCallInfo fcinfo);
extern Datum int8ge(FunctionCallInfo fcinfo);
extern Datum int84eq(FunctionCallInfo fcinfo);
extern Datum int84ne(FunctionCallInfo fcinfo);
extern Datum int84lt(FunctionCallInfo fcinfo);
extern Datum int84gt(FunctionCallInfo fcinfo);
extern Datum int84le(FunctionCallInfo fcinfo);
extern Datum int84ge(FunctionCallInfo fcinfo);
extern Datum int84(FunctionCallInfo fcinfo);
extern Datum int48(FunctionCallInfo fcinfo);
extern Datum i8tod(FunctionCallInfo fcinfo);
extern Datum dtoi8(FunctionCallInfo fcinfo);
extern Datum array_larger(FunctionCallInfo fcinfo);
extern Datum array_smaller(FunctionCallInfo fcinfo);
extern Datum inet_abbrev(FunctionCallInfo fcinfo);
extern Datum cidr_abbrev(FunctionCallInfo fcinfo);
extern Datum inet_set_masklen(FunctionCallInfo fcinfo);
extern Datum oidvectorne(FunctionCallInfo fcinfo);
extern Datum hash_array(FunctionCallInfo fcinfo);
extern Datum cidr_set_masklen(FunctionCallInfo fcinfo);
extern Datum pg_indexam_has_property(FunctionCallInfo fcinfo);
extern Datum pg_index_has_property(FunctionCallInfo fcinfo);
extern Datum pg_index_column_has_property(FunctionCallInfo fcinfo);
extern Datum i8tof(FunctionCallInfo fcinfo);
extern Datum ftoi8(FunctionCallInfo fcinfo);
extern Datum namelt(FunctionCallInfo fcinfo);
extern Datum namele(FunctionCallInfo fcinfo);
extern Datum namegt(FunctionCallInfo fcinfo);
extern Datum namege(FunctionCallInfo fcinfo);
extern Datum namene(FunctionCallInfo fcinfo);
extern Datum bpchar(FunctionCallInfo fcinfo);
extern Datum varchar(FunctionCallInfo fcinfo);
extern Datum pg_indexam_progress_phasename(FunctionCallInfo fcinfo);
extern Datum oidvectorlt(FunctionCallInfo fcinfo);
extern Datum oidvectorle(FunctionCallInfo fcinfo);
extern Datum oidvectoreq(FunctionCallInfo fcinfo);
extern Datum oidvectorge(FunctionCallInfo fcinfo);
extern Datum oidvectorgt(FunctionCallInfo fcinfo);
extern Datum network_network(FunctionCallInfo fcinfo);
extern Datum network_netmask(FunctionCallInfo fcinfo);
extern Datum network_masklen(FunctionCallInfo fcinfo);
extern Datum network_broadcast(FunctionCallInfo fcinfo);
extern Datum network_host(FunctionCallInfo fcinfo);
extern Datum current_user(FunctionCallInfo fcinfo);
extern Datum network_family(FunctionCallInfo fcinfo);
extern Datum int82(FunctionCallInfo fcinfo);
extern Datum be_lo_create(FunctionCallInfo fcinfo);
extern Datum oidlt(FunctionCallInfo fcinfo);
extern Datum oidle(FunctionCallInfo fcinfo);
extern Datum byteaoctetlen(FunctionCallInfo fcinfo);
extern Datum byteaGetByte(FunctionCallInfo fcinfo);
extern Datum byteaSetByte(FunctionCallInfo fcinfo);
extern Datum byteaGetBit(FunctionCallInfo fcinfo);
extern Datum byteaSetBit(FunctionCallInfo fcinfo);
extern Datum dist_pl(FunctionCallInfo fcinfo);
extern Datum dist_lb(FunctionCallInfo fcinfo);
extern Datum dist_sl(FunctionCallInfo fcinfo);
extern Datum dist_cpoly(FunctionCallInfo fcinfo);
extern Datum poly_distance(FunctionCallInfo fcinfo);
extern Datum network_show(FunctionCallInfo fcinfo);
extern Datum text_lt(FunctionCallInfo fcinfo);
extern Datum text_le(FunctionCallInfo fcinfo);
extern Datum text_gt(FunctionCallInfo fcinfo);
extern Datum text_ge(FunctionCallInfo fcinfo);
extern Datum array_eq(FunctionCallInfo fcinfo);
extern Datum session_user(FunctionCallInfo fcinfo);
extern Datum array_dims(FunctionCallInfo fcinfo);
extern Datum array_ndims(FunctionCallInfo fcinfo);
extern Datum byteaoverlay(FunctionCallInfo fcinfo);
extern Datum array_in(FunctionCallInfo fcinfo);
extern Datum array_out(FunctionCallInfo fcinfo);
extern Datum byteaoverlay_no_len(FunctionCallInfo fcinfo);
extern Datum macaddr_trunc(FunctionCallInfo fcinfo);
extern Datum int28(FunctionCallInfo fcinfo);
extern Datum be_lo_import(FunctionCallInfo fcinfo);
extern Datum be_lo_export(FunctionCallInfo fcinfo);
extern Datum int4inc(FunctionCallInfo fcinfo);
extern Datum be_lo_import_with_oid(FunctionCallInfo fcinfo);
extern Datum int4larger(FunctionCallInfo fcinfo);
extern Datum int4smaller(FunctionCallInfo fcinfo);
extern Datum int2larger(FunctionCallInfo fcinfo);
extern Datum int2smaller(FunctionCallInfo fcinfo);
extern Datum hashvarlenaextended(FunctionCallInfo fcinfo);
extern Datum hashoidvectorextended(FunctionCallInfo fcinfo);
extern Datum hash_aclitem_extended(FunctionCallInfo fcinfo);
extern Datum hashmacaddrextended(FunctionCallInfo fcinfo);
extern Datum hashinetextended(FunctionCallInfo fcinfo);
extern Datum hash_numeric_extended(FunctionCallInfo fcinfo);
extern Datum hashmacaddr8extended(FunctionCallInfo fcinfo);
extern Datum hash_array_extended(FunctionCallInfo fcinfo);
extern Datum pg_client_encoding(FunctionCallInfo fcinfo);
extern Datum current_query(FunctionCallInfo fcinfo);
extern Datum macaddr_eq(FunctionCallInfo fcinfo);
extern Datum macaddr_lt(FunctionCallInfo fcinfo);
extern Datum macaddr_le(FunctionCallInfo fcinfo);
extern Datum macaddr_gt(FunctionCallInfo fcinfo);
extern Datum macaddr_ge(FunctionCallInfo fcinfo);
extern Datum macaddr_ne(FunctionCallInfo fcinfo);
extern Datum macaddr_cmp(FunctionCallInfo fcinfo);
extern Datum int82pl(FunctionCallInfo fcinfo);
extern Datum int82mi(FunctionCallInfo fcinfo);
extern Datum int82mul(FunctionCallInfo fcinfo);
extern Datum int82div(FunctionCallInfo fcinfo);
extern Datum int28pl(FunctionCallInfo fcinfo);
extern Datum btint8cmp(FunctionCallInfo fcinfo);
extern Datum cash_mul_flt4(FunctionCallInfo fcinfo);
extern Datum cash_div_flt4(FunctionCallInfo fcinfo);
extern Datum flt4_mul_cash(FunctionCallInfo fcinfo);
extern Datum textpos(FunctionCallInfo fcinfo);
extern Datum textlike(FunctionCallInfo fcinfo);
extern Datum textnlike(FunctionCallInfo fcinfo);
extern Datum int48eq(FunctionCallInfo fcinfo);
extern Datum int48ne(FunctionCallInfo fcinfo);
extern Datum int48lt(FunctionCallInfo fcinfo);
extern Datum int48gt(FunctionCallInfo fcinfo);
extern Datum int48le(FunctionCallInfo fcinfo);
extern Datum int48ge(FunctionCallInfo fcinfo);
extern Datum namelike(FunctionCallInfo fcinfo);
extern Datum namenlike(FunctionCallInfo fcinfo);
extern Datum char_bpchar(FunctionCallInfo fcinfo);
extern Datum current_database(FunctionCallInfo fcinfo);
extern Datum int4_mul_cash(FunctionCallInfo fcinfo);
extern Datum int2_mul_cash(FunctionCallInfo fcinfo);
extern Datum cash_mul_int4(FunctionCallInfo fcinfo);
extern Datum cash_div_int4(FunctionCallInfo fcinfo);
extern Datum cash_mul_int2(FunctionCallInfo fcinfo);
extern Datum cash_div_int2(FunctionCallInfo fcinfo);
extern Datum lower(FunctionCallInfo fcinfo);
extern Datum upper(FunctionCallInfo fcinfo);
extern Datum initcap(FunctionCallInfo fcinfo);
extern Datum lpad(FunctionCallInfo fcinfo);
extern Datum rpad(FunctionCallInfo fcinfo);
extern Datum ltrim(FunctionCallInfo fcinfo);
extern Datum rtrim(FunctionCallInfo fcinfo);
extern Datum text_substr(FunctionCallInfo fcinfo);
extern Datum translate(FunctionCallInfo fcinfo);
extern Datum ltrim1(FunctionCallInfo fcinfo);
extern Datum text_substr_no_len(FunctionCallInfo fcinfo);
extern Datum btrim(FunctionCallInfo fcinfo);
extern Datum btrim1(FunctionCallInfo fcinfo);
extern Datum cash_in(FunctionCallInfo fcinfo);
extern Datum cash_out(FunctionCallInfo fcinfo);
extern Datum cash_eq(FunctionCallInfo fcinfo);
extern Datum cash_ne(FunctionCallInfo fcinfo);
extern Datum cash_lt(FunctionCallInfo fcinfo);
extern Datum cash_le(FunctionCallInfo fcinfo);
extern Datum cash_gt(FunctionCallInfo fcinfo);
extern Datum cash_ge(FunctionCallInfo fcinfo);
extern Datum cash_pl(FunctionCallInfo fcinfo);
extern Datum cash_mi(FunctionCallInfo fcinfo);
extern Datum cash_mul_flt8(FunctionCallInfo fcinfo);
extern Datum cash_div_flt8(FunctionCallInfo fcinfo);
extern Datum cashlarger(FunctionCallInfo fcinfo);
extern Datum cashsmaller(FunctionCallInfo fcinfo);
extern Datum inet_in(FunctionCallInfo fcinfo);
extern Datum inet_out(FunctionCallInfo fcinfo);
extern Datum flt8_mul_cash(FunctionCallInfo fcinfo);
extern Datum network_eq(FunctionCallInfo fcinfo);
extern Datum network_lt(FunctionCallInfo fcinfo);
extern Datum network_le(FunctionCallInfo fcinfo);
extern Datum network_gt(FunctionCallInfo fcinfo);
extern Datum network_ge(FunctionCallInfo fcinfo);
extern Datum network_ne(FunctionCallInfo fcinfo);
extern Datum network_cmp(FunctionCallInfo fcinfo);
extern Datum network_sub(FunctionCallInfo fcinfo);
extern Datum network_subeq(FunctionCallInfo fcinfo);
extern Datum network_sup(FunctionCallInfo fcinfo);
extern Datum network_supeq(FunctionCallInfo fcinfo);
extern Datum cash_words(FunctionCallInfo fcinfo);
extern Datum generate_series_timestamp(FunctionCallInfo fcinfo);
extern Datum generate_series_timestamptz(FunctionCallInfo fcinfo);
extern Datum int28mi(FunctionCallInfo fcinfo);
extern Datum int28mul(FunctionCallInfo fcinfo);
extern Datum text_char(FunctionCallInfo fcinfo);
extern Datum int8mod(FunctionCallInfo fcinfo);
extern Datum char_text(FunctionCallInfo fcinfo);
extern Datum int28div(FunctionCallInfo fcinfo);
extern Datum hashint8(FunctionCallInfo fcinfo);
extern Datum be_lo_open(FunctionCallInfo fcinfo);
extern Datum be_lo_close(FunctionCallInfo fcinfo);
extern Datum be_loread(FunctionCallInfo fcinfo);
extern Datum be_lowrite(FunctionCallInfo fcinfo);
extern Datum be_lo_lseek(FunctionCallInfo fcinfo);
extern Datum be_lo_creat(FunctionCallInfo fcinfo);
extern Datum be_lo_tell(FunctionCallInfo fcinfo);
extern Datum on_pl(FunctionCallInfo fcinfo);
extern Datum on_sl(FunctionCallInfo fcinfo);
extern Datum close_pl(FunctionCallInfo fcinfo);
extern Datum close_sl(FunctionCallInfo fcinfo);
extern Datum close_lb(FunctionCallInfo fcinfo);
extern Datum be_lo_unlink(FunctionCallInfo fcinfo);
extern Datum hashbpcharextended(FunctionCallInfo fcinfo);
extern Datum path_inter(FunctionCallInfo fcinfo);
extern Datum box_area(FunctionCallInfo fcinfo);
extern Datum box_width(FunctionCallInfo fcinfo);
extern Datum box_height(FunctionCallInfo fcinfo);
extern Datum box_distance(FunctionCallInfo fcinfo);
extern Datum path_area(FunctionCallInfo fcinfo);
extern Datum box_intersect(FunctionCallInfo fcinfo);
extern Datum box_diagonal(FunctionCallInfo fcinfo);
extern Datum path_n_lt(FunctionCallInfo fcinfo);
extern Datum path_n_gt(FunctionCallInfo fcinfo);
extern Datum path_n_eq(FunctionCallInfo fcinfo);
extern Datum path_n_le(FunctionCallInfo fcinfo);
extern Datum path_n_ge(FunctionCallInfo fcinfo);
extern Datum path_length(FunctionCallInfo fcinfo);
extern Datum point_ne(FunctionCallInfo fcinfo);
extern Datum point_vert(FunctionCallInfo fcinfo);
extern Datum point_horiz(FunctionCallInfo fcinfo);
extern Datum point_distance(FunctionCallInfo fcinfo);
extern Datum point_slope(FunctionCallInfo fcinfo);
extern Datum lseg_construct(FunctionCallInfo fcinfo);
extern Datum lseg_intersect(FunctionCallInfo fcinfo);
extern Datum lseg_parallel(FunctionCallInfo fcinfo);
extern Datum lseg_perp(FunctionCallInfo fcinfo);
extern Datum lseg_vertical(FunctionCallInfo fcinfo);
extern Datum lseg_horizontal(FunctionCallInfo fcinfo);
extern Datum lseg_eq(FunctionCallInfo fcinfo);
extern Datum be_lo_truncate(FunctionCallInfo fcinfo);
extern Datum textlike_support(FunctionCallInfo fcinfo);
extern Datum texticregexeq_support(FunctionCallInfo fcinfo);
extern Datum texticlike_support(FunctionCallInfo fcinfo);
extern Datum timestamptz_izone(FunctionCallInfo fcinfo);
extern Datum gist_point_compress(FunctionCallInfo fcinfo);
extern Datum aclitemin(FunctionCallInfo fcinfo);
extern Datum aclitemout(FunctionCallInfo fcinfo);
extern Datum aclinsert(FunctionCallInfo fcinfo);
extern Datum aclremove(FunctionCallInfo fcinfo);
extern Datum aclcontains(FunctionCallInfo fcinfo);
extern Datum getdatabaseencoding(FunctionCallInfo fcinfo);
extern Datum bpcharin(FunctionCallInfo fcinfo);
extern Datum bpcharout(FunctionCallInfo fcinfo);
extern Datum varcharin(FunctionCallInfo fcinfo);
extern Datum varcharout(FunctionCallInfo fcinfo);
extern Datum bpchareq(FunctionCallInfo fcinfo);
extern Datum bpcharlt(FunctionCallInfo fcinfo);
extern Datum bpcharle(FunctionCallInfo fcinfo);
extern Datum bpchargt(FunctionCallInfo fcinfo);
extern Datum bpcharge(FunctionCallInfo fcinfo);
extern Datum bpcharne(FunctionCallInfo fcinfo);
extern Datum aclitem_eq(FunctionCallInfo fcinfo);
extern Datum bpchar_larger(FunctionCallInfo fcinfo);
extern Datum bpchar_smaller(FunctionCallInfo fcinfo);
extern Datum pg_prepared_xact(FunctionCallInfo fcinfo);
extern Datum generate_series_step_int4(FunctionCallInfo fcinfo);
extern Datum generate_series_int4(FunctionCallInfo fcinfo);
extern Datum generate_series_step_int8(FunctionCallInfo fcinfo);
extern Datum generate_series_int8(FunctionCallInfo fcinfo);
extern Datum bpcharcmp(FunctionCallInfo fcinfo);
extern Datum text_regclass(FunctionCallInfo fcinfo);
extern Datum hashbpchar(FunctionCallInfo fcinfo);
extern Datum format_type(FunctionCallInfo fcinfo);
extern Datum date_in(FunctionCallInfo fcinfo);
extern Datum date_out(FunctionCallInfo fcinfo);
extern Datum date_eq(FunctionCallInfo fcinfo);
extern Datum date_lt(FunctionCallInfo fcinfo);
extern Datum date_le(FunctionCallInfo fcinfo);
extern Datum date_gt(FunctionCallInfo fcinfo);
extern Datum date_ge(FunctionCallInfo fcinfo);
extern Datum date_ne(FunctionCallInfo fcinfo);
extern Datum date_cmp(FunctionCallInfo fcinfo);
extern Datum time_lt(FunctionCallInfo fcinfo);
extern Datum time_le(FunctionCallInfo fcinfo);
extern Datum time_gt(FunctionCallInfo fcinfo);
extern Datum time_ge(FunctionCallInfo fcinfo);
extern Datum time_ne(FunctionCallInfo fcinfo);
extern Datum time_cmp(FunctionCallInfo fcinfo);
extern Datum date_larger(FunctionCallInfo fcinfo);
extern Datum date_smaller(FunctionCallInfo fcinfo);
extern Datum date_mi(FunctionCallInfo fcinfo);
extern Datum date_pli(FunctionCallInfo fcinfo);
extern Datum date_mii(FunctionCallInfo fcinfo);
extern Datum time_in(FunctionCallInfo fcinfo);
extern Datum time_out(FunctionCallInfo fcinfo);
extern Datum time_eq(FunctionCallInfo fcinfo);
extern Datum circle_add_pt(FunctionCallInfo fcinfo);
extern Datum circle_sub_pt(FunctionCallInfo fcinfo);
extern Datum circle_mul_pt(FunctionCallInfo fcinfo);
extern Datum circle_div_pt(FunctionCallInfo fcinfo);
extern Datum timestamptz_in(FunctionCallInfo fcinfo);
extern Datum timestamptz_out(FunctionCallInfo fcinfo);
extern Datum timestamp_eq(FunctionCallInfo fcinfo);
extern Datum timestamp_ne(FunctionCallInfo fcinfo);
extern Datum timestamp_lt(FunctionCallInfo fcinfo);
extern Datum timestamp_le(FunctionCallInfo fcinfo);
extern Datum timestamp_ge(FunctionCallInfo fcinfo);
extern Datum timestamp_gt(FunctionCallInfo fcinfo);
extern Datum float8_timestamptz(FunctionCallInfo fcinfo);
extern Datum timestamptz_zone(FunctionCallInfo fcinfo);
extern Datum interval_in(FunctionCallInfo fcinfo);
extern Datum interval_out(FunctionCallInfo fcinfo);
extern Datum interval_eq(FunctionCallInfo fcinfo);
extern Datum interval_ne(FunctionCallInfo fcinfo);
extern Datum interval_lt(FunctionCallInfo fcinfo);
extern Datum interval_le(FunctionCallInfo fcinfo);
extern Datum interval_ge(FunctionCallInfo fcinfo);
extern Datum interval_gt(FunctionCallInfo fcinfo);
extern Datum interval_um(FunctionCallInfo fcinfo);
extern Datum interval_pl(FunctionCallInfo fcinfo);
extern Datum interval_mi(FunctionCallInfo fcinfo);
extern Datum timestamptz_part(FunctionCallInfo fcinfo);
extern Datum interval_part(FunctionCallInfo fcinfo);
extern Datum network_subset_support(FunctionCallInfo fcinfo);
extern Datum date_timestamptz(FunctionCallInfo fcinfo);
extern Datum interval_justify_hours(FunctionCallInfo fcinfo);
extern Datum timestamptz_date(FunctionCallInfo fcinfo);
extern Datum xid_age(FunctionCallInfo fcinfo);
extern Datum timestamp_mi(FunctionCallInfo fcinfo);
extern Datum timestamptz_pl_interval(FunctionCallInfo fcinfo);
extern Datum timestamptz_mi_interval(FunctionCallInfo fcinfo);
extern Datum generate_subscripts(FunctionCallInfo fcinfo);
extern Datum generate_subscripts_nodir(FunctionCallInfo fcinfo);
extern Datum array_fill(FunctionCallInfo fcinfo);
extern Datum dlog10(FunctionCallInfo fcinfo);
extern Datum timestamp_smaller(FunctionCallInfo fcinfo);
extern Datum timestamp_larger(FunctionCallInfo fcinfo);
extern Datum interval_smaller(FunctionCallInfo fcinfo);
extern Datum interval_larger(FunctionCallInfo fcinfo);
extern Datum timestamptz_age(FunctionCallInfo fcinfo);
extern Datum interval_scale(FunctionCallInfo fcinfo);
extern Datum timestamptz_trunc(FunctionCallInfo fcinfo);
extern Datum interval_trunc(FunctionCallInfo fcinfo);
extern Datum int8inc(FunctionCallInfo fcinfo);
extern Datum int8abs(FunctionCallInfo fcinfo);
extern Datum int8larger(FunctionCallInfo fcinfo);
extern Datum int8smaller(FunctionCallInfo fcinfo);
extern Datum texticregexeq(FunctionCallInfo fcinfo);
extern Datum texticregexne(FunctionCallInfo fcinfo);
extern Datum nameicregexeq(FunctionCallInfo fcinfo);
extern Datum nameicregexne(FunctionCallInfo fcinfo);
extern Datum boolin(FunctionCallInfo fcinfo);
extern Datum boolout(FunctionCallInfo fcinfo);
extern Datum byteain(FunctionCallInfo fcinfo);
extern Datum charin(FunctionCallInfo fcinfo);
extern Datum charlt(FunctionCallInfo fcinfo);
extern Datum unique_key_recheck(FunctionCallInfo fcinfo);
extern Datum int4abs(FunctionCallInfo fcinfo);
extern Datum nameregexne(FunctionCallInfo fcinfo);
extern Datum int2abs(FunctionCallInfo fcinfo);
extern Datum textregexeq(FunctionCallInfo fcinfo);
extern Datum textregexne(FunctionCallInfo fcinfo);
extern Datum textlen(FunctionCallInfo fcinfo);
extern Datum textcat(FunctionCallInfo fcinfo);
extern Datum PG_char_to_encoding(FunctionCallInfo fcinfo);
extern Datum tidne(FunctionCallInfo fcinfo);
extern Datum cidr_in(FunctionCallInfo fcinfo);
extern Datum parse_ident(FunctionCallInfo fcinfo);
extern Datum pg_column_size(FunctionCallInfo fcinfo);
extern Datum overlaps_timetz(FunctionCallInfo fcinfo);
extern Datum datetime_timestamp(FunctionCallInfo fcinfo);
extern Datum timetz_part(FunctionCallInfo fcinfo);
extern Datum int84pl(FunctionCallInfo fcinfo);
extern Datum int84mi(FunctionCallInfo fcinfo);
extern Datum int84mul(FunctionCallInfo fcinfo);
extern Datum int84div(FunctionCallInfo fcinfo);
extern Datum int48pl(FunctionCallInfo fcinfo);
extern Datum int48mi(FunctionCallInfo fcinfo);
extern Datum int48mul(FunctionCallInfo fcinfo);
extern Datum int48div(FunctionCallInfo fcinfo);
extern Datum quote_ident(FunctionCallInfo fcinfo);
extern Datum quote_literal(FunctionCallInfo fcinfo);
extern Datum timestamptz_trunc_zone(FunctionCallInfo fcinfo);
extern Datum array_fill_with_lower_bounds(FunctionCallInfo fcinfo);
extern Datum i8tooid(FunctionCallInfo fcinfo);
extern Datum oidtoi8(FunctionCallInfo fcinfo);
extern Datum quote_nullable(FunctionCallInfo fcinfo);
extern Datum suppress_redundant_updates_trigger(FunctionCallInfo fcinfo);
extern Datum tideq(FunctionCallInfo fcinfo);
extern Datum currtid_byreloid(FunctionCallInfo fcinfo);
extern Datum currtid_byrelname(FunctionCallInfo fcinfo);
extern Datum interval_justify_days(FunctionCallInfo fcinfo);
extern Datum datetimetz_timestamptz(FunctionCallInfo fcinfo);
extern Datum now(FunctionCallInfo fcinfo);
extern Datum positionsel(FunctionCallInfo fcinfo);
extern Datum positionjoinsel(FunctionCallInfo fcinfo);
extern Datum contsel(FunctionCallInfo fcinfo);
extern Datum contjoinsel(FunctionCallInfo fcinfo);
extern Datum overlaps_timestamp(FunctionCallInfo fcinfo);
extern Datum overlaps_time(FunctionCallInfo fcinfo);
extern Datum timestamp_in(FunctionCallInfo fcinfo);
extern Datum timestamp_out(FunctionCallInfo fcinfo);
extern Datum timestamp_cmp(FunctionCallInfo fcinfo);
extern Datum interval_cmp(FunctionCallInfo fcinfo);
extern Datum timestamp_time(FunctionCallInfo fcinfo);
extern Datum bpcharlen(FunctionCallInfo fcinfo);
extern Datum interval_div(FunctionCallInfo fcinfo);
extern Datum oidvectortypes(FunctionCallInfo fcinfo);
extern Datum timetz_in(FunctionCallInfo fcinfo);
extern Datum timetz_out(FunctionCallInfo fcinfo);
extern Datum timetz_eq(FunctionCallInfo fcinfo);
extern Datum timetz_ne(FunctionCallInfo fcinfo);
extern Datum timetz_lt(FunctionCallInfo fcinfo);
extern Datum timetz_le(FunctionCallInfo fcinfo);
extern Datum timetz_ge(FunctionCallInfo fcinfo);
extern Datum timetz_gt(FunctionCallInfo fcinfo);
extern Datum timetz_cmp(FunctionCallInfo fcinfo);
extern Datum network_hostmask(FunctionCallInfo fcinfo);
extern Datum textregexeq_support(FunctionCallInfo fcinfo);
extern Datum makeaclitem(FunctionCallInfo fcinfo);
extern Datum time_interval(FunctionCallInfo fcinfo);
extern Datum pg_lock_status(FunctionCallInfo fcinfo);
extern Datum date_finite(FunctionCallInfo fcinfo);
extern Datum textoctetlen(FunctionCallInfo fcinfo);
extern Datum bpcharoctetlen(FunctionCallInfo fcinfo);
extern Datum time_larger(FunctionCallInfo fcinfo);
extern Datum time_smaller(FunctionCallInfo fcinfo);
extern Datum timetz_larger(FunctionCallInfo fcinfo);
extern Datum timetz_smaller(FunctionCallInfo fcinfo);
extern Datum time_part(FunctionCallInfo fcinfo);
extern Datum pg_get_constraintdef(FunctionCallInfo fcinfo);
extern Datum timestamptz_timetz(FunctionCallInfo fcinfo);
extern Datum timestamp_finite(FunctionCallInfo fcinfo);
extern Datum interval_finite(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_start(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_client_addr(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_client_port(FunctionCallInfo fcinfo);
extern Datum current_schema(FunctionCallInfo fcinfo);
extern Datum current_schemas(FunctionCallInfo fcinfo);
extern Datum textoverlay(FunctionCallInfo fcinfo);
extern Datum textoverlay_no_len(FunctionCallInfo fcinfo);
extern Datum line_parallel(FunctionCallInfo fcinfo);
extern Datum line_perp(FunctionCallInfo fcinfo);
extern Datum line_vertical(FunctionCallInfo fcinfo);
extern Datum line_horizontal(FunctionCallInfo fcinfo);
extern Datum circle_center(FunctionCallInfo fcinfo);
extern Datum interval_time(FunctionCallInfo fcinfo);
extern Datum points_box(FunctionCallInfo fcinfo);
extern Datum box_add(FunctionCallInfo fcinfo);
extern Datum box_sub(FunctionCallInfo fcinfo);
extern Datum box_mul(FunctionCallInfo fcinfo);
extern Datum box_div(FunctionCallInfo fcinfo);
extern Datum cidr_out(FunctionCallInfo fcinfo);
extern Datum poly_contain_pt(FunctionCallInfo fcinfo);
extern Datum pt_contained_poly(FunctionCallInfo fcinfo);
extern Datum path_isclosed(FunctionCallInfo fcinfo);
extern Datum path_isopen(FunctionCallInfo fcinfo);
extern Datum path_npoints(FunctionCallInfo fcinfo);
extern Datum path_close(FunctionCallInfo fcinfo);
extern Datum path_open(FunctionCallInfo fcinfo);
extern Datum path_add(FunctionCallInfo fcinfo);
extern Datum path_add_pt(FunctionCallInfo fcinfo);
extern Datum path_sub_pt(FunctionCallInfo fcinfo);
extern Datum path_mul_pt(FunctionCallInfo fcinfo);
extern Datum path_div_pt(FunctionCallInfo fcinfo);
extern Datum construct_point(FunctionCallInfo fcinfo);
extern Datum point_add(FunctionCallInfo fcinfo);
extern Datum point_sub(FunctionCallInfo fcinfo);
extern Datum point_mul(FunctionCallInfo fcinfo);
extern Datum point_div(FunctionCallInfo fcinfo);
extern Datum poly_npoints(FunctionCallInfo fcinfo);
extern Datum poly_box(FunctionCallInfo fcinfo);
extern Datum poly_path(FunctionCallInfo fcinfo);
extern Datum box_poly(FunctionCallInfo fcinfo);
extern Datum path_poly(FunctionCallInfo fcinfo);
extern Datum circle_in(FunctionCallInfo fcinfo);
extern Datum circle_out(FunctionCallInfo fcinfo);
extern Datum circle_same(FunctionCallInfo fcinfo);
extern Datum circle_contain(FunctionCallInfo fcinfo);
extern Datum circle_left(FunctionCallInfo fcinfo);
extern Datum circle_overleft(FunctionCallInfo fcinfo);
extern Datum circle_overright(FunctionCallInfo fcinfo);
extern Datum circle_right(FunctionCallInfo fcinfo);
extern Datum circle_contained(FunctionCallInfo fcinfo);
extern Datum circle_overlap(FunctionCallInfo fcinfo);
extern Datum circle_below(FunctionCallInfo fcinfo);
extern Datum circle_above(FunctionCallInfo fcinfo);
extern Datum circle_eq(FunctionCallInfo fcinfo);
extern Datum circle_ne(FunctionCallInfo fcinfo);
extern Datum circle_lt(FunctionCallInfo fcinfo);
extern Datum circle_gt(FunctionCallInfo fcinfo);
extern Datum circle_le(FunctionCallInfo fcinfo);
extern Datum circle_ge(FunctionCallInfo fcinfo);
extern Datum circle_area(FunctionCallInfo fcinfo);
extern Datum circle_diameter(FunctionCallInfo fcinfo);
extern Datum circle_radius(FunctionCallInfo fcinfo);
extern Datum circle_distance(FunctionCallInfo fcinfo);
extern Datum cr_circle(FunctionCallInfo fcinfo);
extern Datum poly_circle(FunctionCallInfo fcinfo);
extern Datum circle_poly(FunctionCallInfo fcinfo);
extern Datum dist_pc(FunctionCallInfo fcinfo);
extern Datum circle_contain_pt(FunctionCallInfo fcinfo);
extern Datum pt_contained_circle(FunctionCallInfo fcinfo);
extern Datum box_circle(FunctionCallInfo fcinfo);
extern Datum circle_box(FunctionCallInfo fcinfo);
extern Datum lseg_ne(FunctionCallInfo fcinfo);
extern Datum lseg_lt(FunctionCallInfo fcinfo);
extern Datum lseg_le(FunctionCallInfo fcinfo);
extern Datum lseg_gt(FunctionCallInfo fcinfo);
extern Datum lseg_ge(FunctionCallInfo fcinfo);
extern Datum lseg_length(FunctionCallInfo fcinfo);
extern Datum close_ls(FunctionCallInfo fcinfo);
extern Datum close_lseg(FunctionCallInfo fcinfo);
extern Datum line_in(FunctionCallInfo fcinfo);
extern Datum line_out(FunctionCallInfo fcinfo);
extern Datum line_eq(FunctionCallInfo fcinfo);
extern Datum line_construct_pp(FunctionCallInfo fcinfo);
extern Datum line_interpt(FunctionCallInfo fcinfo);
extern Datum line_intersect(FunctionCallInfo fcinfo);
extern Datum bit_in(FunctionCallInfo fcinfo);
extern Datum bit_out(FunctionCallInfo fcinfo);
extern Datum pg_get_ruledef(FunctionCallInfo fcinfo);
extern Datum nextval_oid(FunctionCallInfo fcinfo);
extern Datum currval_oid(FunctionCallInfo fcinfo);
extern Datum setval_oid(FunctionCallInfo fcinfo);
extern Datum varbit_in(FunctionCallInfo fcinfo);
extern Datum varbit_out(FunctionCallInfo fcinfo);
extern Datum biteq(FunctionCallInfo fcinfo);
extern Datum bitne(FunctionCallInfo fcinfo);
extern Datum bitge(FunctionCallInfo fcinfo);
extern Datum bitgt(FunctionCallInfo fcinfo);
extern Datum bitle(FunctionCallInfo fcinfo);
extern Datum bitlt(FunctionCallInfo fcinfo);
extern Datum bitcmp(FunctionCallInfo fcinfo);
extern Datum PG_encoding_to_char(FunctionCallInfo fcinfo);
extern Datum drandom(FunctionCallInfo fcinfo);
extern Datum setseed(FunctionCallInfo fcinfo);
extern Datum dasin(FunctionCallInfo fcinfo);
extern Datum dacos(FunctionCallInfo fcinfo);
extern Datum datan(FunctionCallInfo fcinfo);
extern Datum datan2(FunctionCallInfo fcinfo);
extern Datum dsin(FunctionCallInfo fcinfo);
extern Datum dcos(FunctionCallInfo fcinfo);
extern Datum dtan(FunctionCallInfo fcinfo);
extern Datum dcot(FunctionCallInfo fcinfo);
extern Datum degrees(FunctionCallInfo fcinfo);
extern Datum radians(FunctionCallInfo fcinfo);
extern Datum dpi(FunctionCallInfo fcinfo);
extern Datum interval_mul(FunctionCallInfo fcinfo);
extern Datum pg_typeof(FunctionCallInfo fcinfo);
extern Datum ascii(FunctionCallInfo fcinfo);
extern Datum chr(FunctionCallInfo fcinfo);
extern Datum repeat(FunctionCallInfo fcinfo);
extern Datum similar_escape(FunctionCallInfo fcinfo);
extern Datum mul_d_interval(FunctionCallInfo fcinfo);
extern Datum texticlike(FunctionCallInfo fcinfo);
extern Datum texticnlike(FunctionCallInfo fcinfo);
extern Datum nameiclike(FunctionCallInfo fcinfo);
extern Datum nameicnlike(FunctionCallInfo fcinfo);
extern Datum like_escape(FunctionCallInfo fcinfo);
extern Datum oidgt(FunctionCallInfo fcinfo);
extern Datum oidge(FunctionCallInfo fcinfo);
extern Datum pg_get_viewdef_name(FunctionCallInfo fcinfo);
extern Datum pg_get_viewdef(FunctionCallInfo fcinfo);
extern Datum pg_get_userbyid(FunctionCallInfo fcinfo);
extern Datum pg_get_indexdef(FunctionCallInfo fcinfo);
extern Datum RI_FKey_check_ins(FunctionCallInfo fcinfo);
extern Datum RI_FKey_check_upd(FunctionCallInfo fcinfo);
extern Datum RI_FKey_cascade_del(FunctionCallInfo fcinfo);
extern Datum RI_FKey_cascade_upd(FunctionCallInfo fcinfo);
extern Datum RI_FKey_restrict_del(FunctionCallInfo fcinfo);
extern Datum RI_FKey_restrict_upd(FunctionCallInfo fcinfo);
extern Datum RI_FKey_setnull_del(FunctionCallInfo fcinfo);
extern Datum RI_FKey_setnull_upd(FunctionCallInfo fcinfo);
extern Datum RI_FKey_setdefault_del(FunctionCallInfo fcinfo);
extern Datum RI_FKey_setdefault_upd(FunctionCallInfo fcinfo);
extern Datum RI_FKey_noaction_del(FunctionCallInfo fcinfo);
extern Datum RI_FKey_noaction_upd(FunctionCallInfo fcinfo);
extern Datum pg_get_triggerdef(FunctionCallInfo fcinfo);
extern Datum pg_get_serial_sequence(FunctionCallInfo fcinfo);
extern Datum bit_and(FunctionCallInfo fcinfo);
extern Datum bit_or(FunctionCallInfo fcinfo);
extern Datum bitxor(FunctionCallInfo fcinfo);
extern Datum bitnot(FunctionCallInfo fcinfo);
extern Datum bitshiftleft(FunctionCallInfo fcinfo);
extern Datum bitshiftright(FunctionCallInfo fcinfo);
extern Datum bitcat(FunctionCallInfo fcinfo);
extern Datum bitsubstr(FunctionCallInfo fcinfo);
extern Datum bitlength(FunctionCallInfo fcinfo);
extern Datum bitoctetlength(FunctionCallInfo fcinfo);
extern Datum bitfromint4(FunctionCallInfo fcinfo);
extern Datum bittoint4(FunctionCallInfo fcinfo);
extern Datum bit(FunctionCallInfo fcinfo);
extern Datum pg_get_keywords(FunctionCallInfo fcinfo);
extern Datum varbit(FunctionCallInfo fcinfo);
extern Datum time_hash(FunctionCallInfo fcinfo);
extern Datum aclexplode(FunctionCallInfo fcinfo);
extern Datum time_mi_time(FunctionCallInfo fcinfo);
extern Datum boolle(FunctionCallInfo fcinfo);
extern Datum boolge(FunctionCallInfo fcinfo);
extern Datum btboolcmp(FunctionCallInfo fcinfo);
extern Datum timetz_hash(FunctionCallInfo fcinfo);
extern Datum interval_hash(FunctionCallInfo fcinfo);
extern Datum bitposition(FunctionCallInfo fcinfo);
extern Datum bitsubstr_no_len(FunctionCallInfo fcinfo);
extern Datum numeric_in(FunctionCallInfo fcinfo);
extern Datum numeric_out(FunctionCallInfo fcinfo);
extern Datum numeric(FunctionCallInfo fcinfo);
extern Datum numeric_abs(FunctionCallInfo fcinfo);
extern Datum numeric_sign(FunctionCallInfo fcinfo);
extern Datum numeric_round(FunctionCallInfo fcinfo);
extern Datum numeric_trunc(FunctionCallInfo fcinfo);
extern Datum numeric_ceil(FunctionCallInfo fcinfo);
extern Datum numeric_floor(FunctionCallInfo fcinfo);
extern Datum length_in_encoding(FunctionCallInfo fcinfo);
extern Datum pg_convert_from(FunctionCallInfo fcinfo);
extern Datum inet_to_cidr(FunctionCallInfo fcinfo);
extern Datum pg_get_expr(FunctionCallInfo fcinfo);
extern Datum pg_convert_to(FunctionCallInfo fcinfo);
extern Datum numeric_eq(FunctionCallInfo fcinfo);
extern Datum numeric_ne(FunctionCallInfo fcinfo);
extern Datum numeric_gt(FunctionCallInfo fcinfo);
extern Datum numeric_ge(FunctionCallInfo fcinfo);
extern Datum numeric_lt(FunctionCallInfo fcinfo);
extern Datum numeric_le(FunctionCallInfo fcinfo);
extern Datum numeric_add(FunctionCallInfo fcinfo);
extern Datum numeric_sub(FunctionCallInfo fcinfo);
extern Datum numeric_mul(FunctionCallInfo fcinfo);
extern Datum numeric_div(FunctionCallInfo fcinfo);
extern Datum numeric_mod(FunctionCallInfo fcinfo);
extern Datum numeric_sqrt(FunctionCallInfo fcinfo);
extern Datum numeric_exp(FunctionCallInfo fcinfo);
extern Datum numeric_ln(FunctionCallInfo fcinfo);
extern Datum numeric_log(FunctionCallInfo fcinfo);
extern Datum numeric_power(FunctionCallInfo fcinfo);
extern Datum int4_numeric(FunctionCallInfo fcinfo);
extern Datum float4_numeric(FunctionCallInfo fcinfo);
extern Datum float8_numeric(FunctionCallInfo fcinfo);
extern Datum numeric_int4(FunctionCallInfo fcinfo);
extern Datum numeric_float4(FunctionCallInfo fcinfo);
extern Datum numeric_float8(FunctionCallInfo fcinfo);
extern Datum time_pl_interval(FunctionCallInfo fcinfo);
extern Datum time_mi_interval(FunctionCallInfo fcinfo);
extern Datum timetz_pl_interval(FunctionCallInfo fcinfo);
extern Datum timetz_mi_interval(FunctionCallInfo fcinfo);
extern Datum numeric_inc(FunctionCallInfo fcinfo);
extern Datum setval3_oid(FunctionCallInfo fcinfo);
extern Datum numeric_smaller(FunctionCallInfo fcinfo);
extern Datum numeric_larger(FunctionCallInfo fcinfo);
extern Datum interval_to_char(FunctionCallInfo fcinfo);
extern Datum numeric_cmp(FunctionCallInfo fcinfo);
extern Datum timestamptz_to_char(FunctionCallInfo fcinfo);
extern Datum numeric_uminus(FunctionCallInfo fcinfo);
extern Datum numeric_to_char(FunctionCallInfo fcinfo);
extern Datum int4_to_char(FunctionCallInfo fcinfo);
extern Datum int8_to_char(FunctionCallInfo fcinfo);
extern Datum float4_to_char(FunctionCallInfo fcinfo);
extern Datum float8_to_char(FunctionCallInfo fcinfo);
extern Datum numeric_to_number(FunctionCallInfo fcinfo);
extern Datum to_timestamp(FunctionCallInfo fcinfo);
extern Datum numeric_int8(FunctionCallInfo fcinfo);
extern Datum to_date(FunctionCallInfo fcinfo);
extern Datum int8_numeric(FunctionCallInfo fcinfo);
extern Datum int2_numeric(FunctionCallInfo fcinfo);
extern Datum numeric_int2(FunctionCallInfo fcinfo);
extern Datum oidin(FunctionCallInfo fcinfo);
extern Datum oidout(FunctionCallInfo fcinfo);
extern Datum pg_convert(FunctionCallInfo fcinfo);
extern Datum iclikesel(FunctionCallInfo fcinfo);
extern Datum icnlikesel(FunctionCallInfo fcinfo);
extern Datum iclikejoinsel(FunctionCallInfo fcinfo);
extern Datum icnlikejoinsel(FunctionCallInfo fcinfo);
extern Datum regexeqsel(FunctionCallInfo fcinfo);
extern Datum likesel(FunctionCallInfo fcinfo);
extern Datum icregexeqsel(FunctionCallInfo fcinfo);
extern Datum regexnesel(FunctionCallInfo fcinfo);
extern Datum nlikesel(FunctionCallInfo fcinfo);
extern Datum icregexnesel(FunctionCallInfo fcinfo);
extern Datum regexeqjoinsel(FunctionCallInfo fcinfo);
extern Datum likejoinsel(FunctionCallInfo fcinfo);
extern Datum icregexeqjoinsel(FunctionCallInfo fcinfo);
extern Datum regexnejoinsel(FunctionCallInfo fcinfo);
extern Datum nlikejoinsel(FunctionCallInfo fcinfo);
extern Datum icregexnejoinsel(FunctionCallInfo fcinfo);
extern Datum float8_avg(FunctionCallInfo fcinfo);
extern Datum float8_var_samp(FunctionCallInfo fcinfo);
extern Datum float8_stddev_samp(FunctionCallInfo fcinfo);
extern Datum numeric_accum(FunctionCallInfo fcinfo);
extern Datum int2_accum(FunctionCallInfo fcinfo);
extern Datum int4_accum(FunctionCallInfo fcinfo);
extern Datum int8_accum(FunctionCallInfo fcinfo);
extern Datum numeric_avg(FunctionCallInfo fcinfo);
extern Datum numeric_var_samp(FunctionCallInfo fcinfo);
extern Datum numeric_stddev_samp(FunctionCallInfo fcinfo);
extern Datum int2_sum(FunctionCallInfo fcinfo);
extern Datum int4_sum(FunctionCallInfo fcinfo);
extern Datum int8_sum(FunctionCallInfo fcinfo);
extern Datum interval_accum(FunctionCallInfo fcinfo);
extern Datum interval_avg(FunctionCallInfo fcinfo);
extern Datum to_ascii_default(FunctionCallInfo fcinfo);
extern Datum to_ascii_enc(FunctionCallInfo fcinfo);
extern Datum to_ascii_encname(FunctionCallInfo fcinfo);
extern Datum int28eq(FunctionCallInfo fcinfo);
extern Datum int28ne(FunctionCallInfo fcinfo);
extern Datum int28lt(FunctionCallInfo fcinfo);
extern Datum int28gt(FunctionCallInfo fcinfo);
extern Datum int28le(FunctionCallInfo fcinfo);
extern Datum int28ge(FunctionCallInfo fcinfo);
extern Datum int82eq(FunctionCallInfo fcinfo);
extern Datum int82ne(FunctionCallInfo fcinfo);
extern Datum int82lt(FunctionCallInfo fcinfo);
extern Datum int82gt(FunctionCallInfo fcinfo);
extern Datum int82le(FunctionCallInfo fcinfo);
extern Datum int82ge(FunctionCallInfo fcinfo);
extern Datum int2and(FunctionCallInfo fcinfo);
extern Datum int2or(FunctionCallInfo fcinfo);
extern Datum int2xor(FunctionCallInfo fcinfo);
extern Datum int2not(FunctionCallInfo fcinfo);
extern Datum int2shl(FunctionCallInfo fcinfo);
extern Datum int2shr(FunctionCallInfo fcinfo);
extern Datum int4and(FunctionCallInfo fcinfo);
extern Datum int4or(FunctionCallInfo fcinfo);
extern Datum int4xor(FunctionCallInfo fcinfo);
extern Datum int4not(FunctionCallInfo fcinfo);
extern Datum int4shl(FunctionCallInfo fcinfo);
extern Datum int4shr(FunctionCallInfo fcinfo);
extern Datum int8and(FunctionCallInfo fcinfo);
extern Datum int8or(FunctionCallInfo fcinfo);
extern Datum int8xor(FunctionCallInfo fcinfo);
extern Datum int8not(FunctionCallInfo fcinfo);
extern Datum int8shl(FunctionCallInfo fcinfo);
extern Datum int8shr(FunctionCallInfo fcinfo);
extern Datum int8up(FunctionCallInfo fcinfo);
extern Datum int2up(FunctionCallInfo fcinfo);
extern Datum int4up(FunctionCallInfo fcinfo);
extern Datum float4up(FunctionCallInfo fcinfo);
extern Datum float8up(FunctionCallInfo fcinfo);
extern Datum numeric_uplus(FunctionCallInfo fcinfo);
extern Datum has_table_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_table_privilege_name_id(FunctionCallInfo fcinfo);
extern Datum has_table_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_table_privilege_id_id(FunctionCallInfo fcinfo);
extern Datum has_table_privilege_name(FunctionCallInfo fcinfo);
extern Datum has_table_privilege_id(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_numscans(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_tuples_returned(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_tuples_fetched(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_tuples_inserted(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_tuples_updated(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_tuples_deleted(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_blocks_fetched(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_blocks_hit(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_idset(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_pid(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_dbid(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_userid(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_activity(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_numbackends(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_xact_commit(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_xact_rollback(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_blocks_fetched(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_blocks_hit(FunctionCallInfo fcinfo);
extern Datum binary_encode(FunctionCallInfo fcinfo);
extern Datum binary_decode(FunctionCallInfo fcinfo);
extern Datum byteaeq(FunctionCallInfo fcinfo);
extern Datum bytealt(FunctionCallInfo fcinfo);
extern Datum byteale(FunctionCallInfo fcinfo);
extern Datum byteagt(FunctionCallInfo fcinfo);
extern Datum byteage(FunctionCallInfo fcinfo);
extern Datum byteane(FunctionCallInfo fcinfo);
extern Datum byteacmp(FunctionCallInfo fcinfo);
extern Datum timestamp_scale(FunctionCallInfo fcinfo);
extern Datum int2_avg_accum(FunctionCallInfo fcinfo);
extern Datum int4_avg_accum(FunctionCallInfo fcinfo);
extern Datum int8_avg(FunctionCallInfo fcinfo);
extern Datum oidlarger(FunctionCallInfo fcinfo);
extern Datum oidsmaller(FunctionCallInfo fcinfo);
extern Datum timestamptz_scale(FunctionCallInfo fcinfo);
extern Datum time_scale(FunctionCallInfo fcinfo);
extern Datum timetz_scale(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_tuples_hot_updated(FunctionCallInfo fcinfo);
extern Datum numeric_div_trunc(FunctionCallInfo fcinfo);
extern Datum bytealike(FunctionCallInfo fcinfo);
extern Datum byteanlike(FunctionCallInfo fcinfo);
extern Datum like_escape_bytea(FunctionCallInfo fcinfo);
extern Datum byteacat(FunctionCallInfo fcinfo);
extern Datum bytea_substr(FunctionCallInfo fcinfo);
extern Datum bytea_substr_no_len(FunctionCallInfo fcinfo);
extern Datum byteapos(FunctionCallInfo fcinfo);
extern Datum byteatrim(FunctionCallInfo fcinfo);
extern Datum timestamptz_time(FunctionCallInfo fcinfo);
extern Datum timestamp_trunc(FunctionCallInfo fcinfo);
extern Datum timestamp_part(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_activity(FunctionCallInfo fcinfo);
extern Datum date_timestamp(FunctionCallInfo fcinfo);
extern Datum pg_backend_pid(FunctionCallInfo fcinfo);
extern Datum timestamptz_timestamp(FunctionCallInfo fcinfo);
extern Datum timestamp_timestamptz(FunctionCallInfo fcinfo);
extern Datum timestamp_date(FunctionCallInfo fcinfo);
extern Datum timestamp_pl_interval(FunctionCallInfo fcinfo);
extern Datum timestamp_mi_interval(FunctionCallInfo fcinfo);
extern Datum pg_conf_load_time(FunctionCallInfo fcinfo);
extern Datum timetz_zone(FunctionCallInfo fcinfo);
extern Datum timetz_izone(FunctionCallInfo fcinfo);
extern Datum timestamp_hash(FunctionCallInfo fcinfo);
extern Datum timetz_time(FunctionCallInfo fcinfo);
extern Datum time_timetz(FunctionCallInfo fcinfo);
extern Datum timestamp_to_char(FunctionCallInfo fcinfo);
extern Datum aggregate_dummy(FunctionCallInfo fcinfo);
extern Datum timestamp_age(FunctionCallInfo fcinfo);
extern Datum timestamp_zone(FunctionCallInfo fcinfo);
extern Datum timestamp_izone(FunctionCallInfo fcinfo);
extern Datum date_pl_interval(FunctionCallInfo fcinfo);
extern Datum date_mi_interval(FunctionCallInfo fcinfo);
extern Datum textregexsubstr(FunctionCallInfo fcinfo);
extern Datum bitfromint8(FunctionCallInfo fcinfo);
extern Datum bittoint8(FunctionCallInfo fcinfo);
extern Datum show_config_by_name(FunctionCallInfo fcinfo);
extern Datum set_config_by_name(FunctionCallInfo fcinfo);
extern Datum pg_table_is_visible(FunctionCallInfo fcinfo);
extern Datum pg_type_is_visible(FunctionCallInfo fcinfo);
extern Datum pg_function_is_visible(FunctionCallInfo fcinfo);
extern Datum pg_operator_is_visible(FunctionCallInfo fcinfo);
extern Datum pg_opclass_is_visible(FunctionCallInfo fcinfo);
extern Datum show_all_settings(FunctionCallInfo fcinfo);
extern Datum replace_text(FunctionCallInfo fcinfo);
extern Datum split_text(FunctionCallInfo fcinfo);
extern Datum to_hex32(FunctionCallInfo fcinfo);
extern Datum to_hex64(FunctionCallInfo fcinfo);
extern Datum array_lower(FunctionCallInfo fcinfo);
extern Datum array_upper(FunctionCallInfo fcinfo);
extern Datum pg_conversion_is_visible(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_activity_start(FunctionCallInfo fcinfo);
extern Datum pg_terminate_backend(FunctionCallInfo fcinfo);
extern Datum pg_get_functiondef(FunctionCallInfo fcinfo);
extern Datum text_pattern_lt(FunctionCallInfo fcinfo);
extern Datum text_pattern_le(FunctionCallInfo fcinfo);
extern Datum pg_get_function_arguments(FunctionCallInfo fcinfo);
extern Datum text_pattern_ge(FunctionCallInfo fcinfo);
extern Datum text_pattern_gt(FunctionCallInfo fcinfo);
extern Datum pg_get_function_result(FunctionCallInfo fcinfo);
extern Datum bttext_pattern_cmp(FunctionCallInfo fcinfo);
extern Datum pg_database_size_name(FunctionCallInfo fcinfo);
extern Datum width_bucket_numeric(FunctionCallInfo fcinfo);
extern Datum pg_cancel_backend(FunctionCallInfo fcinfo);
extern Datum pg_start_backup(FunctionCallInfo fcinfo);
extern Datum pg_stop_backup(FunctionCallInfo fcinfo);
extern Datum bpchar_pattern_lt(FunctionCallInfo fcinfo);
extern Datum bpchar_pattern_le(FunctionCallInfo fcinfo);
extern Datum array_length(FunctionCallInfo fcinfo);
extern Datum bpchar_pattern_ge(FunctionCallInfo fcinfo);
extern Datum bpchar_pattern_gt(FunctionCallInfo fcinfo);
extern Datum gist_point_consistent(FunctionCallInfo fcinfo);
extern Datum btbpchar_pattern_cmp(FunctionCallInfo fcinfo);
extern Datum has_sequence_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_sequence_privilege_name_id(FunctionCallInfo fcinfo);
extern Datum has_sequence_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_sequence_privilege_id_id(FunctionCallInfo fcinfo);
extern Datum has_sequence_privilege_name(FunctionCallInfo fcinfo);
extern Datum has_sequence_privilege_id(FunctionCallInfo fcinfo);
extern Datum btint48cmp(FunctionCallInfo fcinfo);
extern Datum btint84cmp(FunctionCallInfo fcinfo);
extern Datum btint24cmp(FunctionCallInfo fcinfo);
extern Datum btint42cmp(FunctionCallInfo fcinfo);
extern Datum btint28cmp(FunctionCallInfo fcinfo);
extern Datum btint82cmp(FunctionCallInfo fcinfo);
extern Datum btfloat48cmp(FunctionCallInfo fcinfo);
extern Datum btfloat84cmp(FunctionCallInfo fcinfo);
extern Datum inet_client_addr(FunctionCallInfo fcinfo);
extern Datum inet_client_port(FunctionCallInfo fcinfo);
extern Datum inet_server_addr(FunctionCallInfo fcinfo);
extern Datum inet_server_port(FunctionCallInfo fcinfo);
extern Datum regprocedurein(FunctionCallInfo fcinfo);
extern Datum regprocedureout(FunctionCallInfo fcinfo);
extern Datum regoperin(FunctionCallInfo fcinfo);
extern Datum regoperout(FunctionCallInfo fcinfo);
extern Datum regoperatorin(FunctionCallInfo fcinfo);
extern Datum regoperatorout(FunctionCallInfo fcinfo);
extern Datum regclassin(FunctionCallInfo fcinfo);
extern Datum regclassout(FunctionCallInfo fcinfo);
extern Datum regtypein(FunctionCallInfo fcinfo);
extern Datum regtypeout(FunctionCallInfo fcinfo);
extern Datum pg_stat_clear_snapshot(FunctionCallInfo fcinfo);
extern Datum pg_get_function_identity_arguments(FunctionCallInfo fcinfo);
extern Datum hashtid(FunctionCallInfo fcinfo);
extern Datum hashtidextended(FunctionCallInfo fcinfo);
extern Datum fmgr_internal_validator(FunctionCallInfo fcinfo);
extern Datum fmgr_c_validator(FunctionCallInfo fcinfo);
extern Datum fmgr_sql_validator(FunctionCallInfo fcinfo);
extern Datum has_database_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_database_privilege_name_id(FunctionCallInfo fcinfo);
extern Datum has_database_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_database_privilege_id_id(FunctionCallInfo fcinfo);
extern Datum has_database_privilege_name(FunctionCallInfo fcinfo);
extern Datum has_database_privilege_id(FunctionCallInfo fcinfo);
extern Datum has_function_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_function_privilege_name_id(FunctionCallInfo fcinfo);
extern Datum has_function_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_function_privilege_id_id(FunctionCallInfo fcinfo);
extern Datum has_function_privilege_name(FunctionCallInfo fcinfo);
extern Datum has_function_privilege_id(FunctionCallInfo fcinfo);
extern Datum has_language_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_language_privilege_name_id(FunctionCallInfo fcinfo);
extern Datum has_language_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_language_privilege_id_id(FunctionCallInfo fcinfo);
extern Datum has_language_privilege_name(FunctionCallInfo fcinfo);
extern Datum has_language_privilege_id(FunctionCallInfo fcinfo);
extern Datum has_schema_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_schema_privilege_name_id(FunctionCallInfo fcinfo);
extern Datum has_schema_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_schema_privilege_id_id(FunctionCallInfo fcinfo);
extern Datum has_schema_privilege_name(FunctionCallInfo fcinfo);
extern Datum has_schema_privilege_id(FunctionCallInfo fcinfo);
extern Datum pg_stat_reset(FunctionCallInfo fcinfo);
extern Datum textregexreplace_noopt(FunctionCallInfo fcinfo);
extern Datum textregexreplace(FunctionCallInfo fcinfo);
extern Datum pg_total_relation_size(FunctionCallInfo fcinfo);
extern Datum pg_size_pretty(FunctionCallInfo fcinfo);
extern Datum pg_options_to_table(FunctionCallInfo fcinfo);
extern Datum record_in(FunctionCallInfo fcinfo);
extern Datum record_out(FunctionCallInfo fcinfo);
extern Datum cstring_in(FunctionCallInfo fcinfo);
extern Datum cstring_out(FunctionCallInfo fcinfo);
extern Datum any_in(FunctionCallInfo fcinfo);
extern Datum any_out(FunctionCallInfo fcinfo);
extern Datum anyarray_in(FunctionCallInfo fcinfo);
extern Datum anyarray_out(FunctionCallInfo fcinfo);
extern Datum void_in(FunctionCallInfo fcinfo);
extern Datum void_out(FunctionCallInfo fcinfo);
extern Datum trigger_in(FunctionCallInfo fcinfo);
extern Datum trigger_out(FunctionCallInfo fcinfo);
extern Datum language_handler_in(FunctionCallInfo fcinfo);
extern Datum language_handler_out(FunctionCallInfo fcinfo);
extern Datum internal_in(FunctionCallInfo fcinfo);
extern Datum internal_out(FunctionCallInfo fcinfo);
extern Datum opaque_in(FunctionCallInfo fcinfo);
extern Datum opaque_out(FunctionCallInfo fcinfo);
extern Datum dceil(FunctionCallInfo fcinfo);
extern Datum dfloor(FunctionCallInfo fcinfo);
extern Datum dsign(FunctionCallInfo fcinfo);
extern Datum md5_text(FunctionCallInfo fcinfo);
extern Datum anyelement_in(FunctionCallInfo fcinfo);
extern Datum anyelement_out(FunctionCallInfo fcinfo);
extern Datum postgresql_fdw_validator(FunctionCallInfo fcinfo);
extern Datum pg_encoding_max_length_sql(FunctionCallInfo fcinfo);
extern Datum md5_bytea(FunctionCallInfo fcinfo);
extern Datum pg_tablespace_size_oid(FunctionCallInfo fcinfo);
extern Datum pg_tablespace_size_name(FunctionCallInfo fcinfo);
extern Datum pg_database_size_oid(FunctionCallInfo fcinfo);
extern Datum array_unnest(FunctionCallInfo fcinfo);
extern Datum pg_relation_size(FunctionCallInfo fcinfo);
extern Datum array_agg_transfn(FunctionCallInfo fcinfo);
extern Datum array_agg_finalfn(FunctionCallInfo fcinfo);
extern Datum date_lt_timestamp(FunctionCallInfo fcinfo);
extern Datum date_le_timestamp(FunctionCallInfo fcinfo);
extern Datum date_eq_timestamp(FunctionCallInfo fcinfo);
extern Datum date_gt_timestamp(FunctionCallInfo fcinfo);
extern Datum date_ge_timestamp(FunctionCallInfo fcinfo);
extern Datum date_ne_timestamp(FunctionCallInfo fcinfo);
extern Datum date_cmp_timestamp(FunctionCallInfo fcinfo);
extern Datum date_lt_timestamptz(FunctionCallInfo fcinfo);
extern Datum date_le_timestamptz(FunctionCallInfo fcinfo);
extern Datum date_eq_timestamptz(FunctionCallInfo fcinfo);
extern Datum date_gt_timestamptz(FunctionCallInfo fcinfo);
extern Datum date_ge_timestamptz(FunctionCallInfo fcinfo);
extern Datum date_ne_timestamptz(FunctionCallInfo fcinfo);
extern Datum date_cmp_timestamptz(FunctionCallInfo fcinfo);
extern Datum timestamp_lt_date(FunctionCallInfo fcinfo);
extern Datum timestamp_le_date(FunctionCallInfo fcinfo);
extern Datum timestamp_eq_date(FunctionCallInfo fcinfo);
extern Datum timestamp_gt_date(FunctionCallInfo fcinfo);
extern Datum timestamp_ge_date(FunctionCallInfo fcinfo);
extern Datum timestamp_ne_date(FunctionCallInfo fcinfo);
extern Datum timestamp_cmp_date(FunctionCallInfo fcinfo);
extern Datum timestamptz_lt_date(FunctionCallInfo fcinfo);
extern Datum timestamptz_le_date(FunctionCallInfo fcinfo);
extern Datum timestamptz_eq_date(FunctionCallInfo fcinfo);
extern Datum timestamptz_gt_date(FunctionCallInfo fcinfo);
extern Datum timestamptz_ge_date(FunctionCallInfo fcinfo);
extern Datum timestamptz_ne_date(FunctionCallInfo fcinfo);
extern Datum timestamptz_cmp_date(FunctionCallInfo fcinfo);
extern Datum has_tablespace_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_tablespace_privilege_name_id(FunctionCallInfo fcinfo);
extern Datum has_tablespace_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_tablespace_privilege_id_id(FunctionCallInfo fcinfo);
extern Datum has_tablespace_privilege_name(FunctionCallInfo fcinfo);
extern Datum has_tablespace_privilege_id(FunctionCallInfo fcinfo);
extern Datum shell_in(FunctionCallInfo fcinfo);
extern Datum shell_out(FunctionCallInfo fcinfo);
extern Datum array_recv(FunctionCallInfo fcinfo);
extern Datum array_send(FunctionCallInfo fcinfo);
extern Datum record_recv(FunctionCallInfo fcinfo);
extern Datum record_send(FunctionCallInfo fcinfo);
extern Datum int2recv(FunctionCallInfo fcinfo);
extern Datum int2send(FunctionCallInfo fcinfo);
extern Datum int4recv(FunctionCallInfo fcinfo);
extern Datum int4send(FunctionCallInfo fcinfo);
extern Datum int8recv(FunctionCallInfo fcinfo);
extern Datum int8send(FunctionCallInfo fcinfo);
extern Datum int2vectorrecv(FunctionCallInfo fcinfo);
extern Datum int2vectorsend(FunctionCallInfo fcinfo);
extern Datum bytearecv(FunctionCallInfo fcinfo);
extern Datum byteasend(FunctionCallInfo fcinfo);
extern Datum textrecv(FunctionCallInfo fcinfo);
extern Datum textsend(FunctionCallInfo fcinfo);
extern Datum unknownrecv(FunctionCallInfo fcinfo);
extern Datum unknownsend(FunctionCallInfo fcinfo);
extern Datum oidrecv(FunctionCallInfo fcinfo);
extern Datum oidsend(FunctionCallInfo fcinfo);
extern Datum oidvectorrecv(FunctionCallInfo fcinfo);
extern Datum oidvectorsend(FunctionCallInfo fcinfo);
extern Datum namerecv(FunctionCallInfo fcinfo);
extern Datum namesend(FunctionCallInfo fcinfo);
extern Datum float4recv(FunctionCallInfo fcinfo);
extern Datum float4send(FunctionCallInfo fcinfo);
extern Datum float8recv(FunctionCallInfo fcinfo);
extern Datum float8send(FunctionCallInfo fcinfo);
extern Datum point_recv(FunctionCallInfo fcinfo);
extern Datum point_send(FunctionCallInfo fcinfo);
extern Datum bpcharrecv(FunctionCallInfo fcinfo);
extern Datum bpcharsend(FunctionCallInfo fcinfo);
extern Datum varcharrecv(FunctionCallInfo fcinfo);
extern Datum varcharsend(FunctionCallInfo fcinfo);
extern Datum charrecv(FunctionCallInfo fcinfo);
extern Datum charsend(FunctionCallInfo fcinfo);
extern Datum boolrecv(FunctionCallInfo fcinfo);
extern Datum boolsend(FunctionCallInfo fcinfo);
extern Datum tidrecv(FunctionCallInfo fcinfo);
extern Datum tidsend(FunctionCallInfo fcinfo);
extern Datum xidrecv(FunctionCallInfo fcinfo);
extern Datum xidsend(FunctionCallInfo fcinfo);
extern Datum cidrecv(FunctionCallInfo fcinfo);
extern Datum cidsend(FunctionCallInfo fcinfo);
extern Datum regprocrecv(FunctionCallInfo fcinfo);
extern Datum regprocsend(FunctionCallInfo fcinfo);
extern Datum regprocedurerecv(FunctionCallInfo fcinfo);
extern Datum regproceduresend(FunctionCallInfo fcinfo);
extern Datum regoperrecv(FunctionCallInfo fcinfo);
extern Datum regopersend(FunctionCallInfo fcinfo);
extern Datum regoperatorrecv(FunctionCallInfo fcinfo);
extern Datum regoperatorsend(FunctionCallInfo fcinfo);
extern Datum regclassrecv(FunctionCallInfo fcinfo);
extern Datum regclasssend(FunctionCallInfo fcinfo);
extern Datum regtyperecv(FunctionCallInfo fcinfo);
extern Datum regtypesend(FunctionCallInfo fcinfo);
extern Datum bit_recv(FunctionCallInfo fcinfo);
extern Datum bit_send(FunctionCallInfo fcinfo);
extern Datum varbit_recv(FunctionCallInfo fcinfo);
extern Datum varbit_send(FunctionCallInfo fcinfo);
extern Datum numeric_recv(FunctionCallInfo fcinfo);
extern Datum numeric_send(FunctionCallInfo fcinfo);
extern Datum dsinh(FunctionCallInfo fcinfo);
extern Datum dcosh(FunctionCallInfo fcinfo);
extern Datum dtanh(FunctionCallInfo fcinfo);
extern Datum dasinh(FunctionCallInfo fcinfo);
extern Datum dacosh(FunctionCallInfo fcinfo);
extern Datum datanh(FunctionCallInfo fcinfo);
extern Datum date_recv(FunctionCallInfo fcinfo);
extern Datum date_send(FunctionCallInfo fcinfo);
extern Datum time_recv(FunctionCallInfo fcinfo);
extern Datum time_send(FunctionCallInfo fcinfo);
extern Datum timetz_recv(FunctionCallInfo fcinfo);
extern Datum timetz_send(FunctionCallInfo fcinfo);
extern Datum timestamp_recv(FunctionCallInfo fcinfo);
extern Datum timestamp_send(FunctionCallInfo fcinfo);
extern Datum timestamptz_recv(FunctionCallInfo fcinfo);
extern Datum timestamptz_send(FunctionCallInfo fcinfo);
extern Datum interval_recv(FunctionCallInfo fcinfo);
extern Datum interval_send(FunctionCallInfo fcinfo);
extern Datum lseg_recv(FunctionCallInfo fcinfo);
extern Datum lseg_send(FunctionCallInfo fcinfo);
extern Datum path_recv(FunctionCallInfo fcinfo);
extern Datum path_send(FunctionCallInfo fcinfo);
extern Datum box_recv(FunctionCallInfo fcinfo);
extern Datum box_send(FunctionCallInfo fcinfo);
extern Datum poly_recv(FunctionCallInfo fcinfo);
extern Datum poly_send(FunctionCallInfo fcinfo);
extern Datum line_recv(FunctionCallInfo fcinfo);
extern Datum line_send(FunctionCallInfo fcinfo);
extern Datum circle_recv(FunctionCallInfo fcinfo);
extern Datum circle_send(FunctionCallInfo fcinfo);
extern Datum cash_recv(FunctionCallInfo fcinfo);
extern Datum cash_send(FunctionCallInfo fcinfo);
extern Datum macaddr_recv(FunctionCallInfo fcinfo);
extern Datum macaddr_send(FunctionCallInfo fcinfo);
extern Datum inet_recv(FunctionCallInfo fcinfo);
extern Datum inet_send(FunctionCallInfo fcinfo);
extern Datum cidr_recv(FunctionCallInfo fcinfo);
extern Datum cidr_send(FunctionCallInfo fcinfo);
extern Datum cstring_recv(FunctionCallInfo fcinfo);
extern Datum cstring_send(FunctionCallInfo fcinfo);
extern Datum anyarray_recv(FunctionCallInfo fcinfo);
extern Datum anyarray_send(FunctionCallInfo fcinfo);
extern Datum pg_get_ruledef_ext(FunctionCallInfo fcinfo);
extern Datum pg_get_viewdef_name_ext(FunctionCallInfo fcinfo);
extern Datum pg_get_viewdef_ext(FunctionCallInfo fcinfo);
extern Datum pg_get_indexdef_ext(FunctionCallInfo fcinfo);
extern Datum pg_get_constraintdef_ext(FunctionCallInfo fcinfo);
extern Datum pg_get_expr_ext(FunctionCallInfo fcinfo);
extern Datum pg_prepared_statement(FunctionCallInfo fcinfo);
extern Datum pg_cursor(FunctionCallInfo fcinfo);
extern Datum float8_var_pop(FunctionCallInfo fcinfo);
extern Datum float8_stddev_pop(FunctionCallInfo fcinfo);
extern Datum numeric_var_pop(FunctionCallInfo fcinfo);
extern Datum booland_statefunc(FunctionCallInfo fcinfo);
extern Datum boolor_statefunc(FunctionCallInfo fcinfo);
extern Datum timestamp_lt_timestamptz(FunctionCallInfo fcinfo);
extern Datum timestamp_le_timestamptz(FunctionCallInfo fcinfo);
extern Datum timestamp_eq_timestamptz(FunctionCallInfo fcinfo);
extern Datum timestamp_gt_timestamptz(FunctionCallInfo fcinfo);
extern Datum timestamp_ge_timestamptz(FunctionCallInfo fcinfo);
extern Datum timestamp_ne_timestamptz(FunctionCallInfo fcinfo);
extern Datum timestamp_cmp_timestamptz(FunctionCallInfo fcinfo);
extern Datum timestamptz_lt_timestamp(FunctionCallInfo fcinfo);
extern Datum timestamptz_le_timestamp(FunctionCallInfo fcinfo);
extern Datum timestamptz_eq_timestamp(FunctionCallInfo fcinfo);
extern Datum timestamptz_gt_timestamp(FunctionCallInfo fcinfo);
extern Datum timestamptz_ge_timestamp(FunctionCallInfo fcinfo);
extern Datum timestamptz_ne_timestamp(FunctionCallInfo fcinfo);
extern Datum timestamptz_cmp_timestamp(FunctionCallInfo fcinfo);
extern Datum pg_tablespace_databases(FunctionCallInfo fcinfo);
extern Datum int4_bool(FunctionCallInfo fcinfo);
extern Datum bool_int4(FunctionCallInfo fcinfo);
extern Datum lastval(FunctionCallInfo fcinfo);
extern Datum pg_postmaster_start_time(FunctionCallInfo fcinfo);
extern Datum pg_blocking_pids(FunctionCallInfo fcinfo);
extern Datum box_below(FunctionCallInfo fcinfo);
extern Datum box_overbelow(FunctionCallInfo fcinfo);
extern Datum box_overabove(FunctionCallInfo fcinfo);
extern Datum box_above(FunctionCallInfo fcinfo);
extern Datum poly_below(FunctionCallInfo fcinfo);
extern Datum poly_overbelow(FunctionCallInfo fcinfo);
extern Datum poly_overabove(FunctionCallInfo fcinfo);
extern Datum poly_above(FunctionCallInfo fcinfo);
extern Datum gist_box_consistent(FunctionCallInfo fcinfo);
extern Datum jsonb_float8(FunctionCallInfo fcinfo);
extern Datum gist_box_penalty(FunctionCallInfo fcinfo);
extern Datum gist_box_picksplit(FunctionCallInfo fcinfo);
extern Datum gist_box_union(FunctionCallInfo fcinfo);
extern Datum gist_box_same(FunctionCallInfo fcinfo);
extern Datum gist_poly_consistent(FunctionCallInfo fcinfo);
extern Datum gist_poly_compress(FunctionCallInfo fcinfo);
extern Datum circle_overbelow(FunctionCallInfo fcinfo);
extern Datum circle_overabove(FunctionCallInfo fcinfo);
extern Datum gist_circle_consistent(FunctionCallInfo fcinfo);
extern Datum gist_circle_compress(FunctionCallInfo fcinfo);
extern Datum numeric_stddev_pop(FunctionCallInfo fcinfo);
extern Datum domain_in(FunctionCallInfo fcinfo);
extern Datum domain_recv(FunctionCallInfo fcinfo);
extern Datum pg_timezone_abbrevs(FunctionCallInfo fcinfo);
extern Datum xmlexists(FunctionCallInfo fcinfo);
extern Datum pg_reload_conf(FunctionCallInfo fcinfo);
extern Datum pg_rotate_logfile_v2(FunctionCallInfo fcinfo);
extern Datum pg_stat_file_1arg(FunctionCallInfo fcinfo);
extern Datum pg_read_file_off_len(FunctionCallInfo fcinfo);
extern Datum pg_ls_dir_1arg(FunctionCallInfo fcinfo);
extern Datum pg_sleep(FunctionCallInfo fcinfo);
extern Datum inetnot(FunctionCallInfo fcinfo);
extern Datum inetand(FunctionCallInfo fcinfo);
extern Datum inetor(FunctionCallInfo fcinfo);
extern Datum inetpl(FunctionCallInfo fcinfo);
extern Datum inetmi_int8(FunctionCallInfo fcinfo);
extern Datum inetmi(FunctionCallInfo fcinfo);
extern Datum statement_timestamp(FunctionCallInfo fcinfo);
extern Datum clock_timestamp(FunctionCallInfo fcinfo);
extern Datum gin_cmp_prefix(FunctionCallInfo fcinfo);
extern Datum pg_has_role_name_name(FunctionCallInfo fcinfo);
extern Datum pg_has_role_name_id(FunctionCallInfo fcinfo);
extern Datum pg_has_role_id_name(FunctionCallInfo fcinfo);
extern Datum pg_has_role_id_id(FunctionCallInfo fcinfo);
extern Datum pg_has_role_name(FunctionCallInfo fcinfo);
extern Datum pg_has_role_id(FunctionCallInfo fcinfo);
extern Datum interval_justify_interval(FunctionCallInfo fcinfo);
extern Datum pg_get_triggerdef_ext(FunctionCallInfo fcinfo);
extern Datum dasind(FunctionCallInfo fcinfo);
extern Datum dacosd(FunctionCallInfo fcinfo);
extern Datum datand(FunctionCallInfo fcinfo);
extern Datum datan2d(FunctionCallInfo fcinfo);
extern Datum dsind(FunctionCallInfo fcinfo);
extern Datum dcosd(FunctionCallInfo fcinfo);
extern Datum dtand(FunctionCallInfo fcinfo);
extern Datum dcotd(FunctionCallInfo fcinfo);
extern Datum pg_stop_backup_v2(FunctionCallInfo fcinfo);
extern Datum numeric_avg_serialize(FunctionCallInfo fcinfo);
extern Datum numeric_avg_deserialize(FunctionCallInfo fcinfo);
extern Datum ginarrayextract(FunctionCallInfo fcinfo);
extern Datum ginarrayconsistent(FunctionCallInfo fcinfo);
extern Datum int8_avg_accum(FunctionCallInfo fcinfo);
extern Datum arrayoverlap(FunctionCallInfo fcinfo);
extern Datum arraycontains(FunctionCallInfo fcinfo);
extern Datum arraycontained(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_tuples_returned(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_tuples_fetched(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_tuples_inserted(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_tuples_updated(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_tuples_deleted(FunctionCallInfo fcinfo);
extern Datum regexp_matches_no_flags(FunctionCallInfo fcinfo);
extern Datum regexp_matches(FunctionCallInfo fcinfo);
extern Datum regexp_split_to_table_no_flags(FunctionCallInfo fcinfo);
extern Datum regexp_split_to_table(FunctionCallInfo fcinfo);
extern Datum regexp_split_to_array_no_flags(FunctionCallInfo fcinfo);
extern Datum regexp_split_to_array(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_bgwriter_timed_checkpoints(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_bgwriter_requested_checkpoints(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_bgwriter_buf_written_checkpoints(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_bgwriter_buf_written_clean(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_bgwriter_maxwritten_clean(FunctionCallInfo fcinfo);
extern Datum ginqueryarrayextract(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_buf_written_backend(FunctionCallInfo fcinfo);
extern Datum anynonarray_in(FunctionCallInfo fcinfo);
extern Datum anynonarray_out(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_last_vacuum_time(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_last_autovacuum_time(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_last_analyze_time(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_last_autoanalyze_time(FunctionCallInfo fcinfo);
extern Datum int8_avg_combine(FunctionCallInfo fcinfo);
extern Datum int8_avg_serialize(FunctionCallInfo fcinfo);
extern Datum int8_avg_deserialize(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_wait_event_type(FunctionCallInfo fcinfo);
extern Datum tidgt(FunctionCallInfo fcinfo);
extern Datum tidlt(FunctionCallInfo fcinfo);
extern Datum tidge(FunctionCallInfo fcinfo);
extern Datum tidle(FunctionCallInfo fcinfo);
extern Datum bttidcmp(FunctionCallInfo fcinfo);
extern Datum tidlarger(FunctionCallInfo fcinfo);
extern Datum tidsmaller(FunctionCallInfo fcinfo);
extern Datum int8inc_any(FunctionCallInfo fcinfo);
extern Datum int8inc_float8_float8(FunctionCallInfo fcinfo);
extern Datum float8_regr_accum(FunctionCallInfo fcinfo);
extern Datum float8_regr_sxx(FunctionCallInfo fcinfo);
extern Datum float8_regr_syy(FunctionCallInfo fcinfo);
extern Datum float8_regr_sxy(FunctionCallInfo fcinfo);
extern Datum float8_regr_avgx(FunctionCallInfo fcinfo);
extern Datum float8_regr_avgy(FunctionCallInfo fcinfo);
extern Datum float8_regr_r2(FunctionCallInfo fcinfo);
extern Datum float8_regr_slope(FunctionCallInfo fcinfo);
extern Datum float8_regr_intercept(FunctionCallInfo fcinfo);
extern Datum float8_covar_pop(FunctionCallInfo fcinfo);
extern Datum float8_covar_samp(FunctionCallInfo fcinfo);
extern Datum float8_corr(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_blk_read_time(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_blk_write_time(FunctionCallInfo fcinfo);
extern Datum pg_switch_wal(FunctionCallInfo fcinfo);
extern Datum pg_current_wal_lsn(FunctionCallInfo fcinfo);
extern Datum pg_walfile_name_offset(FunctionCallInfo fcinfo);
extern Datum pg_walfile_name(FunctionCallInfo fcinfo);
extern Datum pg_current_wal_insert_lsn(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_wait_event(FunctionCallInfo fcinfo);
extern Datum pg_my_temp_schema(FunctionCallInfo fcinfo);
extern Datum pg_is_other_temp_schema(FunctionCallInfo fcinfo);
extern Datum pg_timezone_names(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_backend_xact_start(FunctionCallInfo fcinfo);
extern Datum numeric_avg_accum(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_buf_alloc(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_live_tuples(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_dead_tuples(FunctionCallInfo fcinfo);
extern Datum pg_advisory_lock_int8(FunctionCallInfo fcinfo);
extern Datum pg_advisory_lock_shared_int8(FunctionCallInfo fcinfo);
extern Datum pg_try_advisory_lock_int8(FunctionCallInfo fcinfo);
extern Datum pg_try_advisory_lock_shared_int8(FunctionCallInfo fcinfo);
extern Datum pg_advisory_unlock_int8(FunctionCallInfo fcinfo);
extern Datum pg_advisory_unlock_shared_int8(FunctionCallInfo fcinfo);
extern Datum pg_advisory_lock_int4(FunctionCallInfo fcinfo);
extern Datum pg_advisory_lock_shared_int4(FunctionCallInfo fcinfo);
extern Datum pg_try_advisory_lock_int4(FunctionCallInfo fcinfo);
extern Datum pg_try_advisory_lock_shared_int4(FunctionCallInfo fcinfo);
extern Datum pg_advisory_unlock_int4(FunctionCallInfo fcinfo);
extern Datum pg_advisory_unlock_shared_int4(FunctionCallInfo fcinfo);
extern Datum pg_advisory_unlock_all(FunctionCallInfo fcinfo);
extern Datum xml_in(FunctionCallInfo fcinfo);
extern Datum xml_out(FunctionCallInfo fcinfo);
extern Datum xmlcomment(FunctionCallInfo fcinfo);
extern Datum texttoxml(FunctionCallInfo fcinfo);
extern Datum xmlvalidate(FunctionCallInfo fcinfo);
extern Datum xml_recv(FunctionCallInfo fcinfo);
extern Datum xml_send(FunctionCallInfo fcinfo);
extern Datum xmlconcat2(FunctionCallInfo fcinfo);
extern Datum varbittypmodin(FunctionCallInfo fcinfo);
extern Datum intervaltypmodin(FunctionCallInfo fcinfo);
extern Datum intervaltypmodout(FunctionCallInfo fcinfo);
extern Datum timestamptypmodin(FunctionCallInfo fcinfo);
extern Datum timestamptypmodout(FunctionCallInfo fcinfo);
extern Datum timestamptztypmodin(FunctionCallInfo fcinfo);
extern Datum timestamptztypmodout(FunctionCallInfo fcinfo);
extern Datum timetypmodin(FunctionCallInfo fcinfo);
extern Datum timetypmodout(FunctionCallInfo fcinfo);
extern Datum timetztypmodin(FunctionCallInfo fcinfo);
extern Datum timetztypmodout(FunctionCallInfo fcinfo);
extern Datum bpchartypmodin(FunctionCallInfo fcinfo);
extern Datum bpchartypmodout(FunctionCallInfo fcinfo);
extern Datum varchartypmodin(FunctionCallInfo fcinfo);
extern Datum varchartypmodout(FunctionCallInfo fcinfo);
extern Datum numerictypmodin(FunctionCallInfo fcinfo);
extern Datum numerictypmodout(FunctionCallInfo fcinfo);
extern Datum bittypmodin(FunctionCallInfo fcinfo);
extern Datum bittypmodout(FunctionCallInfo fcinfo);
extern Datum varbittypmodout(FunctionCallInfo fcinfo);
extern Datum xmltotext(FunctionCallInfo fcinfo);
extern Datum table_to_xml(FunctionCallInfo fcinfo);
extern Datum query_to_xml(FunctionCallInfo fcinfo);
extern Datum cursor_to_xml(FunctionCallInfo fcinfo);
extern Datum table_to_xmlschema(FunctionCallInfo fcinfo);
extern Datum query_to_xmlschema(FunctionCallInfo fcinfo);
extern Datum cursor_to_xmlschema(FunctionCallInfo fcinfo);
extern Datum table_to_xml_and_xmlschema(FunctionCallInfo fcinfo);
extern Datum query_to_xml_and_xmlschema(FunctionCallInfo fcinfo);
extern Datum xpath(FunctionCallInfo fcinfo);
extern Datum schema_to_xml(FunctionCallInfo fcinfo);
extern Datum schema_to_xmlschema(FunctionCallInfo fcinfo);
extern Datum schema_to_xml_and_xmlschema(FunctionCallInfo fcinfo);
extern Datum database_to_xml(FunctionCallInfo fcinfo);
extern Datum database_to_xmlschema(FunctionCallInfo fcinfo);
extern Datum database_to_xml_and_xmlschema(FunctionCallInfo fcinfo);
extern Datum txid_snapshot_in(FunctionCallInfo fcinfo);
extern Datum txid_snapshot_out(FunctionCallInfo fcinfo);
extern Datum txid_snapshot_recv(FunctionCallInfo fcinfo);
extern Datum txid_snapshot_send(FunctionCallInfo fcinfo);
extern Datum txid_current(FunctionCallInfo fcinfo);
extern Datum txid_current_snapshot(FunctionCallInfo fcinfo);
extern Datum txid_snapshot_xmin(FunctionCallInfo fcinfo);
extern Datum txid_snapshot_xmax(FunctionCallInfo fcinfo);
extern Datum txid_snapshot_xip(FunctionCallInfo fcinfo);
extern Datum txid_visible_in_snapshot(FunctionCallInfo fcinfo);
extern Datum uuid_in(FunctionCallInfo fcinfo);
extern Datum uuid_out(FunctionCallInfo fcinfo);
extern Datum uuid_lt(FunctionCallInfo fcinfo);
extern Datum uuid_le(FunctionCallInfo fcinfo);
extern Datum uuid_eq(FunctionCallInfo fcinfo);
extern Datum uuid_ge(FunctionCallInfo fcinfo);
extern Datum uuid_gt(FunctionCallInfo fcinfo);
extern Datum uuid_ne(FunctionCallInfo fcinfo);
extern Datum uuid_cmp(FunctionCallInfo fcinfo);
extern Datum uuid_recv(FunctionCallInfo fcinfo);
extern Datum uuid_send(FunctionCallInfo fcinfo);
extern Datum uuid_hash(FunctionCallInfo fcinfo);
extern Datum booltext(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_function_calls(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_function_total_time(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_function_self_time(FunctionCallInfo fcinfo);
extern Datum record_eq(FunctionCallInfo fcinfo);
extern Datum record_ne(FunctionCallInfo fcinfo);
extern Datum record_lt(FunctionCallInfo fcinfo);
extern Datum record_gt(FunctionCallInfo fcinfo);
extern Datum record_le(FunctionCallInfo fcinfo);
extern Datum record_ge(FunctionCallInfo fcinfo);
extern Datum btrecordcmp(FunctionCallInfo fcinfo);
extern Datum pg_table_size(FunctionCallInfo fcinfo);
extern Datum pg_indexes_size(FunctionCallInfo fcinfo);
extern Datum pg_relation_filenode(FunctionCallInfo fcinfo);
extern Datum has_foreign_data_wrapper_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_foreign_data_wrapper_privilege_name_id(FunctionCallInfo fcinfo);
extern Datum has_foreign_data_wrapper_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_foreign_data_wrapper_privilege_id_id(FunctionCallInfo fcinfo);
extern Datum has_foreign_data_wrapper_privilege_name(FunctionCallInfo fcinfo);
extern Datum has_foreign_data_wrapper_privilege_id(FunctionCallInfo fcinfo);
extern Datum has_server_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_server_privilege_name_id(FunctionCallInfo fcinfo);
extern Datum has_server_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_server_privilege_id_id(FunctionCallInfo fcinfo);
extern Datum has_server_privilege_name(FunctionCallInfo fcinfo);
extern Datum has_server_privilege_id(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_name_name_name(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_name_name_attnum(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_name_id_name(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_name_id_attnum(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_id_name_name(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_id_name_attnum(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_id_id_name(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_id_id_attnum(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_name_attnum(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_column_privilege_id_attnum(FunctionCallInfo fcinfo);
extern Datum has_any_column_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_any_column_privilege_name_id(FunctionCallInfo fcinfo);
extern Datum has_any_column_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_any_column_privilege_id_id(FunctionCallInfo fcinfo);
extern Datum has_any_column_privilege_name(FunctionCallInfo fcinfo);
extern Datum has_any_column_privilege_id(FunctionCallInfo fcinfo);
extern Datum bitoverlay(FunctionCallInfo fcinfo);
extern Datum bitoverlay_no_len(FunctionCallInfo fcinfo);
extern Datum bitgetbit(FunctionCallInfo fcinfo);
extern Datum bitsetbit(FunctionCallInfo fcinfo);
extern Datum pg_relation_filepath(FunctionCallInfo fcinfo);
extern Datum pg_listening_channels(FunctionCallInfo fcinfo);
extern Datum pg_notify(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_numscans(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_tuples_returned(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_tuples_fetched(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_tuples_inserted(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_tuples_updated(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_tuples_deleted(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_tuples_hot_updated(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_blocks_fetched(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_blocks_hit(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_function_calls(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_function_total_time(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_xact_function_self_time(FunctionCallInfo fcinfo);
extern Datum xpath_exists(FunctionCallInfo fcinfo);
extern Datum xml_is_well_formed(FunctionCallInfo fcinfo);
extern Datum xml_is_well_formed_document(FunctionCallInfo fcinfo);
extern Datum xml_is_well_formed_content(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_vacuum_count(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_autovacuum_count(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_analyze_count(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_autoanalyze_count(FunctionCallInfo fcinfo);
extern Datum text_concat(FunctionCallInfo fcinfo);
extern Datum text_concat_ws(FunctionCallInfo fcinfo);
extern Datum text_left(FunctionCallInfo fcinfo);
extern Datum text_right(FunctionCallInfo fcinfo);
extern Datum text_reverse(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_buf_fsync_backend(FunctionCallInfo fcinfo);
extern Datum gist_point_distance(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_conflict_tablespace(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_conflict_lock(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_conflict_snapshot(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_conflict_bufferpin(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_conflict_startup_deadlock(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_conflict_all(FunctionCallInfo fcinfo);
extern Datum pg_wal_replay_pause(FunctionCallInfo fcinfo);
extern Datum pg_wal_replay_resume(FunctionCallInfo fcinfo);
extern Datum pg_is_wal_replay_paused(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_stat_reset_time(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_bgwriter_stat_reset_time(FunctionCallInfo fcinfo);
extern Datum ginarrayextract_2args(FunctionCallInfo fcinfo);
extern Datum gin_extract_tsvector_2args(FunctionCallInfo fcinfo);
extern Datum pg_sequence_parameters(FunctionCallInfo fcinfo);
extern Datum pg_available_extensions(FunctionCallInfo fcinfo);
extern Datum pg_available_extension_versions(FunctionCallInfo fcinfo);
extern Datum pg_extension_update_paths(FunctionCallInfo fcinfo);
extern Datum pg_extension_config_dump(FunctionCallInfo fcinfo);
extern Datum gin_extract_tsquery_5args(FunctionCallInfo fcinfo);
extern Datum gin_tsquery_consistent_6args(FunctionCallInfo fcinfo);
extern Datum pg_advisory_xact_lock_int8(FunctionCallInfo fcinfo);
extern Datum pg_advisory_xact_lock_shared_int8(FunctionCallInfo fcinfo);
extern Datum pg_try_advisory_xact_lock_int8(FunctionCallInfo fcinfo);
extern Datum pg_try_advisory_xact_lock_shared_int8(FunctionCallInfo fcinfo);
extern Datum pg_advisory_xact_lock_int4(FunctionCallInfo fcinfo);
extern Datum pg_advisory_xact_lock_shared_int4(FunctionCallInfo fcinfo);
extern Datum pg_try_advisory_xact_lock_int4(FunctionCallInfo fcinfo);
extern Datum pg_try_advisory_xact_lock_shared_int4(FunctionCallInfo fcinfo);
extern Datum varchar_support(FunctionCallInfo fcinfo);
extern Datum pg_create_restore_point(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_wal_senders(FunctionCallInfo fcinfo);
extern Datum window_row_number(FunctionCallInfo fcinfo);
extern Datum window_rank(FunctionCallInfo fcinfo);
extern Datum window_dense_rank(FunctionCallInfo fcinfo);
extern Datum window_percent_rank(FunctionCallInfo fcinfo);
extern Datum window_cume_dist(FunctionCallInfo fcinfo);
extern Datum window_ntile(FunctionCallInfo fcinfo);
extern Datum window_lag(FunctionCallInfo fcinfo);
extern Datum window_lag_with_offset(FunctionCallInfo fcinfo);
extern Datum window_lag_with_offset_and_default(FunctionCallInfo fcinfo);
extern Datum window_lead(FunctionCallInfo fcinfo);
extern Datum window_lead_with_offset(FunctionCallInfo fcinfo);
extern Datum window_lead_with_offset_and_default(FunctionCallInfo fcinfo);
extern Datum window_first_value(FunctionCallInfo fcinfo);
extern Datum window_last_value(FunctionCallInfo fcinfo);
extern Datum window_nth_value(FunctionCallInfo fcinfo);
extern Datum fdw_handler_in(FunctionCallInfo fcinfo);
extern Datum fdw_handler_out(FunctionCallInfo fcinfo);
extern Datum void_recv(FunctionCallInfo fcinfo);
extern Datum void_send(FunctionCallInfo fcinfo);
extern Datum btint2sortsupport(FunctionCallInfo fcinfo);
extern Datum btint4sortsupport(FunctionCallInfo fcinfo);
extern Datum btint8sortsupport(FunctionCallInfo fcinfo);
extern Datum btfloat4sortsupport(FunctionCallInfo fcinfo);
extern Datum btfloat8sortsupport(FunctionCallInfo fcinfo);
extern Datum btoidsortsupport(FunctionCallInfo fcinfo);
extern Datum btnamesortsupport(FunctionCallInfo fcinfo);
extern Datum date_sortsupport(FunctionCallInfo fcinfo);
extern Datum timestamp_sortsupport(FunctionCallInfo fcinfo);
extern Datum has_type_privilege_name_name(FunctionCallInfo fcinfo);
extern Datum has_type_privilege_name_id(FunctionCallInfo fcinfo);
extern Datum has_type_privilege_id_name(FunctionCallInfo fcinfo);
extern Datum has_type_privilege_id_id(FunctionCallInfo fcinfo);
extern Datum has_type_privilege_name(FunctionCallInfo fcinfo);
extern Datum has_type_privilege_id(FunctionCallInfo fcinfo);
extern Datum macaddr_not(FunctionCallInfo fcinfo);
extern Datum macaddr_and(FunctionCallInfo fcinfo);
extern Datum macaddr_or(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_temp_files(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_temp_bytes(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_deadlocks(FunctionCallInfo fcinfo);
extern Datum array_to_json(FunctionCallInfo fcinfo);
extern Datum array_to_json_pretty(FunctionCallInfo fcinfo);
extern Datum row_to_json(FunctionCallInfo fcinfo);
extern Datum row_to_json_pretty(FunctionCallInfo fcinfo);
extern Datum numeric_support(FunctionCallInfo fcinfo);
extern Datum varbit_support(FunctionCallInfo fcinfo);
extern Datum pg_get_viewdef_wrap(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_checkpoint_write_time(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_checkpoint_sync_time(FunctionCallInfo fcinfo);
extern Datum pg_collation_for(FunctionCallInfo fcinfo);
extern Datum pg_trigger_depth(FunctionCallInfo fcinfo);
extern Datum pg_wal_lsn_diff(FunctionCallInfo fcinfo);
extern Datum pg_size_pretty_numeric(FunctionCallInfo fcinfo);
extern Datum array_remove(FunctionCallInfo fcinfo);
extern Datum array_replace(FunctionCallInfo fcinfo);
extern Datum rangesel(FunctionCallInfo fcinfo);
extern Datum be_lo_lseek64(FunctionCallInfo fcinfo);
extern Datum be_lo_tell64(FunctionCallInfo fcinfo);
extern Datum be_lo_truncate64(FunctionCallInfo fcinfo);
extern Datum json_agg_transfn(FunctionCallInfo fcinfo);
extern Datum json_agg_finalfn(FunctionCallInfo fcinfo);
extern Datum to_json(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_mod_since_analyze(FunctionCallInfo fcinfo);
extern Datum numeric_sum(FunctionCallInfo fcinfo);
extern Datum array_cardinality(FunctionCallInfo fcinfo);
extern Datum json_object_agg_transfn(FunctionCallInfo fcinfo);
extern Datum record_image_eq(FunctionCallInfo fcinfo);
extern Datum record_image_ne(FunctionCallInfo fcinfo);
extern Datum record_image_lt(FunctionCallInfo fcinfo);
extern Datum record_image_gt(FunctionCallInfo fcinfo);
extern Datum record_image_le(FunctionCallInfo fcinfo);
extern Datum record_image_ge(FunctionCallInfo fcinfo);
extern Datum btrecordimagecmp(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_archiver(FunctionCallInfo fcinfo);
extern Datum json_object_agg_finalfn(FunctionCallInfo fcinfo);
extern Datum json_build_array(FunctionCallInfo fcinfo);
extern Datum json_build_array_noargs(FunctionCallInfo fcinfo);
extern Datum json_build_object(FunctionCallInfo fcinfo);
extern Datum json_build_object_noargs(FunctionCallInfo fcinfo);
extern Datum json_object(FunctionCallInfo fcinfo);
extern Datum json_object_two_arg(FunctionCallInfo fcinfo);
extern Datum json_to_record(FunctionCallInfo fcinfo);
extern Datum json_to_recordset(FunctionCallInfo fcinfo);
extern Datum jsonb_array_length(FunctionCallInfo fcinfo);
extern Datum jsonb_each(FunctionCallInfo fcinfo);
extern Datum jsonb_populate_record(FunctionCallInfo fcinfo);
extern Datum jsonb_typeof(FunctionCallInfo fcinfo);
extern Datum jsonb_object_field_text(FunctionCallInfo fcinfo);
extern Datum jsonb_array_element(FunctionCallInfo fcinfo);
extern Datum jsonb_array_element_text(FunctionCallInfo fcinfo);
extern Datum jsonb_extract_path(FunctionCallInfo fcinfo);
extern Datum width_bucket_array(FunctionCallInfo fcinfo);
extern Datum jsonb_array_elements(FunctionCallInfo fcinfo);
extern Datum pg_lsn_in(FunctionCallInfo fcinfo);
extern Datum pg_lsn_out(FunctionCallInfo fcinfo);
extern Datum pg_lsn_lt(FunctionCallInfo fcinfo);
extern Datum pg_lsn_le(FunctionCallInfo fcinfo);
extern Datum pg_lsn_eq(FunctionCallInfo fcinfo);
extern Datum pg_lsn_ge(FunctionCallInfo fcinfo);
extern Datum pg_lsn_gt(FunctionCallInfo fcinfo);
extern Datum pg_lsn_ne(FunctionCallInfo fcinfo);
extern Datum pg_lsn_mi(FunctionCallInfo fcinfo);
extern Datum pg_lsn_recv(FunctionCallInfo fcinfo);
extern Datum pg_lsn_send(FunctionCallInfo fcinfo);
extern Datum pg_lsn_cmp(FunctionCallInfo fcinfo);
extern Datum pg_lsn_hash(FunctionCallInfo fcinfo);
extern Datum bttextsortsupport(FunctionCallInfo fcinfo);
extern Datum generate_series_step_numeric(FunctionCallInfo fcinfo);
extern Datum generate_series_numeric(FunctionCallInfo fcinfo);
extern Datum json_strip_nulls(FunctionCallInfo fcinfo);
extern Datum jsonb_strip_nulls(FunctionCallInfo fcinfo);
extern Datum jsonb_object(FunctionCallInfo fcinfo);
extern Datum jsonb_object_two_arg(FunctionCallInfo fcinfo);
extern Datum jsonb_agg_transfn(FunctionCallInfo fcinfo);
extern Datum jsonb_agg_finalfn(FunctionCallInfo fcinfo);
extern Datum jsonb_object_agg_transfn(FunctionCallInfo fcinfo);
extern Datum jsonb_object_agg_finalfn(FunctionCallInfo fcinfo);
extern Datum jsonb_build_array(FunctionCallInfo fcinfo);
extern Datum jsonb_build_array_noargs(FunctionCallInfo fcinfo);
extern Datum jsonb_build_object(FunctionCallInfo fcinfo);
extern Datum jsonb_build_object_noargs(FunctionCallInfo fcinfo);
extern Datum dist_ppoly(FunctionCallInfo fcinfo);
extern Datum array_position(FunctionCallInfo fcinfo);
extern Datum array_position_start(FunctionCallInfo fcinfo);
extern Datum array_positions(FunctionCallInfo fcinfo);
extern Datum gist_circle_distance(FunctionCallInfo fcinfo);
extern Datum numeric_scale(FunctionCallInfo fcinfo);
extern Datum gist_point_fetch(FunctionCallInfo fcinfo);
extern Datum numeric_sortsupport(FunctionCallInfo fcinfo);
extern Datum gist_poly_distance(FunctionCallInfo fcinfo);
extern Datum dist_cpoint(FunctionCallInfo fcinfo);
extern Datum dist_polyp(FunctionCallInfo fcinfo);
extern Datum pg_read_file_v2(FunctionCallInfo fcinfo);
extern Datum show_config_by_name_missing_ok(FunctionCallInfo fcinfo);
extern Datum pg_read_binary_file(FunctionCallInfo fcinfo);
extern Datum pg_notification_queue_usage(FunctionCallInfo fcinfo);
extern Datum pg_ls_dir(FunctionCallInfo fcinfo);
extern Datum row_security_active(FunctionCallInfo fcinfo);
extern Datum row_security_active_name(FunctionCallInfo fcinfo);
extern Datum uuid_sortsupport(FunctionCallInfo fcinfo);
extern Datum jsonb_concat(FunctionCallInfo fcinfo);
extern Datum jsonb_delete(FunctionCallInfo fcinfo);
extern Datum jsonb_delete_idx(FunctionCallInfo fcinfo);
extern Datum jsonb_delete_path(FunctionCallInfo fcinfo);
extern Datum jsonb_set(FunctionCallInfo fcinfo);
extern Datum jsonb_pretty(FunctionCallInfo fcinfo);
extern Datum pg_stat_file(FunctionCallInfo fcinfo);
extern Datum xidneq(FunctionCallInfo fcinfo);
extern Datum tsm_handler_in(FunctionCallInfo fcinfo);
extern Datum tsm_handler_out(FunctionCallInfo fcinfo);
extern Datum tsm_bernoulli_handler(FunctionCallInfo fcinfo);
extern Datum tsm_system_handler(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_wal_receiver(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_progress_info(FunctionCallInfo fcinfo);
extern Datum tsvector_filter(FunctionCallInfo fcinfo);
extern Datum tsvector_setweight_by_filter(FunctionCallInfo fcinfo);
extern Datum tsvector_delete_str(FunctionCallInfo fcinfo);
extern Datum tsvector_unnest(FunctionCallInfo fcinfo);
extern Datum tsvector_delete_arr(FunctionCallInfo fcinfo);
extern Datum int4_avg_combine(FunctionCallInfo fcinfo);
extern Datum interval_combine(FunctionCallInfo fcinfo);
extern Datum tsvector_to_array(FunctionCallInfo fcinfo);
extern Datum array_to_tsvector(FunctionCallInfo fcinfo);
extern Datum bpchar_sortsupport(FunctionCallInfo fcinfo);
extern Datum show_all_file_settings(FunctionCallInfo fcinfo);
extern Datum pg_current_wal_flush_lsn(FunctionCallInfo fcinfo);
extern Datum bytea_sortsupport(FunctionCallInfo fcinfo);
extern Datum bttext_pattern_sortsupport(FunctionCallInfo fcinfo);
extern Datum btbpchar_pattern_sortsupport(FunctionCallInfo fcinfo);
extern Datum pg_size_bytes(FunctionCallInfo fcinfo);
extern Datum numeric_serialize(FunctionCallInfo fcinfo);
extern Datum numeric_deserialize(FunctionCallInfo fcinfo);
extern Datum numeric_avg_combine(FunctionCallInfo fcinfo);
extern Datum numeric_poly_combine(FunctionCallInfo fcinfo);
extern Datum numeric_poly_serialize(FunctionCallInfo fcinfo);
extern Datum numeric_poly_deserialize(FunctionCallInfo fcinfo);
extern Datum numeric_combine(FunctionCallInfo fcinfo);
extern Datum float8_regr_combine(FunctionCallInfo fcinfo);
extern Datum jsonb_delete_array(FunctionCallInfo fcinfo);
extern Datum cash_mul_int8(FunctionCallInfo fcinfo);
extern Datum cash_div_int8(FunctionCallInfo fcinfo);
extern Datum txid_current_if_assigned(FunctionCallInfo fcinfo);
extern Datum pg_get_partkeydef(FunctionCallInfo fcinfo);
extern Datum pg_ls_logdir(FunctionCallInfo fcinfo);
extern Datum pg_ls_waldir(FunctionCallInfo fcinfo);
extern Datum pg_ndistinct_in(FunctionCallInfo fcinfo);
extern Datum pg_ndistinct_out(FunctionCallInfo fcinfo);
extern Datum pg_ndistinct_recv(FunctionCallInfo fcinfo);
extern Datum pg_ndistinct_send(FunctionCallInfo fcinfo);
extern Datum macaddr_sortsupport(FunctionCallInfo fcinfo);
extern Datum txid_status(FunctionCallInfo fcinfo);
extern Datum pg_safe_snapshot_blocking_pids(FunctionCallInfo fcinfo);
extern Datum pg_isolation_test_session_is_blocked(FunctionCallInfo fcinfo);
extern Datum pg_identify_object_as_address(FunctionCallInfo fcinfo);
extern Datum brin_minmax_opcinfo(FunctionCallInfo fcinfo);
extern Datum brin_minmax_add_value(FunctionCallInfo fcinfo);
extern Datum brin_minmax_consistent(FunctionCallInfo fcinfo);
extern Datum brin_minmax_union(FunctionCallInfo fcinfo);
extern Datum int8_avg_accum_inv(FunctionCallInfo fcinfo);
extern Datum numeric_poly_sum(FunctionCallInfo fcinfo);
extern Datum numeric_poly_avg(FunctionCallInfo fcinfo);
extern Datum numeric_poly_var_pop(FunctionCallInfo fcinfo);
extern Datum numeric_poly_var_samp(FunctionCallInfo fcinfo);
extern Datum numeric_poly_stddev_pop(FunctionCallInfo fcinfo);
extern Datum numeric_poly_stddev_samp(FunctionCallInfo fcinfo);
extern Datum regexp_match_no_flags(FunctionCallInfo fcinfo);
extern Datum regexp_match(FunctionCallInfo fcinfo);
extern Datum int8_mul_cash(FunctionCallInfo fcinfo);
extern Datum pg_config(FunctionCallInfo fcinfo);
extern Datum pg_hba_file_rules(FunctionCallInfo fcinfo);
extern Datum pg_statistics_obj_is_visible(FunctionCallInfo fcinfo);
extern Datum pg_dependencies_in(FunctionCallInfo fcinfo);
extern Datum pg_dependencies_out(FunctionCallInfo fcinfo);
extern Datum pg_dependencies_recv(FunctionCallInfo fcinfo);
extern Datum pg_dependencies_send(FunctionCallInfo fcinfo);
extern Datum pg_get_partition_constraintdef(FunctionCallInfo fcinfo);
extern Datum time_hash_extended(FunctionCallInfo fcinfo);
extern Datum timetz_hash_extended(FunctionCallInfo fcinfo);
extern Datum timestamp_hash_extended(FunctionCallInfo fcinfo);
extern Datum uuid_hash_extended(FunctionCallInfo fcinfo);
extern Datum pg_lsn_hash_extended(FunctionCallInfo fcinfo);
extern Datum hashenumextended(FunctionCallInfo fcinfo);
extern Datum pg_get_statisticsobjdef(FunctionCallInfo fcinfo);
extern Datum jsonb_hash_extended(FunctionCallInfo fcinfo);
extern Datum hash_range_extended(FunctionCallInfo fcinfo);
extern Datum interval_hash_extended(FunctionCallInfo fcinfo);
extern Datum sha224_bytea(FunctionCallInfo fcinfo);
extern Datum sha256_bytea(FunctionCallInfo fcinfo);
extern Datum sha384_bytea(FunctionCallInfo fcinfo);
extern Datum sha512_bytea(FunctionCallInfo fcinfo);
extern Datum pg_partition_tree(FunctionCallInfo fcinfo);
extern Datum pg_partition_root(FunctionCallInfo fcinfo);
extern Datum pg_partition_ancestors(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_checksum_failures(FunctionCallInfo fcinfo);
extern Datum pg_stats_ext_mcvlist_items(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_db_checksum_last_failure(FunctionCallInfo fcinfo);
extern Datum pg_promote(FunctionCallInfo fcinfo);
extern Datum prefixsel(FunctionCallInfo fcinfo);
extern Datum prefixjoinsel(FunctionCallInfo fcinfo);
extern Datum pg_control_system(FunctionCallInfo fcinfo);
extern Datum pg_control_checkpoint(FunctionCallInfo fcinfo);
extern Datum pg_control_recovery(FunctionCallInfo fcinfo);
extern Datum pg_control_init(FunctionCallInfo fcinfo);
extern Datum pg_import_system_collations(FunctionCallInfo fcinfo);
extern Datum macaddr8_recv(FunctionCallInfo fcinfo);
extern Datum macaddr8_send(FunctionCallInfo fcinfo);
extern Datum pg_collation_actual_version(FunctionCallInfo fcinfo);
extern Datum jsonb_numeric(FunctionCallInfo fcinfo);
extern Datum jsonb_int2(FunctionCallInfo fcinfo);
extern Datum jsonb_int4(FunctionCallInfo fcinfo);
extern Datum jsonb_int8(FunctionCallInfo fcinfo);
extern Datum jsonb_float4(FunctionCallInfo fcinfo);
extern Datum pg_filenode_relation(FunctionCallInfo fcinfo);
extern Datum be_lo_from_bytea(FunctionCallInfo fcinfo);
extern Datum be_lo_get(FunctionCallInfo fcinfo);
extern Datum be_lo_get_fragment(FunctionCallInfo fcinfo);
extern Datum be_lo_put(FunctionCallInfo fcinfo);
extern Datum make_timestamp(FunctionCallInfo fcinfo);
extern Datum make_timestamptz(FunctionCallInfo fcinfo);
extern Datum make_timestamptz_at_timezone(FunctionCallInfo fcinfo);
extern Datum make_interval(FunctionCallInfo fcinfo);
extern Datum jsonb_array_elements_text(FunctionCallInfo fcinfo);
extern Datum spg_range_quad_config(FunctionCallInfo fcinfo);
extern Datum spg_range_quad_choose(FunctionCallInfo fcinfo);
extern Datum spg_range_quad_picksplit(FunctionCallInfo fcinfo);
extern Datum spg_range_quad_inner_consistent(FunctionCallInfo fcinfo);
extern Datum spg_range_quad_leaf_consistent(FunctionCallInfo fcinfo);
extern Datum jsonb_populate_recordset(FunctionCallInfo fcinfo);
extern Datum to_regoperator(FunctionCallInfo fcinfo);
extern Datum jsonb_object_field(FunctionCallInfo fcinfo);
extern Datum to_regprocedure(FunctionCallInfo fcinfo);
extern Datum gin_compare_jsonb(FunctionCallInfo fcinfo);
extern Datum gin_extract_jsonb(FunctionCallInfo fcinfo);
extern Datum gin_extract_jsonb_query(FunctionCallInfo fcinfo);
extern Datum gin_consistent_jsonb(FunctionCallInfo fcinfo);
extern Datum gin_extract_jsonb_path(FunctionCallInfo fcinfo);
extern Datum gin_extract_jsonb_query_path(FunctionCallInfo fcinfo);
extern Datum gin_consistent_jsonb_path(FunctionCallInfo fcinfo);
extern Datum gin_triconsistent_jsonb(FunctionCallInfo fcinfo);
extern Datum gin_triconsistent_jsonb_path(FunctionCallInfo fcinfo);
extern Datum jsonb_to_record(FunctionCallInfo fcinfo);
extern Datum jsonb_to_recordset(FunctionCallInfo fcinfo);
extern Datum to_regoper(FunctionCallInfo fcinfo);
extern Datum to_regtype(FunctionCallInfo fcinfo);
extern Datum to_regproc(FunctionCallInfo fcinfo);
extern Datum to_regclass(FunctionCallInfo fcinfo);
extern Datum bool_accum(FunctionCallInfo fcinfo);
extern Datum bool_accum_inv(FunctionCallInfo fcinfo);
extern Datum bool_alltrue(FunctionCallInfo fcinfo);
extern Datum bool_anytrue(FunctionCallInfo fcinfo);
extern Datum anyenum_in(FunctionCallInfo fcinfo);
extern Datum anyenum_out(FunctionCallInfo fcinfo);
extern Datum enum_in(FunctionCallInfo fcinfo);
extern Datum enum_out(FunctionCallInfo fcinfo);
extern Datum enum_eq(FunctionCallInfo fcinfo);
extern Datum enum_ne(FunctionCallInfo fcinfo);
extern Datum enum_lt(FunctionCallInfo fcinfo);
extern Datum enum_gt(FunctionCallInfo fcinfo);
extern Datum enum_le(FunctionCallInfo fcinfo);
extern Datum enum_ge(FunctionCallInfo fcinfo);
extern Datum enum_cmp(FunctionCallInfo fcinfo);
extern Datum hashenum(FunctionCallInfo fcinfo);
extern Datum enum_smaller(FunctionCallInfo fcinfo);
extern Datum enum_larger(FunctionCallInfo fcinfo);
extern Datum enum_first(FunctionCallInfo fcinfo);
extern Datum enum_last(FunctionCallInfo fcinfo);
extern Datum enum_range_bounds(FunctionCallInfo fcinfo);
extern Datum enum_range_all(FunctionCallInfo fcinfo);
extern Datum enum_recv(FunctionCallInfo fcinfo);
extern Datum enum_send(FunctionCallInfo fcinfo);
extern Datum string_agg_transfn(FunctionCallInfo fcinfo);
extern Datum string_agg_finalfn(FunctionCallInfo fcinfo);
extern Datum pg_describe_object(FunctionCallInfo fcinfo);
extern Datum text_format(FunctionCallInfo fcinfo);
extern Datum text_format_nv(FunctionCallInfo fcinfo);
extern Datum bytea_string_agg_transfn(FunctionCallInfo fcinfo);
extern Datum bytea_string_agg_finalfn(FunctionCallInfo fcinfo);
extern Datum int8dec(FunctionCallInfo fcinfo);
extern Datum int8dec_any(FunctionCallInfo fcinfo);
extern Datum numeric_accum_inv(FunctionCallInfo fcinfo);
extern Datum interval_accum_inv(FunctionCallInfo fcinfo);
extern Datum network_overlap(FunctionCallInfo fcinfo);
extern Datum inet_gist_consistent(FunctionCallInfo fcinfo);
extern Datum inet_gist_union(FunctionCallInfo fcinfo);
extern Datum inet_gist_compress(FunctionCallInfo fcinfo);
extern Datum jsonb_bool(FunctionCallInfo fcinfo);
extern Datum inet_gist_penalty(FunctionCallInfo fcinfo);
extern Datum inet_gist_picksplit(FunctionCallInfo fcinfo);
extern Datum inet_gist_same(FunctionCallInfo fcinfo);
extern Datum networksel(FunctionCallInfo fcinfo);
extern Datum networkjoinsel(FunctionCallInfo fcinfo);
extern Datum network_larger(FunctionCallInfo fcinfo);
extern Datum network_smaller(FunctionCallInfo fcinfo);
extern Datum pg_event_trigger_dropped_objects(FunctionCallInfo fcinfo);
extern Datum int2_accum_inv(FunctionCallInfo fcinfo);
extern Datum int4_accum_inv(FunctionCallInfo fcinfo);
extern Datum int8_accum_inv(FunctionCallInfo fcinfo);
extern Datum int2_avg_accum_inv(FunctionCallInfo fcinfo);
extern Datum int4_avg_accum_inv(FunctionCallInfo fcinfo);
extern Datum int2int4_sum(FunctionCallInfo fcinfo);
extern Datum inet_gist_fetch(FunctionCallInfo fcinfo);
extern Datum pg_logical_emit_message_text(FunctionCallInfo fcinfo);
extern Datum pg_logical_emit_message_bytea(FunctionCallInfo fcinfo);
extern Datum jsonb_insert(FunctionCallInfo fcinfo);
extern Datum pg_xact_commit_timestamp(FunctionCallInfo fcinfo);
extern Datum binary_upgrade_set_next_pg_type_oid(FunctionCallInfo fcinfo);
extern Datum pg_last_committed_xact(FunctionCallInfo fcinfo);
extern Datum binary_upgrade_set_next_array_pg_type_oid(FunctionCallInfo fcinfo);
extern Datum binary_upgrade_set_next_toast_pg_type_oid(FunctionCallInfo fcinfo);
extern Datum binary_upgrade_set_next_heap_pg_class_oid(FunctionCallInfo fcinfo);
extern Datum binary_upgrade_set_next_index_pg_class_oid(FunctionCallInfo fcinfo);
extern Datum binary_upgrade_set_next_toast_pg_class_oid(FunctionCallInfo fcinfo);
extern Datum binary_upgrade_set_next_pg_enum_oid(FunctionCallInfo fcinfo);
extern Datum binary_upgrade_set_next_pg_authid_oid(FunctionCallInfo fcinfo);
extern Datum binary_upgrade_create_empty_extension(FunctionCallInfo fcinfo);
extern Datum event_trigger_in(FunctionCallInfo fcinfo);
extern Datum event_trigger_out(FunctionCallInfo fcinfo);
extern Datum tsvectorin(FunctionCallInfo fcinfo);
extern Datum tsvectorout(FunctionCallInfo fcinfo);
extern Datum tsqueryin(FunctionCallInfo fcinfo);
extern Datum tsqueryout(FunctionCallInfo fcinfo);
extern Datum tsvector_lt(FunctionCallInfo fcinfo);
extern Datum tsvector_le(FunctionCallInfo fcinfo);
extern Datum tsvector_eq(FunctionCallInfo fcinfo);
extern Datum tsvector_ne(FunctionCallInfo fcinfo);
extern Datum tsvector_ge(FunctionCallInfo fcinfo);
extern Datum tsvector_gt(FunctionCallInfo fcinfo);
extern Datum tsvector_cmp(FunctionCallInfo fcinfo);
extern Datum tsvector_strip(FunctionCallInfo fcinfo);
extern Datum tsvector_setweight(FunctionCallInfo fcinfo);
extern Datum tsvector_concat(FunctionCallInfo fcinfo);
extern Datum ts_match_vq(FunctionCallInfo fcinfo);
extern Datum ts_match_qv(FunctionCallInfo fcinfo);
extern Datum tsvectorsend(FunctionCallInfo fcinfo);
extern Datum tsvectorrecv(FunctionCallInfo fcinfo);
extern Datum tsquerysend(FunctionCallInfo fcinfo);
extern Datum tsqueryrecv(FunctionCallInfo fcinfo);
extern Datum gtsvectorin(FunctionCallInfo fcinfo);
extern Datum gtsvectorout(FunctionCallInfo fcinfo);
extern Datum gtsvector_compress(FunctionCallInfo fcinfo);
extern Datum gtsvector_decompress(FunctionCallInfo fcinfo);
extern Datum gtsvector_picksplit(FunctionCallInfo fcinfo);
extern Datum gtsvector_union(FunctionCallInfo fcinfo);
extern Datum gtsvector_same(FunctionCallInfo fcinfo);
extern Datum gtsvector_penalty(FunctionCallInfo fcinfo);
extern Datum gtsvector_consistent(FunctionCallInfo fcinfo);
extern Datum gin_extract_tsvector(FunctionCallInfo fcinfo);
extern Datum gin_extract_tsquery(FunctionCallInfo fcinfo);
extern Datum gin_tsquery_consistent(FunctionCallInfo fcinfo);
extern Datum tsquery_lt(FunctionCallInfo fcinfo);
extern Datum tsquery_le(FunctionCallInfo fcinfo);
extern Datum tsquery_eq(FunctionCallInfo fcinfo);
extern Datum tsquery_ne(FunctionCallInfo fcinfo);
extern Datum tsquery_ge(FunctionCallInfo fcinfo);
extern Datum tsquery_gt(FunctionCallInfo fcinfo);
extern Datum tsquery_cmp(FunctionCallInfo fcinfo);
extern Datum tsquery_and(FunctionCallInfo fcinfo);
extern Datum tsquery_or(FunctionCallInfo fcinfo);
extern Datum tsquery_not(FunctionCallInfo fcinfo);
extern Datum tsquery_numnode(FunctionCallInfo fcinfo);
extern Datum tsquerytree(FunctionCallInfo fcinfo);
extern Datum tsquery_rewrite(FunctionCallInfo fcinfo);
extern Datum tsquery_rewrite_query(FunctionCallInfo fcinfo);
extern Datum tsmatchsel(FunctionCallInfo fcinfo);
extern Datum tsmatchjoinsel(FunctionCallInfo fcinfo);
extern Datum ts_typanalyze(FunctionCallInfo fcinfo);
extern Datum ts_stat1(FunctionCallInfo fcinfo);
extern Datum ts_stat2(FunctionCallInfo fcinfo);
extern Datum tsq_mcontains(FunctionCallInfo fcinfo);
extern Datum tsq_mcontained(FunctionCallInfo fcinfo);
extern Datum gtsquery_compress(FunctionCallInfo fcinfo);
extern Datum text_starts_with(FunctionCallInfo fcinfo);
extern Datum gtsquery_picksplit(FunctionCallInfo fcinfo);
extern Datum gtsquery_union(FunctionCallInfo fcinfo);
extern Datum gtsquery_same(FunctionCallInfo fcinfo);
extern Datum gtsquery_penalty(FunctionCallInfo fcinfo);
extern Datum gtsquery_consistent(FunctionCallInfo fcinfo);
extern Datum ts_rank_wttf(FunctionCallInfo fcinfo);
extern Datum ts_rank_wtt(FunctionCallInfo fcinfo);
extern Datum ts_rank_ttf(FunctionCallInfo fcinfo);
extern Datum ts_rank_tt(FunctionCallInfo fcinfo);
extern Datum ts_rankcd_wttf(FunctionCallInfo fcinfo);
extern Datum ts_rankcd_wtt(FunctionCallInfo fcinfo);
extern Datum ts_rankcd_ttf(FunctionCallInfo fcinfo);
extern Datum ts_rankcd_tt(FunctionCallInfo fcinfo);
extern Datum tsvector_length(FunctionCallInfo fcinfo);
extern Datum ts_token_type_byid(FunctionCallInfo fcinfo);
extern Datum ts_token_type_byname(FunctionCallInfo fcinfo);
extern Datum ts_parse_byid(FunctionCallInfo fcinfo);
extern Datum ts_parse_byname(FunctionCallInfo fcinfo);
extern Datum prsd_start(FunctionCallInfo fcinfo);
extern Datum prsd_nexttoken(FunctionCallInfo fcinfo);
extern Datum prsd_end(FunctionCallInfo fcinfo);
extern Datum prsd_headline(FunctionCallInfo fcinfo);
extern Datum prsd_lextype(FunctionCallInfo fcinfo);
extern Datum ts_lexize(FunctionCallInfo fcinfo);
extern Datum gin_cmp_tslexeme(FunctionCallInfo fcinfo);
extern Datum dsimple_init(FunctionCallInfo fcinfo);
extern Datum dsimple_lexize(FunctionCallInfo fcinfo);
extern Datum dsynonym_init(FunctionCallInfo fcinfo);
extern Datum dsynonym_lexize(FunctionCallInfo fcinfo);
extern Datum dispell_init(FunctionCallInfo fcinfo);
extern Datum dispell_lexize(FunctionCallInfo fcinfo);
extern Datum regconfigin(FunctionCallInfo fcinfo);
extern Datum regconfigout(FunctionCallInfo fcinfo);
extern Datum regconfigrecv(FunctionCallInfo fcinfo);
extern Datum regconfigsend(FunctionCallInfo fcinfo);
extern Datum thesaurus_init(FunctionCallInfo fcinfo);
extern Datum thesaurus_lexize(FunctionCallInfo fcinfo);
extern Datum ts_headline_byid_opt(FunctionCallInfo fcinfo);
extern Datum ts_headline_byid(FunctionCallInfo fcinfo);
extern Datum to_tsvector_byid(FunctionCallInfo fcinfo);
extern Datum to_tsquery_byid(FunctionCallInfo fcinfo);
extern Datum plainto_tsquery_byid(FunctionCallInfo fcinfo);
extern Datum to_tsvector(FunctionCallInfo fcinfo);
extern Datum to_tsquery(FunctionCallInfo fcinfo);
extern Datum plainto_tsquery(FunctionCallInfo fcinfo);
extern Datum tsvector_update_trigger_byid(FunctionCallInfo fcinfo);
extern Datum tsvector_update_trigger_bycolumn(FunctionCallInfo fcinfo);
extern Datum ts_headline_opt(FunctionCallInfo fcinfo);
extern Datum ts_headline(FunctionCallInfo fcinfo);
extern Datum pg_ts_parser_is_visible(FunctionCallInfo fcinfo);
extern Datum pg_ts_dict_is_visible(FunctionCallInfo fcinfo);
extern Datum pg_ts_config_is_visible(FunctionCallInfo fcinfo);
extern Datum get_current_ts_config(FunctionCallInfo fcinfo);
extern Datum ts_match_tt(FunctionCallInfo fcinfo);
extern Datum ts_match_tq(FunctionCallInfo fcinfo);
extern Datum pg_ts_template_is_visible(FunctionCallInfo fcinfo);
extern Datum regdictionaryin(FunctionCallInfo fcinfo);
extern Datum regdictionaryout(FunctionCallInfo fcinfo);
extern Datum regdictionaryrecv(FunctionCallInfo fcinfo);
extern Datum regdictionarysend(FunctionCallInfo fcinfo);
extern Datum pg_stat_reset_shared(FunctionCallInfo fcinfo);
extern Datum pg_stat_reset_single_table_counters(FunctionCallInfo fcinfo);
extern Datum pg_stat_reset_single_function_counters(FunctionCallInfo fcinfo);
extern Datum pg_tablespace_location(FunctionCallInfo fcinfo);
extern Datum pg_create_physical_replication_slot(FunctionCallInfo fcinfo);
extern Datum pg_drop_replication_slot(FunctionCallInfo fcinfo);
extern Datum pg_get_replication_slots(FunctionCallInfo fcinfo);
extern Datum pg_logical_slot_get_changes(FunctionCallInfo fcinfo);
extern Datum pg_logical_slot_get_binary_changes(FunctionCallInfo fcinfo);
extern Datum pg_logical_slot_peek_changes(FunctionCallInfo fcinfo);
extern Datum pg_logical_slot_peek_binary_changes(FunctionCallInfo fcinfo);
extern Datum pg_create_logical_replication_slot(FunctionCallInfo fcinfo);
extern Datum to_jsonb(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_snapshot_timestamp(FunctionCallInfo fcinfo);
extern Datum gin_clean_pending_list(FunctionCallInfo fcinfo);
extern Datum gtsvector_consistent_oldsig(FunctionCallInfo fcinfo);
extern Datum gin_extract_tsquery_oldsig(FunctionCallInfo fcinfo);
extern Datum gin_tsquery_consistent_oldsig(FunctionCallInfo fcinfo);
extern Datum gtsquery_consistent_oldsig(FunctionCallInfo fcinfo);
extern Datum inet_spg_config(FunctionCallInfo fcinfo);
extern Datum inet_spg_choose(FunctionCallInfo fcinfo);
extern Datum inet_spg_picksplit(FunctionCallInfo fcinfo);
extern Datum inet_spg_inner_consistent(FunctionCallInfo fcinfo);
extern Datum inet_spg_leaf_consistent(FunctionCallInfo fcinfo);
extern Datum pg_current_logfile(FunctionCallInfo fcinfo);
extern Datum pg_current_logfile_1arg(FunctionCallInfo fcinfo);
extern Datum jsonb_send(FunctionCallInfo fcinfo);
extern Datum jsonb_out(FunctionCallInfo fcinfo);
extern Datum jsonb_recv(FunctionCallInfo fcinfo);
extern Datum jsonb_in(FunctionCallInfo fcinfo);
extern Datum pg_get_function_arg_default(FunctionCallInfo fcinfo);
extern Datum pg_export_snapshot(FunctionCallInfo fcinfo);
extern Datum pg_is_in_recovery(FunctionCallInfo fcinfo);
extern Datum int4_cash(FunctionCallInfo fcinfo);
extern Datum int8_cash(FunctionCallInfo fcinfo);
extern Datum pg_is_in_backup(FunctionCallInfo fcinfo);
extern Datum pg_backup_start_time(FunctionCallInfo fcinfo);
extern Datum pg_collation_is_visible(FunctionCallInfo fcinfo);
extern Datum array_typanalyze(FunctionCallInfo fcinfo);
extern Datum arraycontsel(FunctionCallInfo fcinfo);
extern Datum arraycontjoinsel(FunctionCallInfo fcinfo);
extern Datum pg_get_multixact_members(FunctionCallInfo fcinfo);
extern Datum pg_last_wal_receive_lsn(FunctionCallInfo fcinfo);
extern Datum pg_last_wal_replay_lsn(FunctionCallInfo fcinfo);
extern Datum cash_div_cash(FunctionCallInfo fcinfo);
extern Datum cash_numeric(FunctionCallInfo fcinfo);
extern Datum numeric_cash(FunctionCallInfo fcinfo);
extern Datum pg_read_file_all(FunctionCallInfo fcinfo);
extern Datum pg_read_binary_file_off_len(FunctionCallInfo fcinfo);
extern Datum pg_read_binary_file_all(FunctionCallInfo fcinfo);
extern Datum pg_opfamily_is_visible(FunctionCallInfo fcinfo);
extern Datum pg_last_xact_replay_timestamp(FunctionCallInfo fcinfo);
extern Datum anyrange_in(FunctionCallInfo fcinfo);
extern Datum anyrange_out(FunctionCallInfo fcinfo);
extern Datum range_in(FunctionCallInfo fcinfo);
extern Datum range_out(FunctionCallInfo fcinfo);
extern Datum range_recv(FunctionCallInfo fcinfo);
extern Datum range_send(FunctionCallInfo fcinfo);
extern Datum pg_identify_object(FunctionCallInfo fcinfo);
extern Datum range_constructor2(FunctionCallInfo fcinfo);
extern Datum range_constructor3(FunctionCallInfo fcinfo);
extern Datum pg_relation_is_updatable(FunctionCallInfo fcinfo);
extern Datum pg_column_is_updatable(FunctionCallInfo fcinfo);
extern Datum make_date(FunctionCallInfo fcinfo);
extern Datum make_time(FunctionCallInfo fcinfo);
extern Datum range_lower(FunctionCallInfo fcinfo);
extern Datum range_upper(FunctionCallInfo fcinfo);
extern Datum range_empty(FunctionCallInfo fcinfo);
extern Datum range_lower_inc(FunctionCallInfo fcinfo);
extern Datum range_upper_inc(FunctionCallInfo fcinfo);
extern Datum range_lower_inf(FunctionCallInfo fcinfo);
extern Datum range_upper_inf(FunctionCallInfo fcinfo);
extern Datum range_eq(FunctionCallInfo fcinfo);
extern Datum range_ne(FunctionCallInfo fcinfo);
extern Datum range_overlaps(FunctionCallInfo fcinfo);
extern Datum range_contains_elem(FunctionCallInfo fcinfo);
extern Datum range_contains(FunctionCallInfo fcinfo);
extern Datum elem_contained_by_range(FunctionCallInfo fcinfo);
extern Datum range_contained_by(FunctionCallInfo fcinfo);
extern Datum range_adjacent(FunctionCallInfo fcinfo);
extern Datum range_before(FunctionCallInfo fcinfo);
extern Datum range_after(FunctionCallInfo fcinfo);
extern Datum range_overleft(FunctionCallInfo fcinfo);
extern Datum range_overright(FunctionCallInfo fcinfo);
extern Datum range_union(FunctionCallInfo fcinfo);
extern Datum range_intersect(FunctionCallInfo fcinfo);
extern Datum range_minus(FunctionCallInfo fcinfo);
extern Datum range_cmp(FunctionCallInfo fcinfo);
extern Datum range_lt(FunctionCallInfo fcinfo);
extern Datum range_le(FunctionCallInfo fcinfo);
extern Datum range_ge(FunctionCallInfo fcinfo);
extern Datum range_gt(FunctionCallInfo fcinfo);
extern Datum range_gist_consistent(FunctionCallInfo fcinfo);
extern Datum range_gist_union(FunctionCallInfo fcinfo);
extern Datum pg_replication_slot_advance(FunctionCallInfo fcinfo);
extern Datum range_gist_penalty(FunctionCallInfo fcinfo);
extern Datum range_gist_picksplit(FunctionCallInfo fcinfo);
extern Datum range_gist_same(FunctionCallInfo fcinfo);
extern Datum hash_range(FunctionCallInfo fcinfo);
extern Datum int4range_canonical(FunctionCallInfo fcinfo);
extern Datum daterange_canonical(FunctionCallInfo fcinfo);
extern Datum range_typanalyze(FunctionCallInfo fcinfo);
extern Datum timestamp_support(FunctionCallInfo fcinfo);
extern Datum interval_support(FunctionCallInfo fcinfo);
extern Datum ginarraytriconsistent(FunctionCallInfo fcinfo);
extern Datum gin_tsquery_triconsistent(FunctionCallInfo fcinfo);
extern Datum int4range_subdiff(FunctionCallInfo fcinfo);
extern Datum int8range_subdiff(FunctionCallInfo fcinfo);
extern Datum numrange_subdiff(FunctionCallInfo fcinfo);
extern Datum daterange_subdiff(FunctionCallInfo fcinfo);
extern Datum int8range_canonical(FunctionCallInfo fcinfo);
extern Datum tsrange_subdiff(FunctionCallInfo fcinfo);
extern Datum tstzrange_subdiff(FunctionCallInfo fcinfo);
extern Datum jsonb_object_keys(FunctionCallInfo fcinfo);
extern Datum jsonb_each_text(FunctionCallInfo fcinfo);
extern Datum mxid_age(FunctionCallInfo fcinfo);
extern Datum jsonb_extract_path_text(FunctionCallInfo fcinfo);
extern Datum acldefault_sql(FunctionCallInfo fcinfo);
extern Datum time_support(FunctionCallInfo fcinfo);
extern Datum json_object_field(FunctionCallInfo fcinfo);
extern Datum json_object_field_text(FunctionCallInfo fcinfo);
extern Datum json_array_element(FunctionCallInfo fcinfo);
extern Datum json_array_element_text(FunctionCallInfo fcinfo);
extern Datum json_extract_path(FunctionCallInfo fcinfo);
extern Datum brin_summarize_new_values(FunctionCallInfo fcinfo);
extern Datum json_extract_path_text(FunctionCallInfo fcinfo);
extern Datum pg_get_object_address(FunctionCallInfo fcinfo);
extern Datum json_array_elements(FunctionCallInfo fcinfo);
extern Datum json_array_length(FunctionCallInfo fcinfo);
extern Datum json_object_keys(FunctionCallInfo fcinfo);
extern Datum json_each(FunctionCallInfo fcinfo);
extern Datum json_each_text(FunctionCallInfo fcinfo);
extern Datum json_populate_record(FunctionCallInfo fcinfo);
extern Datum json_populate_recordset(FunctionCallInfo fcinfo);
extern Datum json_typeof(FunctionCallInfo fcinfo);
extern Datum json_array_elements_text(FunctionCallInfo fcinfo);
extern Datum ordered_set_transition(FunctionCallInfo fcinfo);
extern Datum ordered_set_transition_multi(FunctionCallInfo fcinfo);
extern Datum percentile_disc_final(FunctionCallInfo fcinfo);
extern Datum percentile_cont_float8_final(FunctionCallInfo fcinfo);
extern Datum percentile_cont_interval_final(FunctionCallInfo fcinfo);
extern Datum percentile_disc_multi_final(FunctionCallInfo fcinfo);
extern Datum percentile_cont_float8_multi_final(FunctionCallInfo fcinfo);
extern Datum percentile_cont_interval_multi_final(FunctionCallInfo fcinfo);
extern Datum mode_final(FunctionCallInfo fcinfo);
extern Datum hypothetical_rank_final(FunctionCallInfo fcinfo);
extern Datum hypothetical_percent_rank_final(FunctionCallInfo fcinfo);
extern Datum hypothetical_cume_dist_final(FunctionCallInfo fcinfo);
extern Datum hypothetical_dense_rank_final(FunctionCallInfo fcinfo);
extern Datum generate_series_int4_support(FunctionCallInfo fcinfo);
extern Datum generate_series_int8_support(FunctionCallInfo fcinfo);
extern Datum array_unnest_support(FunctionCallInfo fcinfo);
extern Datum brin_summarize_range(FunctionCallInfo fcinfo);
extern Datum jsonpath_in(FunctionCallInfo fcinfo);
extern Datum jsonpath_recv(FunctionCallInfo fcinfo);
extern Datum jsonpath_out(FunctionCallInfo fcinfo);
extern Datum jsonpath_send(FunctionCallInfo fcinfo);
extern Datum jsonb_path_exists(FunctionCallInfo fcinfo);
extern Datum jsonb_path_query(FunctionCallInfo fcinfo);
extern Datum jsonb_path_query_array(FunctionCallInfo fcinfo);
extern Datum jsonb_path_query_first(FunctionCallInfo fcinfo);
extern Datum jsonb_path_match(FunctionCallInfo fcinfo);
extern Datum jsonb_path_exists_opr(FunctionCallInfo fcinfo);
extern Datum jsonb_path_match_opr(FunctionCallInfo fcinfo);
extern Datum brin_desummarize_range(FunctionCallInfo fcinfo);
extern Datum spg_quad_config(FunctionCallInfo fcinfo);
extern Datum spg_quad_choose(FunctionCallInfo fcinfo);
extern Datum spg_quad_picksplit(FunctionCallInfo fcinfo);
extern Datum spg_quad_inner_consistent(FunctionCallInfo fcinfo);
extern Datum spg_quad_leaf_consistent(FunctionCallInfo fcinfo);
extern Datum spg_kd_config(FunctionCallInfo fcinfo);
extern Datum spg_kd_choose(FunctionCallInfo fcinfo);
extern Datum spg_kd_picksplit(FunctionCallInfo fcinfo);
extern Datum spg_kd_inner_consistent(FunctionCallInfo fcinfo);
extern Datum spg_text_config(FunctionCallInfo fcinfo);
extern Datum spg_text_choose(FunctionCallInfo fcinfo);
extern Datum spg_text_picksplit(FunctionCallInfo fcinfo);
extern Datum spg_text_inner_consistent(FunctionCallInfo fcinfo);
extern Datum spg_text_leaf_consistent(FunctionCallInfo fcinfo);
extern Datum pg_sequence_last_value(FunctionCallInfo fcinfo);
extern Datum jsonb_ne(FunctionCallInfo fcinfo);
extern Datum jsonb_lt(FunctionCallInfo fcinfo);
extern Datum jsonb_gt(FunctionCallInfo fcinfo);
extern Datum jsonb_le(FunctionCallInfo fcinfo);
extern Datum jsonb_ge(FunctionCallInfo fcinfo);
extern Datum jsonb_eq(FunctionCallInfo fcinfo);
extern Datum jsonb_cmp(FunctionCallInfo fcinfo);
extern Datum jsonb_hash(FunctionCallInfo fcinfo);
extern Datum jsonb_contains(FunctionCallInfo fcinfo);
extern Datum jsonb_exists(FunctionCallInfo fcinfo);
extern Datum jsonb_exists_any(FunctionCallInfo fcinfo);
extern Datum jsonb_exists_all(FunctionCallInfo fcinfo);
extern Datum jsonb_contained(FunctionCallInfo fcinfo);
extern Datum array_agg_array_transfn(FunctionCallInfo fcinfo);
extern Datum array_agg_array_finalfn(FunctionCallInfo fcinfo);
extern Datum range_merge(FunctionCallInfo fcinfo);
extern Datum inet_merge(FunctionCallInfo fcinfo);
extern Datum boxes_bound_box(FunctionCallInfo fcinfo);
extern Datum inet_same_family(FunctionCallInfo fcinfo);
extern Datum binary_upgrade_set_record_init_privs(FunctionCallInfo fcinfo);
extern Datum regnamespacein(FunctionCallInfo fcinfo);
extern Datum regnamespaceout(FunctionCallInfo fcinfo);
extern Datum to_regnamespace(FunctionCallInfo fcinfo);
extern Datum regnamespacerecv(FunctionCallInfo fcinfo);
extern Datum regnamespacesend(FunctionCallInfo fcinfo);
extern Datum point_box(FunctionCallInfo fcinfo);
extern Datum regroleout(FunctionCallInfo fcinfo);
extern Datum to_regrole(FunctionCallInfo fcinfo);
extern Datum regrolerecv(FunctionCallInfo fcinfo);
extern Datum regrolesend(FunctionCallInfo fcinfo);
extern Datum regrolein(FunctionCallInfo fcinfo);
extern Datum pg_rotate_logfile(FunctionCallInfo fcinfo);
extern Datum pg_read_file(FunctionCallInfo fcinfo);
extern Datum binary_upgrade_set_missing_value(FunctionCallInfo fcinfo);
extern Datum brin_inclusion_opcinfo(FunctionCallInfo fcinfo);
extern Datum brin_inclusion_add_value(FunctionCallInfo fcinfo);
extern Datum brin_inclusion_consistent(FunctionCallInfo fcinfo);
extern Datum brin_inclusion_union(FunctionCallInfo fcinfo);
extern Datum macaddr8_in(FunctionCallInfo fcinfo);
extern Datum macaddr8_out(FunctionCallInfo fcinfo);
extern Datum macaddr8_trunc(FunctionCallInfo fcinfo);
extern Datum macaddr8_eq(FunctionCallInfo fcinfo);
extern Datum macaddr8_lt(FunctionCallInfo fcinfo);
extern Datum macaddr8_le(FunctionCallInfo fcinfo);
extern Datum macaddr8_gt(FunctionCallInfo fcinfo);
extern Datum macaddr8_ge(FunctionCallInfo fcinfo);
extern Datum macaddr8_ne(FunctionCallInfo fcinfo);
extern Datum macaddr8_cmp(FunctionCallInfo fcinfo);
extern Datum macaddr8_not(FunctionCallInfo fcinfo);
extern Datum macaddr8_and(FunctionCallInfo fcinfo);
extern Datum macaddr8_or(FunctionCallInfo fcinfo);
extern Datum macaddrtomacaddr8(FunctionCallInfo fcinfo);
extern Datum macaddr8tomacaddr(FunctionCallInfo fcinfo);
extern Datum macaddr8_set7bit(FunctionCallInfo fcinfo);
extern Datum in_range_int8_int8(FunctionCallInfo fcinfo);
extern Datum in_range_int4_int8(FunctionCallInfo fcinfo);
extern Datum in_range_int4_int4(FunctionCallInfo fcinfo);
extern Datum in_range_int4_int2(FunctionCallInfo fcinfo);
extern Datum in_range_int2_int8(FunctionCallInfo fcinfo);
extern Datum in_range_int2_int4(FunctionCallInfo fcinfo);
extern Datum in_range_int2_int2(FunctionCallInfo fcinfo);
extern Datum in_range_date_interval(FunctionCallInfo fcinfo);
extern Datum in_range_timestamp_interval(FunctionCallInfo fcinfo);
extern Datum in_range_timestamptz_interval(FunctionCallInfo fcinfo);
extern Datum in_range_interval_interval(FunctionCallInfo fcinfo);
extern Datum in_range_time_interval(FunctionCallInfo fcinfo);
extern Datum in_range_timetz_interval(FunctionCallInfo fcinfo);
extern Datum in_range_float8_float8(FunctionCallInfo fcinfo);
extern Datum in_range_float4_float8(FunctionCallInfo fcinfo);
extern Datum in_range_numeric_numeric(FunctionCallInfo fcinfo);
extern Datum ts_headline_jsonb_byid_opt(FunctionCallInfo fcinfo);
extern Datum ts_headline_jsonb_byid(FunctionCallInfo fcinfo);
extern Datum ts_headline_jsonb_opt(FunctionCallInfo fcinfo);
extern Datum ts_headline_jsonb(FunctionCallInfo fcinfo);
extern Datum ts_headline_json_byid_opt(FunctionCallInfo fcinfo);
extern Datum ts_headline_json_byid(FunctionCallInfo fcinfo);
extern Datum ts_headline_json_opt(FunctionCallInfo fcinfo);
extern Datum ts_headline_json(FunctionCallInfo fcinfo);
extern Datum jsonb_string_to_tsvector(FunctionCallInfo fcinfo);
extern Datum json_string_to_tsvector(FunctionCallInfo fcinfo);
extern Datum jsonb_string_to_tsvector_byid(FunctionCallInfo fcinfo);
extern Datum json_string_to_tsvector_byid(FunctionCallInfo fcinfo);
extern Datum jsonb_to_tsvector(FunctionCallInfo fcinfo);
extern Datum jsonb_to_tsvector_byid(FunctionCallInfo fcinfo);
extern Datum json_to_tsvector(FunctionCallInfo fcinfo);
extern Datum json_to_tsvector_byid(FunctionCallInfo fcinfo);
extern Datum pg_copy_physical_replication_slot_a(FunctionCallInfo fcinfo);
extern Datum pg_copy_physical_replication_slot_b(FunctionCallInfo fcinfo);
extern Datum pg_copy_logical_replication_slot_a(FunctionCallInfo fcinfo);
extern Datum pg_copy_logical_replication_slot_b(FunctionCallInfo fcinfo);
extern Datum pg_copy_logical_replication_slot_c(FunctionCallInfo fcinfo);
extern Datum pg_event_trigger_table_rewrite_oid(FunctionCallInfo fcinfo);
extern Datum pg_event_trigger_table_rewrite_reason(FunctionCallInfo fcinfo);
extern Datum pg_event_trigger_ddl_commands(FunctionCallInfo fcinfo);
extern Datum phraseto_tsquery(FunctionCallInfo fcinfo);
extern Datum tsquery_phrase(FunctionCallInfo fcinfo);
extern Datum tsquery_phrase_distance(FunctionCallInfo fcinfo);
extern Datum phraseto_tsquery_byid(FunctionCallInfo fcinfo);
extern Datum websearch_to_tsquery_byid(FunctionCallInfo fcinfo);
extern Datum websearch_to_tsquery(FunctionCallInfo fcinfo);
extern Datum spg_bbox_quad_config(FunctionCallInfo fcinfo);
extern Datum spg_poly_quad_compress(FunctionCallInfo fcinfo);
extern Datum spg_box_quad_config(FunctionCallInfo fcinfo);
extern Datum spg_box_quad_choose(FunctionCallInfo fcinfo);
extern Datum spg_box_quad_picksplit(FunctionCallInfo fcinfo);
extern Datum spg_box_quad_inner_consistent(FunctionCallInfo fcinfo);
extern Datum spg_box_quad_leaf_consistent(FunctionCallInfo fcinfo);
extern Datum pg_mcv_list_in(FunctionCallInfo fcinfo);
extern Datum pg_mcv_list_out(FunctionCallInfo fcinfo);
extern Datum pg_mcv_list_recv(FunctionCallInfo fcinfo);
extern Datum pg_mcv_list_send(FunctionCallInfo fcinfo);
extern Datum satisfies_hash_partition(FunctionCallInfo fcinfo);
extern Datum pg_ls_tmpdir_noargs(FunctionCallInfo fcinfo);
extern Datum pg_ls_tmpdir_1arg(FunctionCallInfo fcinfo);
extern Datum pg_ls_archive_statusdir(FunctionCallInfo fcinfo);
extern Datum pg_replication_origin_create(FunctionCallInfo fcinfo);
extern Datum pg_replication_origin_drop(FunctionCallInfo fcinfo);
extern Datum pg_replication_origin_oid(FunctionCallInfo fcinfo);
extern Datum pg_replication_origin_session_setup(FunctionCallInfo fcinfo);
extern Datum pg_replication_origin_session_reset(FunctionCallInfo fcinfo);
extern Datum pg_replication_origin_session_is_setup(FunctionCallInfo fcinfo);
extern Datum pg_replication_origin_session_progress(FunctionCallInfo fcinfo);
extern Datum pg_replication_origin_xact_setup(FunctionCallInfo fcinfo);
extern Datum pg_replication_origin_xact_reset(FunctionCallInfo fcinfo);
extern Datum pg_replication_origin_advance(FunctionCallInfo fcinfo);
extern Datum pg_replication_origin_progress(FunctionCallInfo fcinfo);
extern Datum pg_show_replication_origin_status(FunctionCallInfo fcinfo);
extern Datum pg_stat_get_subscription(FunctionCallInfo fcinfo);
extern Datum pg_get_publication_tables(FunctionCallInfo fcinfo);
extern Datum pg_get_replica_identity_index(FunctionCallInfo fcinfo);
extern Datum pg_relation_is_publishable(FunctionCallInfo fcinfo);
# 20 "/products1/postgres/PG12.1/include/server/utils/builtins.h" 2



extern _Bool parse_bool(const char *value, _Bool *result);
extern _Bool parse_bool_with_len(const char *value, size_t len, _Bool *result);


extern void domain_check(Datum value, _Bool isnull, Oid domainType,
       void **extra, MemoryContext mcxt);
extern int errdatatype(Oid datatypeOid);
extern int errdomainconstraint(Oid datatypeOid, const char *conname);


extern unsigned hex_encode(const char *src, unsigned len, char *dst);
extern unsigned hex_decode(const char *src, unsigned len, char *dst);


extern int2vector *buildint2vector(const int16 *int2s, int n);


extern int namecpy(Name n1, const NameData *n2);
extern int namestrcpy(Name name, const char *str);
extern int namestrcmp(Name name, const char *str);


extern int32 pg_atoi(const char *s, int size, int c);
extern int16 pg_strtoint16(const char *s);
extern int32 pg_strtoint32(const char *s);
extern void pg_itoa(int16 i, char *a);
extern void pg_ltoa(int32 l, char *a);
extern void pg_lltoa(int64 ll, char *a);
extern char *pg_ltostr_zeropad(char *str, int32 value, int32 minwidth);
extern char *pg_ltostr(char *str, int32 value);
extern uint64 pg_strtouint64(const char *str, char **endptr, int base);


extern oidvector *buildoidvector(const Oid *oids, int n);
extern Oid oidparse(Node *node);
extern int oid_cmp(const void *p1, const void *p2);


extern char *regexp_fixed_prefix(text *text_re, _Bool case_insensitive,
         Oid collation, _Bool *exact);


extern _Bool quote_all_identifiers;
extern const char *quote_identifier(const char *ident);
extern char *quote_qualified_identifier(const char *qualifier,
          const char *ident);
extern void generate_operator_clause(fmStringInfo buf,
          const char *leftop, Oid leftoptype,
          Oid opoid,
          const char *rightop, Oid rightoptype);


extern int bpchartruelen(char *s, int len);


extern text *cstring_to_text(const char *s);
extern text *cstring_to_text_with_len(const char *s, int len);
extern char *text_to_cstring(const text *t);
extern void text_to_cstring_buffer(const text *src, char *dst, size_t dst_len);





extern int xidComparator(const void *arg1, const void *arg2);


extern char *inet_cidr_ntop(int af, const void *src, int bits,
       char *dst, size_t size);


extern int inet_net_pton(int af, const char *src,
        void *dst, size_t size);


extern double convert_network_to_scalar(Datum value, Oid typid, _Bool *failure);
extern Datum network_scan_first(Datum in);
extern Datum network_scan_last(Datum in);
extern void clean_ipv6_addr(int addr_family, char *addr);


extern Datum numeric_float8_no_overflow(FunctionCallInfo fcinfo);







extern char *format_type_extended(Oid type_oid, int32 typemod, bits16 flags);

extern char *format_type_be(Oid type_oid);
extern char *format_type_be_qualified(Oid type_oid);
extern char *format_type_with_typemod(Oid type_oid, int32 typemod);

extern int32 type_maximum_size(Oid type_oid, int32 typemod);


extern char *quote_literal_cstr(const char *rawstr);
# 59 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/catcache.h" 1
# 39 "/products1/postgres/PG12.1/include/server/utils/catcache.h"
typedef uint32 (*CCHashFN) (Datum datum);


typedef _Bool (*CCFastEqualFN) (Datum a, Datum b);

typedef struct catcache
{
 int id;
 int cc_nbuckets;
 TupleDesc cc_tupdesc;
 dlist_head *cc_bucket;
 CCHashFN cc_hashfunc[4];
 CCFastEqualFN cc_fastequal[4];

 int cc_keyno[4];
 dlist_head cc_lists;
 int cc_ntup;
 int cc_nkeys;
 const char *cc_relname;
 Oid cc_reloid;
 Oid cc_indexoid;
 _Bool cc_relisshared;
 slist_node cc_next;
 ScanKeyData cc_skey[4];
# 83 "/products1/postgres/PG12.1/include/server/utils/catcache.h"
} CatCache;


typedef struct catctup
{
 int ct_magic;


 uint32 hash_value;





 Datum keys[4];






 dlist_node cache_elem;
# 118 "/products1/postgres/PG12.1/include/server/utils/catcache.h"
 int refcount;
 _Bool dead;
 _Bool negative;
 HeapTupleData tuple;
# 130 "/products1/postgres/PG12.1/include/server/utils/catcache.h"
 struct catclist *c_list;

 CatCache *my_cache;

} CatCTup;
# 157 "/products1/postgres/PG12.1/include/server/utils/catcache.h"
typedef struct catclist
{
 int cl_magic;


 uint32 hash_value;

 dlist_node cache_elem;





 Datum keys[4];

 int refcount;
 _Bool dead;
 _Bool ordered;
 short nkeys;
 int n_members;
 CatCache *my_cache;
 CatCTup *members[];
} CatCList;


typedef struct catcacheheader
{
 slist_head ch_caches;
 int ch_ntup;
} CatCacheHeader;



extern MemoryContext CacheMemoryContext;

extern void CreateCacheMemoryContext(void);

extern CatCache *InitCatCache(int id, Oid reloid, Oid indexoid,
         int nkeys, const int *key,
         int nbuckets);
extern void InitCatCachePhase2(CatCache *cache, _Bool touch_index);

extern HeapTuple SearchCatCache(CatCache *cache,
        Datum v1, Datum v2, Datum v3, Datum v4);
extern HeapTuple SearchCatCache1(CatCache *cache,
         Datum v1);
extern HeapTuple SearchCatCache2(CatCache *cache,
         Datum v1, Datum v2);
extern HeapTuple SearchCatCache3(CatCache *cache,
         Datum v1, Datum v2, Datum v3);
extern HeapTuple SearchCatCache4(CatCache *cache,
         Datum v1, Datum v2, Datum v3, Datum v4);
extern void ReleaseCatCache(HeapTuple tuple);

extern uint32 GetCatCacheHashValue(CatCache *cache,
           Datum v1, Datum v2,
           Datum v3, Datum v4);

extern CatCList *SearchCatCacheList(CatCache *cache, int nkeys,
         Datum v1, Datum v2,
         Datum v3);
extern void ReleaseCatCacheList(CatCList *list);

extern void ResetCatalogCaches(void);
extern void CatalogCacheFlushCatalog(Oid catId);
extern void CatCacheInvalidate(CatCache *cache, uint32 hashValue);
extern void PrepareToInvalidateCacheTuple(Relation relation,
            HeapTuple tuple,
            HeapTuple newtuple,
            void (*function) (int, uint32, Oid));

extern void PrintCatCacheLeakWarning(HeapTuple tuple);
extern void PrintCatCacheListLeakWarning(CatCList *list);
# 60 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/date.h" 1
# 17 "/products1/postgres/PG12.1/include/server/utils/date.h"
# 1 "/usr/include/math.h" 1 3 4
# 29 "/usr/include/math.h" 3 4




# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 34 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 40 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 43 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 28 "/usr/include/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
# 47 "/usr/include/math.h" 2 3 4
# 70 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double cos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tan (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double cosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tanh (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern void sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                           ;





extern double acosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atanh (double __x) __attribute__ ((__nothrow__ , __leaf__));







extern double exp (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double log (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log10 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double pow10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow10 (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log1p (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log1p (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double logb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __logb (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log2 (double __x) __attribute__ ((__nothrow__ , __leaf__));








extern double pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));






extern double cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__));








extern double ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double significand (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __significand (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern double nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double j0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double j1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double jn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __jn (int, double) __attribute__ ((__nothrow__ , __leaf__));
extern double y0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double y1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double yn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __yn (int, double) __attribute__ ((__nothrow__ , __leaf__));






extern double erf (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erf (double) __attribute__ ((__nothrow__ , __leaf__));
extern double erfc (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erfc (double) __attribute__ ((__nothrow__ , __leaf__));
extern double lgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma (double) __attribute__ ((__nothrow__ , __leaf__));






extern double tgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __tgamma (double) __attribute__ ((__nothrow__ , __leaf__));





extern double gamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __gamma (double) __attribute__ ((__nothrow__ , __leaf__));






extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern double rint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __rint (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern double nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lround (double __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassify (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));








extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__));
# 71 "/usr/include/math.h" 2 3 4
# 89 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float cosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float coshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __coshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern void sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                           ;





extern float acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));







extern float expf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float logf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log10f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float pow10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __pow10f (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float logbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logbf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log2f (float __x) __attribute__ ((__nothrow__ , __leaf__));








extern float powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));






extern float cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));








extern float ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float significandf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __significandf (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float j0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float j1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float jnf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __jnf (int, float) __attribute__ ((__nothrow__ , __leaf__));
extern float y0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float y1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float ynf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __ynf (int, float) __attribute__ ((__nothrow__ , __leaf__));






extern float erff (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erff (float) __attribute__ ((__nothrow__ , __leaf__));
extern float erfcf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erfcf (float) __attribute__ ((__nothrow__ , __leaf__));
extern float lgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf (float) __attribute__ ((__nothrow__ , __leaf__));






extern float tgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __tgammaf (float) __attribute__ ((__nothrow__ , __leaf__));





extern float gammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __gammaf (float) __attribute__ ((__nothrow__ , __leaf__));






extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern float rintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __rintf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__));








extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__));
# 90 "/usr/include/math.h" 2 3 4
# 133 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                           ;





extern long double acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));







extern long double expl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double logl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double pow10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __pow10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));








extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));






extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));








extern long double ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double j0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double j1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double erfl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double erfcl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double lgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double tgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double gammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __gammal (long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern long double rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));








extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__));
# 134 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
extern int signgam;
# 190 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 288 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 313 "/usr/include/math.h" 3 4
struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);
# 413 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathinline.h" 1 3 4
# 123 "/usr/include/bits/mathinline.h" 3 4



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) __signbitf (float __x)
{

  int __m;
  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
  return (__m & 0x8) != 0;




}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) __signbit (double __x)
{

  int __m;
  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
  return (__m & 0x80) != 0;




}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) __signbitl (long double __x)
{
  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
  return (__u.__i[2] & 0x8000) != 0;
}


# 414 "/usr/include/math.h" 2 3 4
# 475 "/usr/include/math.h" 3 4

# 18 "/products1/postgres/PG12.1/include/server/utils/date.h" 2





typedef int32 DateADT;

typedef int64 TimeADT;

typedef struct
{
 TimeADT time;
 int32 zone;
} TimeTzADT;
# 71 "/products1/postgres/PG12.1/include/server/utils/date.h"
extern int32 anytime_typmod_check(_Bool istz, int32 typmod);
extern double date2timestamp_no_overflow(DateADT dateVal);
extern void EncodeSpecialDate(DateADT dt, char *str);
extern DateADT GetSQLCurrentDate(void);
extern TimeTzADT *GetSQLCurrentTime(int32 typmod);
extern TimeADT GetSQLLocalTime(int32 typmod);
extern int time2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec);
extern int timetz2tm(TimeTzADT *time, struct pg_tm *tm, fsec_t *fsec, int *tzp);
# 61 "db2_fdw.c" 2

# 1 "/products1/postgres/PG12.1/include/server/utils/elog.h" 1
# 63 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/fmgroids.h" 1
# 64 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/formatting.h" 1
# 23 "/products1/postgres/PG12.1/include/server/utils/formatting.h"
extern char *str_tolower(const char *buff, size_t nbytes, Oid collid);
extern char *str_toupper(const char *buff, size_t nbytes, Oid collid);
extern char *str_initcap(const char *buff, size_t nbytes, Oid collid);

extern char *asc_tolower(const char *buff, size_t nbytes);
extern char *asc_toupper(const char *buff, size_t nbytes);
extern char *asc_initcap(const char *buff, size_t nbytes);
# 65 "db2_fdw.c" 2

# 1 "/products1/postgres/PG12.1/include/server/utils/lsyscache.h" 1
# 21 "/products1/postgres/PG12.1/include/server/utils/lsyscache.h"
typedef struct OpBtreeInterpretation
{
 Oid opfamily_id;
 int strategy;
 Oid oplefttype;
 Oid oprighttype;
} OpBtreeInterpretation;


typedef enum IOFuncSelector
{
 IOFunc_input,
 IOFunc_output,
 IOFunc_receive,
 IOFunc_send
} IOFuncSelector;






typedef struct AttStatsSlot
{

 Oid staop;
 Oid stacoll;

 Oid valuetype;
 Datum *values;
 int nvalues;

 float4 *numbers;
 int nnumbers;


 void *values_arr;
 void *numbers_arr;
} AttStatsSlot;


typedef int32 (*get_attavgwidth_hook_type) (Oid relid, AttrNumber attnum);
extern get_attavgwidth_hook_type get_attavgwidth_hook;

extern _Bool op_in_opfamily(Oid opno, Oid opfamily);
extern int get_op_opfamily_strategy(Oid opno, Oid opfamily);
extern Oid get_op_opfamily_sortfamily(Oid opno, Oid opfamily);
extern void get_op_opfamily_properties(Oid opno, Oid opfamily, _Bool ordering_op,
            int *strategy,
            Oid *lefttype,
            Oid *righttype);
extern Oid get_opfamily_member(Oid opfamily, Oid lefttype, Oid righttype,
        int16 strategy);
extern _Bool get_ordering_op_properties(Oid opno,
            Oid *opfamily, Oid *opcintype, int16 *strategy);
extern Oid get_equality_op_for_ordering_op(Oid opno, _Bool *reverse);
extern Oid get_ordering_op_for_equality_op(Oid opno, _Bool use_lhs_type);
extern List *get_mergejoin_opfamilies(Oid opno);
extern _Bool get_compatible_hash_operators(Oid opno,
            Oid *lhs_opno, Oid *rhs_opno);
extern _Bool get_op_hash_functions(Oid opno,
          RegProcedure *lhs_procno, RegProcedure *rhs_procno);
extern List *get_op_btree_interpretation(Oid opno);
extern _Bool equality_ops_are_compatible(Oid opno1, Oid opno2);
extern Oid get_opfamily_proc(Oid opfamily, Oid lefttype, Oid righttype,
         int16 procnum);
extern char *get_attname(Oid relid, AttrNumber attnum, _Bool missing_ok);
extern AttrNumber get_attnum(Oid relid, const char *attname);
extern char get_attgenerated(Oid relid, AttrNumber attnum);
extern Oid get_atttype(Oid relid, AttrNumber attnum);
extern void get_atttypetypmodcoll(Oid relid, AttrNumber attnum,
          Oid *typid, int32 *typmod, Oid *collid);
extern char *get_collation_name(Oid colloid);
extern _Bool get_collation_isdeterministic(Oid colloid);
extern char *get_constraint_name(Oid conoid);
extern char *get_language_name(Oid langoid, _Bool missing_ok);
extern Oid get_opclass_family(Oid opclass);
extern Oid get_opclass_input_type(Oid opclass);
extern _Bool get_opclass_opfamily_and_input_type(Oid opclass,
            Oid *opfamily, Oid *opcintype);
extern RegProcedure get_opcode(Oid opno);
extern char *get_opname(Oid opno);
extern Oid get_op_rettype(Oid opno);
extern void op_input_types(Oid opno, Oid *lefttype, Oid *righttype);
extern _Bool op_mergejoinable(Oid opno, Oid inputtype);
extern _Bool op_hashjoinable(Oid opno, Oid inputtype);
extern _Bool op_strict(Oid opno);
extern char op_volatile(Oid opno);
extern Oid get_commutator(Oid opno);
extern Oid get_negator(Oid opno);
extern RegProcedure get_oprrest(Oid opno);
extern RegProcedure get_oprjoin(Oid opno);
extern char *get_func_name(Oid funcid);
extern Oid get_func_namespace(Oid funcid);
extern Oid get_func_rettype(Oid funcid);
extern int get_func_nargs(Oid funcid);
extern Oid get_func_signature(Oid funcid, Oid **argtypes, int *nargs);
extern Oid get_func_variadictype(Oid funcid);
extern _Bool get_func_retset(Oid funcid);
extern _Bool func_strict(Oid funcid);
extern char func_volatile(Oid funcid);
extern char func_parallel(Oid funcid);
extern char get_func_prokind(Oid funcid);
extern _Bool get_func_leakproof(Oid funcid);
extern RegProcedure get_func_support(Oid funcid);
extern Oid get_relname_relid(const char *relname, Oid relnamespace);
extern char *get_rel_name(Oid relid);
extern Oid get_rel_namespace(Oid relid);
extern Oid get_rel_type_id(Oid relid);
extern char get_rel_relkind(Oid relid);
extern _Bool get_rel_relispartition(Oid relid);
extern Oid get_rel_tablespace(Oid relid);
extern char get_rel_persistence(Oid relid);
extern Oid get_transform_fromsql(Oid typid, Oid langid, List *trftypes);
extern Oid get_transform_tosql(Oid typid, Oid langid, List *trftypes);
extern _Bool get_typisdefined(Oid typid);
extern int16 get_typlen(Oid typid);
extern _Bool get_typbyval(Oid typid);
extern void get_typlenbyval(Oid typid, int16 *typlen, _Bool *typbyval);
extern void get_typlenbyvalalign(Oid typid, int16 *typlen, _Bool *typbyval,
         char *typalign);
extern Oid getTypeIOParam(HeapTuple typeTuple);
extern void get_type_io_data(Oid typid,
        IOFuncSelector which_func,
        int16 *typlen,
        _Bool *typbyval,
        char *typalign,
        char *typdelim,
        Oid *typioparam,
        Oid *func);
extern char get_typstorage(Oid typid);
extern Node *get_typdefault(Oid typid);
extern char get_typtype(Oid typid);
extern _Bool type_is_rowtype(Oid typid);
extern _Bool type_is_enum(Oid typid);
extern _Bool type_is_range(Oid typid);
extern void get_type_category_preferred(Oid typid,
          char *typcategory,
          _Bool *typispreferred);
extern Oid get_typ_typrelid(Oid typid);
extern Oid get_element_type(Oid typid);
extern Oid get_array_type(Oid typid);
extern Oid get_promoted_array_type(Oid typid);
extern Oid get_base_element_type(Oid typid);
extern void getTypeInputInfo(Oid type, Oid *typInput, Oid *typIOParam);
extern void getTypeOutputInfo(Oid type, Oid *typOutput, _Bool *typIsVarlena);
extern void getTypeBinaryInputInfo(Oid type, Oid *typReceive, Oid *typIOParam);
extern void getTypeBinaryOutputInfo(Oid type, Oid *typSend, _Bool *typIsVarlena);
extern Oid get_typmodin(Oid typid);
extern Oid get_typcollation(Oid typid);
extern _Bool type_is_collatable(Oid typid);
extern Oid getBaseType(Oid typid);
extern Oid getBaseTypeAndTypmod(Oid typid, int32 *typmod);
extern int32 get_typavgwidth(Oid typid, int32 typmod);
extern int32 get_attavgwidth(Oid relid, AttrNumber attnum);
extern _Bool get_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,
        int reqkind, Oid reqop, int flags);
extern void free_attstatsslot(AttStatsSlot *sslot);
extern char *get_namespace_name(Oid nspid);
extern char *get_namespace_name_or_temp(Oid nspid);
extern Oid get_range_subtype(Oid rangeOid);
extern Oid get_index_column_opclass(Oid index_oid, int attno);
# 67 "db2_fdw.c" 2

# 1 "/products1/postgres/PG12.1/include/server/utils/rel.h" 1
# 18 "/products1/postgres/PG12.1/include/server/utils/rel.h"
# 1 "/products1/postgres/PG12.1/include/server/access/xlog.h" 1
# 16 "/products1/postgres/PG12.1/include/server/access/xlog.h"
# 1 "/products1/postgres/PG12.1/include/server/access/xloginsert.h" 1
# 42 "/products1/postgres/PG12.1/include/server/access/xloginsert.h"
extern void XLogBeginInsert(void);
extern void XLogSetRecordFlags(uint8 flags);
extern XLogRecPtr XLogInsert(RmgrId rmid, uint8 info);
extern void XLogEnsureRecordSpace(int nbuffers, int ndatas);
extern void XLogRegisterData(char *data, int len);
extern void XLogRegisterBuffer(uint8 block_id, Buffer buffer, uint8 flags);
extern void XLogRegisterBlock(uint8 block_id, RelFileNode *rnode,
         ForkNumber forknum, BlockNumber blknum, char *page,
         uint8 flags);
extern void XLogRegisterBufData(uint8 block_id, char *data, int len);
extern void XLogResetInsertion(void);
extern _Bool XLogCheckBufferNeedsBackup(Buffer buffer);

extern XLogRecPtr log_newpage(RelFileNode *rnode, ForkNumber forkNum,
         BlockNumber blk, char *page, _Bool page_std);
extern XLogRecPtr log_newpage_buffer(Buffer buffer, _Bool page_std);
extern void log_newpage_range(Relation rel, ForkNumber forkNum,
         BlockNumber startblk, BlockNumber endblk, _Bool page_std);
extern XLogRecPtr XLogSaveBufferForHint(Buffer buffer, _Bool buffer_std);

extern void InitXLogInsert(void);
# 17 "/products1/postgres/PG12.1/include/server/access/xlog.h" 2
# 30 "/products1/postgres/PG12.1/include/server/access/xlog.h"
extern int sync_method;

extern TimeLineID ThisTimeLineID;
# 41 "/products1/postgres/PG12.1/include/server/access/xlog.h"
extern _Bool InRecovery;
# 64 "/products1/postgres/PG12.1/include/server/access/xlog.h"
typedef enum
{
 STANDBY_DISABLED,
 STANDBY_INITIALIZED,
 STANDBY_SNAPSHOT_PENDING,
 STANDBY_SNAPSHOT_READY
} HotStandbyState;

extern HotStandbyState standbyState;







typedef enum
{
 RECOVERY_TARGET_UNSET,
 RECOVERY_TARGET_XID,
 RECOVERY_TARGET_TIME,
 RECOVERY_TARGET_NAME,
 RECOVERY_TARGET_LSN,
 RECOVERY_TARGET_IMMEDIATE
} RecoveryTargetType;




typedef enum
{
 RECOVERY_TARGET_TIMELINE_CONTROLFILE,
 RECOVERY_TARGET_TIMELINE_LATEST,
 RECOVERY_TARGET_TIMELINE_NUMERIC
} RecoveryTargetTimeLineGoal;

extern XLogRecPtr ProcLastRecPtr;
extern XLogRecPtr XactLastRecEnd;
extern XLogRecPtr XactLastCommitEnd;

extern _Bool reachedConsistency;


extern int wal_segment_size;
extern int min_wal_size_mb;
extern int max_wal_size_mb;
extern int wal_keep_segments;
extern int XLOGbuffers;
extern int XLogArchiveTimeout;
extern int wal_retrieve_retry_interval;
extern char *XLogArchiveCommand;
extern _Bool EnableHotStandby;
extern _Bool fullPageWrites;
extern _Bool wal_log_hints;
extern _Bool wal_compression;
extern _Bool wal_init_zero;
extern _Bool wal_recycle;
extern _Bool *wal_consistency_checking;
extern char *wal_consistency_checking_string;
extern _Bool log_checkpoints;
extern char *recoveryRestoreCommand;
extern char *recoveryEndCommand;
extern char *archiveCleanupCommand;
extern _Bool recoveryTargetInclusive;
extern int recoveryTargetAction;
extern int recovery_min_apply_delay;
extern char *PrimaryConnInfo;
extern char *PrimarySlotName;


extern TransactionId recoveryTargetXid;
extern char *recovery_target_time_string;
extern const char *recoveryTargetName;
extern XLogRecPtr recoveryTargetLSN;
extern RecoveryTargetType recoveryTarget;
extern char *PromoteTriggerFile;
extern RecoveryTargetTimeLineGoal recoveryTargetTimeLineGoal;
extern TimeLineID recoveryTargetTLIRequested;
extern TimeLineID recoveryTargetTLI;

extern int CheckPointSegments;


extern _Bool StandbyModeRequested;
extern _Bool StandbyMode;


typedef enum ArchiveMode
{
 ARCHIVE_MODE_OFF = 0,
 ARCHIVE_MODE_ON,
 ARCHIVE_MODE_ALWAYS
} ArchiveMode;
extern int XLogArchiveMode;


typedef enum WalLevel
{
 WAL_LEVEL_MINIMAL = 0,
 WAL_LEVEL_REPLICA,
 WAL_LEVEL_LOGICAL
} WalLevel;

extern int wal_level;
# 233 "/products1/postgres/PG12.1/include/server/access/xlog.h"
typedef struct CheckpointStatsData
{
 TimestampTz ckpt_start_t;
 TimestampTz ckpt_write_t;
 TimestampTz ckpt_sync_t;
 TimestampTz ckpt_sync_end_t;
 TimestampTz ckpt_end_t;

 int ckpt_bufs_written;

 int ckpt_segs_added;
 int ckpt_segs_removed;
 int ckpt_segs_recycled;

 int ckpt_sync_rels;
 uint64 ckpt_longest_sync;
 uint64 ckpt_agg_sync_time;



} CheckpointStatsData;

extern CheckpointStatsData CheckpointStats;

struct XLogRecData;

extern XLogRecPtr XLogInsertRecord(struct XLogRecData *rdata,
           XLogRecPtr fpw_lsn,
           uint8 flags);
extern void XLogFlush(XLogRecPtr RecPtr);
extern _Bool XLogBackgroundFlush(void);
extern _Bool XLogNeedsFlush(XLogRecPtr RecPtr);
extern int XLogFileInit(XLogSegNo segno, _Bool *use_existent, _Bool use_lock);
extern int XLogFileOpen(XLogSegNo segno);

extern void CheckXLogRemoved(XLogSegNo segno, TimeLineID tli);
extern XLogSegNo XLogGetLastRemovedSegno(void);
extern void XLogSetAsyncXactLSN(XLogRecPtr record);
extern void XLogSetReplicationSlotMinimumLSN(XLogRecPtr lsn);

extern void xlog_redo(XLogReaderState *record);
extern void xlog_desc(StringInfo buf, XLogReaderState *record);
extern const char *xlog_identify(uint8 info);

extern void issue_xlog_fsync(int fd, XLogSegNo segno);

extern _Bool RecoveryInProgress(void);
extern _Bool HotStandbyActive(void);
extern _Bool HotStandbyActiveInReplay(void);
extern _Bool XLogInsertAllowed(void);
extern void GetXLogReceiptTime(TimestampTz *rtime, _Bool *fromStream);
extern XLogRecPtr GetXLogReplayRecPtr(TimeLineID *replayTLI);
extern XLogRecPtr GetXLogInsertRecPtr(void);
extern XLogRecPtr GetXLogWriteRecPtr(void);
extern _Bool RecoveryIsPaused(void);
extern void SetRecoveryPause(_Bool recoveryPause);
extern TimestampTz GetLatestXTime(void);
extern TimestampTz GetCurrentChunkReplayStartTime(void);
extern char *XLogFileNameP(TimeLineID tli, XLogSegNo segno);

extern void UpdateControlFile(void);
extern uint64 GetSystemIdentifier(void);
extern char *GetMockAuthenticationNonce(void);
extern _Bool DataChecksumsEnabled(void);
extern XLogRecPtr GetFakeLSNForUnloggedRel(void);
extern Size XLOGShmemSize(void);
extern void XLOGShmemInit(void);
extern void BootStrapXLOG(void);
extern void LocalProcessControlFile(_Bool reset);
extern void StartupXLOG(void);
extern void ShutdownXLOG(int code, Datum arg);
extern void InitXLOGAccess(void);
extern void CreateCheckPoint(int flags);
extern _Bool CreateRestartPoint(int flags);
extern void XLogPutNextOid(Oid nextOid);
extern XLogRecPtr XLogRestorePoint(const char *rpName);
extern void UpdateFullPageWrites(void);
extern void GetFullPageWriteInfo(XLogRecPtr *RedoRecPtr_p, _Bool *doPageWrites_p);
extern XLogRecPtr GetRedoRecPtr(void);
extern XLogRecPtr GetInsertRecPtr(void);
extern XLogRecPtr GetFlushRecPtr(void);
extern XLogRecPtr GetLastImportantRecPtr(void);
extern void RemovePromoteSignalFiles(void);

extern _Bool CheckPromoteSignal(void);
extern void WakeupRecovery(void);
extern void SetWalWriterSleeping(_Bool sleeping);

extern void XLogRequestWalReceiverReply(void);

extern void assign_max_wal_size(int newval, void *extra);
extern void assign_checkpoint_completion_target(double newval, void *extra);
# 340 "/products1/postgres/PG12.1/include/server/access/xlog.h"
typedef enum SessionBackupState
{
 SESSION_BACKUP_NONE,
 SESSION_BACKUP_EXCLUSIVE,
 SESSION_BACKUP_NON_EXCLUSIVE
} SessionBackupState;

extern XLogRecPtr do_pg_start_backup(const char *backupidstr, _Bool fast,
          TimeLineID *starttli_p, StringInfo labelfile,
          List **tablespaces, StringInfo tblspcmapfile, _Bool infotbssize,
          _Bool needtblspcmapfile);
extern XLogRecPtr do_pg_stop_backup(char *labelfile, _Bool waitforarchive,
         TimeLineID *stoptli_p);
extern void do_pg_abort_backup(void);
extern SessionBackupState get_backup_status(void);
# 19 "/products1/postgres/PG12.1/include/server/utils/rel.h" 2

# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_index.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_index.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_index_d.h" 1
# 23 "/products1/postgres/PG12.1/include/server/catalog/pg_index.h" 2






typedef struct FormData_pg_index
{
 Oid indexrelid;
 Oid indrelid;
 int16 indnatts;
 int16 indnkeyatts;
 _Bool indisunique;
 _Bool indisprimary;
 _Bool indisexclusion;
 _Bool indimmediate;
 _Bool indisclustered;
 _Bool indisvalid;
 _Bool indcheckxmin;
 _Bool indisready;
 _Bool indislive;
 _Bool indisreplident;


 int2vector indkey;
# 59 "/products1/postgres/PG12.1/include/server/catalog/pg_index.h"
} FormData_pg_index;






typedef FormData_pg_index *Form_pg_index;
# 21 "/products1/postgres/PG12.1/include/server/utils/rel.h" 2
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_publication.h" 1
# 21 "/products1/postgres/PG12.1/include/server/catalog/pg_publication.h"
# 1 "/products1/postgres/PG12.1/include/server/catalog/pg_publication_d.h" 1
# 22 "/products1/postgres/PG12.1/include/server/catalog/pg_publication.h" 2
# 30 "/products1/postgres/PG12.1/include/server/catalog/pg_publication.h"
typedef struct FormData_pg_publication
{
 Oid oid;

 NameData pubname;

 Oid pubowner;





 _Bool puballtables;


 _Bool pubinsert;


 _Bool pubupdate;


 _Bool pubdelete;


 _Bool pubtruncate;

} FormData_pg_publication;






typedef FormData_pg_publication *Form_pg_publication;

typedef struct PublicationActions
{
 _Bool pubinsert;
 _Bool pubupdate;
 _Bool pubdelete;
 _Bool pubtruncate;
} PublicationActions;

typedef struct Publication
{
 Oid oid;
 char *name;
 _Bool alltables;
 PublicationActions pubactions;
} Publication;

extern Publication *GetPublication(Oid pubid);
extern Publication *GetPublicationByName(const char *pubname, _Bool missing_ok);
extern List *GetRelationPublications(Oid relid);
extern List *GetPublicationRelations(Oid pubid);
extern List *GetAllTablesPublications(void);
extern List *GetAllTablesPublicationRelations(void);

extern _Bool is_publishable_relation(Relation rel);
extern ObjectAddress publication_add_relation(Oid pubid, Relation targetrel,
             _Bool if_not_exists);

extern Oid get_publication_oid(const char *pubname, _Bool missing_ok);
extern char *get_publication_name(Oid pubid, _Bool missing_ok);

extern Datum pg_get_publication_tables(FunctionCallInfo fcinfo);
# 22 "/products1/postgres/PG12.1/include/server/utils/rel.h" 2


# 1 "/products1/postgres/PG12.1/include/server/rewrite/prs2lock.h" 1
# 24 "/products1/postgres/PG12.1/include/server/rewrite/prs2lock.h"
typedef struct RewriteRule
{
 Oid ruleId;
 CmdType event;
 Node *qual;
 List *actions;
 char enabled;
 _Bool isInstead;
} RewriteRule;







typedef struct RuleLock
{
 int numLocks;
 RewriteRule **rules;
} RuleLock;
# 25 "/products1/postgres/PG12.1/include/server/utils/rel.h" 2
# 36 "/products1/postgres/PG12.1/include/server/utils/rel.h"
typedef struct LockRelId
{
 Oid relId;
 Oid dbId;
} LockRelId;

typedef struct LockInfoData
{
 LockRelId lockRelId;
} LockInfoData;

typedef LockInfoData *LockInfo;





typedef struct RelationData
{
 RelFileNode rd_node;

 struct SMgrRelationData *rd_smgr;
 int rd_refcnt;
 BackendId rd_backend;
 _Bool rd_islocaltemp;
 _Bool rd_isnailed;
 _Bool rd_isvalid;
 _Bool rd_indexvalid;

 _Bool rd_statvalid;
# 80 "/products1/postgres/PG12.1/include/server/utils/rel.h"
 SubTransactionId rd_createSubid;
 SubTransactionId rd_newRelfilenodeSubid;


 Form_pg_class rd_rel;
 TupleDesc rd_att;
 Oid rd_id;
 LockInfoData rd_lockInfo;
 RuleLock *rd_rules;
 MemoryContext rd_rulescxt;
 TriggerDesc *trigdesc;

 struct RowSecurityDesc *rd_rsdesc;


 List *rd_fkeylist;
 _Bool rd_fkeyvalid;

 struct PartitionKeyData *rd_partkey;
 MemoryContext rd_partkeycxt;
 struct PartitionDescData *rd_partdesc;
 MemoryContext rd_pdcxt;
 List *rd_partcheck;
 _Bool rd_partcheckvalid;
 MemoryContext rd_partcheckcxt;


 List *rd_indexlist;
 Oid rd_pkindex;
 Oid rd_replidindex;


 List *rd_statlist;


 Bitmapset *rd_indexattr;
 Bitmapset *rd_keyattr;
 Bitmapset *rd_pkattr;
 Bitmapset *rd_idattr;

 PublicationActions *rd_pubactions;






 bytea *rd_options;
# 136 "/products1/postgres/PG12.1/include/server/utils/rel.h"
 Oid rd_amhandler;




 const struct TableAmRoutine *rd_tableam;


 Form_pg_index rd_index;

 struct HeapTupleData *rd_indextuple;
# 156 "/products1/postgres/PG12.1/include/server/utils/rel.h"
 MemoryContext rd_indexcxt;

 struct IndexAmRoutine *rd_indam;
 Oid *rd_opfamily;
 Oid *rd_opcintype;
 RegProcedure *rd_support;
 FmgrInfo *rd_supportinfo;
 int16 *rd_indoption;
 List *rd_indexprs;
 List *rd_indpred;
 Oid *rd_exclops;
 Oid *rd_exclprocs;
 uint16 *rd_exclstrats;
 Oid *rd_indcollation;
# 180 "/products1/postgres/PG12.1/include/server/utils/rel.h"
 void *rd_amcache;
# 191 "/products1/postgres/PG12.1/include/server/utils/rel.h"
 struct FdwRoutine *rd_fdwroutine;
# 202 "/products1/postgres/PG12.1/include/server/utils/rel.h"
 Oid rd_toastoid;


 struct PgStat_TableStatus *pgstat_info;
} RelationData;
# 223 "/products1/postgres/PG12.1/include/server/utils/rel.h"
typedef struct ForeignKeyCacheInfo
{
 NodeTag type;
 Oid conoid;
 Oid conrelid;
 Oid confrelid;
 int nkeys;

 AttrNumber conkey[32];
 AttrNumber confkey[32];
 Oid conpfeqop[32];
} ForeignKeyCacheInfo;
# 246 "/products1/postgres/PG12.1/include/server/utils/rel.h"
typedef struct AutoVacOpts
{
 _Bool enabled;
 int vacuum_threshold;
 int analyze_threshold;
 int vacuum_cost_limit;
 int freeze_min_age;
 int freeze_max_age;
 int freeze_table_age;
 int multixact_freeze_min_age;
 int multixact_freeze_max_age;
 int multixact_freeze_table_age;
 int log_min_duration;
 float8 vacuum_cost_delay;
 float8 vacuum_scale_factor;
 float8 analyze_scale_factor;
} AutoVacOpts;

typedef struct StdRdOptions
{
 int32 vl_len_;
 int fillfactor;

 float8 vacuum_cleanup_index_scale_factor;
 int toast_tuple_target;
 AutoVacOpts autovacuum;
 _Bool user_catalog_table;
 int parallel_workers;
 _Bool vacuum_index_cleanup;
 _Bool vacuum_truncate;
} StdRdOptions;
# 336 "/products1/postgres/PG12.1/include/server/utils/rel.h"
typedef struct ViewOptions
{
 int32 vl_len_;
 _Bool security_barrier;
 int check_option_offset;
} ViewOptions;
# 607 "/products1/postgres/PG12.1/include/server/utils/rel.h"
extern void RelationIncrementReferenceCount(Relation rel);
extern void RelationDecrementReferenceCount(Relation rel);
extern List *RelationGetRepsetList(Relation rel);
# 69 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/resowner.h" 1
# 27 "/products1/postgres/PG12.1/include/server/utils/resowner.h"
typedef struct ResourceOwnerData *ResourceOwner;





extern ResourceOwner CurrentResourceOwner;
extern ResourceOwner CurTransactionResourceOwner;
extern ResourceOwner TopTransactionResourceOwner;
extern ResourceOwner AuxProcessResourceOwner;
# 46 "/products1/postgres/PG12.1/include/server/utils/resowner.h"
typedef enum
{
 RESOURCE_RELEASE_BEFORE_LOCKS,
 RESOURCE_RELEASE_LOCKS,
 RESOURCE_RELEASE_AFTER_LOCKS
} ResourceReleasePhase;





typedef void (*ResourceReleaseCallback) (ResourceReleasePhase phase,
           _Bool isCommit,
           _Bool isTopLevel,
           void *arg);







extern ResourceOwner ResourceOwnerCreate(ResourceOwner parent,
           const char *name);
extern void ResourceOwnerRelease(ResourceOwner owner,
         ResourceReleasePhase phase,
         _Bool isCommit,
         _Bool isTopLevel);
extern void ResourceOwnerDelete(ResourceOwner owner);
extern ResourceOwner ResourceOwnerGetParent(ResourceOwner owner);
extern void ResourceOwnerNewParent(ResourceOwner owner,
           ResourceOwner newparent);
extern void RegisterResourceReleaseCallback(ResourceReleaseCallback callback,
           void *arg);
extern void UnregisterResourceReleaseCallback(ResourceReleaseCallback callback,
             void *arg);
extern void CreateAuxProcessResourceOwner(void);
extern void ReleaseAuxProcessResources(_Bool isCommit);
# 70 "db2_fdw.c" 2


# 1 "/products1/postgres/PG12.1/include/server/utils/snapmgr.h" 1
# 49 "/products1/postgres/PG12.1/include/server/utils/snapmgr.h"
extern int old_snapshot_threshold;


extern Size SnapMgrShmemSize(void);
extern void SnapMgrInit(void);
extern TimestampTz GetSnapshotCurrentTimestamp(void);
extern TimestampTz GetOldSnapshotThresholdTimestamp(void);

extern _Bool FirstSnapshotSet;

extern TransactionId TransactionXmin;
extern TransactionId RecentXmin;
extern TransactionId RecentGlobalXmin;
extern TransactionId RecentGlobalDataXmin;


extern SnapshotData SnapshotSelfData;
extern SnapshotData SnapshotAnyData;
extern SnapshotData CatalogSnapshotData;
# 103 "/products1/postgres/PG12.1/include/server/utils/snapmgr.h"
extern Snapshot GetTransactionSnapshot(void);
extern Snapshot GetLatestSnapshot(void);
extern void SnapshotSetCommandId(CommandId curcid);
extern Snapshot GetOldestSnapshot(void);

extern Snapshot GetCatalogSnapshot(Oid relid);
extern Snapshot GetNonHistoricCatalogSnapshot(Oid relid);
extern void InvalidateCatalogSnapshot(void);
extern void InvalidateCatalogSnapshotConditionally(void);

extern void PushActiveSnapshot(Snapshot snapshot);
extern void PushCopiedSnapshot(Snapshot snapshot);
extern void UpdateActiveSnapshotCommandId(void);
extern void PopActiveSnapshot(void);
extern Snapshot GetActiveSnapshot(void);
extern _Bool ActiveSnapshotSet(void);

extern Snapshot RegisterSnapshot(Snapshot snapshot);
extern void UnregisterSnapshot(Snapshot snapshot);
extern Snapshot RegisterSnapshotOnOwner(Snapshot snapshot, ResourceOwner owner);
extern void UnregisterSnapshotFromOwner(Snapshot snapshot, ResourceOwner owner);

extern FullTransactionId GetFullRecentGlobalXmin(void);

extern void AtSubCommit_Snapshot(int level);
extern void AtSubAbort_Snapshot(int level);
extern void AtEOXact_Snapshot(_Bool isCommit, _Bool resetXmin);

extern void ImportSnapshot(const char *idstr);
extern _Bool XactHasExportedSnapshots(void);
extern void DeleteAllExportedSnapshotFiles(void);
extern _Bool ThereAreNoPriorRegisteredSnapshots(void);
extern TransactionId TransactionIdLimitedForOldSnapshots(TransactionId recentXmin,
               Relation relation);
extern void MaintainOldSnapshotTimeMapping(TimestampTz whenTaken,
             TransactionId xmin);

extern char *ExportSnapshot(Snapshot snapshot);




extern _Bool XidInMVCCSnapshot(TransactionId xid, Snapshot snapshot);


struct HTAB;
extern struct HTAB *HistoricSnapshotGetTupleCids(void);
extern void SetupHistoricSnapshot(Snapshot snapshot_now, struct HTAB *tuplecids);
extern void TeardownHistoricSnapshot(_Bool is_error);
extern _Bool HistoricSnapshotActive(void);

extern Size EstimateSnapshotSpace(Snapshot snapshot);
extern void SerializeSnapshot(Snapshot snapshot, char *start_address);
extern Snapshot RestoreSnapshot(char *start_address);
extern void RestoreTransactionSnapshot(Snapshot snapshot, void *master_pgproc);
# 73 "db2_fdw.c" 2
# 1 "/products1/postgres/PG12.1/include/server/utils/syscache.h" 1
# 32 "/products1/postgres/PG12.1/include/server/utils/syscache.h"
enum SysCacheIdentifier
{
 AGGFNOID = 0,
 AMNAME,
 AMOID,
 AMOPOPID,
 AMOPSTRATEGY,
 AMPROCNUM,
 ATTNAME,
 ATTNUM,
 AUTHMEMMEMROLE,
 AUTHMEMROLEMEM,
 AUTHNAME,
 AUTHOID,
 CASTSOURCETARGET,
 CLAAMNAMENSP,
 CLAOID,
 COLLNAMEENCNSP,
 COLLOID,
 CONDEFAULT,
 CONNAMENSP,
 CONSTROID,
 CONVOID,
 DATABASEOID,
 DEFACLROLENSPOBJ,
 ENUMOID,
 ENUMTYPOIDNAME,
 EVENTTRIGGERNAME,
 EVENTTRIGGEROID,
 FOREIGNDATAWRAPPERNAME,
 FOREIGNDATAWRAPPEROID,
 FOREIGNSERVERNAME,
 FOREIGNSERVEROID,
 FOREIGNTABLEREL,
 INDEXRELID,
 LANGNAME,
 LANGOID,
 NAMESPACENAME,
 NAMESPACEOID,
 OPERNAMENSP,
 OPEROID,
 OPFAMILYAMNAMENSP,
 OPFAMILYOID,
 PARTRELID,
 PROCNAMEARGSNSP,
 PROCOID,
 PUBLICATIONNAME,
 PUBLICATIONOID,
 PUBLICATIONREL,
 PUBLICATIONRELMAP,
 RANGETYPE,
 RELNAMENSP,
 RELOID,
 REPLORIGIDENT,
 REPLORIGNAME,
 RULERELNAME,
 SEQRELID,
 STATEXTDATASTXOID,
 STATEXTNAMENSP,
 STATEXTOID,
 STATRELATTINH,
 SUBSCRIPTIONNAME,
 SUBSCRIPTIONOID,
 SUBSCRIPTIONRELMAP,
 TABLESPACEOID,
 TRFOID,
 TRFTYPELANG,
 TSCONFIGMAP,
 TSCONFIGNAMENSP,
 TSCONFIGOID,
 TSDICTNAMENSP,
 TSDICTOID,
 TSPARSERNAMENSP,
 TSPARSEROID,
 TSTEMPLATENAMENSP,
 TSTEMPLATEOID,
 TYPENAMENSP,
 TYPEOID,
 USERMAPPINGOID,
 USERMAPPINGUSERSERVER


};

extern void InitCatalogCache(void);
extern void InitCatalogCachePhase2(void);

extern HeapTuple SearchSysCache(int cacheId,
        Datum key1, Datum key2, Datum key3, Datum key4);





extern HeapTuple SearchSysCache1(int cacheId,
         Datum key1);
extern HeapTuple SearchSysCache2(int cacheId,
         Datum key1, Datum key2);
extern HeapTuple SearchSysCache3(int cacheId,
         Datum key1, Datum key2, Datum key3);
extern HeapTuple SearchSysCache4(int cacheId,
         Datum key1, Datum key2, Datum key3, Datum key4);

extern void ReleaseSysCache(HeapTuple tuple);


extern HeapTuple SearchSysCacheCopy(int cacheId,
         Datum key1, Datum key2, Datum key3, Datum key4);
extern _Bool SearchSysCacheExists(int cacheId,
         Datum key1, Datum key2, Datum key3, Datum key4);
extern Oid GetSysCacheOid(int cacheId, AttrNumber oidcol,
         Datum key1, Datum key2, Datum key3, Datum key4);

extern HeapTuple SearchSysCacheAttName(Oid relid, const char *attname);
extern HeapTuple SearchSysCacheCopyAttName(Oid relid, const char *attname);
extern _Bool SearchSysCacheExistsAttName(Oid relid, const char *attname);

extern HeapTuple SearchSysCacheAttNum(Oid relid, int16 attnum);
extern HeapTuple SearchSysCacheCopyAttNum(Oid relid, int16 attnum);

extern Datum SysCacheGetAttr(int cacheId, HeapTuple tup,
        AttrNumber attributeNumber, _Bool *isNull);

extern uint32 GetSysCacheHashValue(int cacheId,
           Datum key1, Datum key2, Datum key3, Datum key4);


struct catclist;
extern struct catclist *SearchSysCacheList(int cacheId, int nkeys,
             Datum key1, Datum key2, Datum key3);

extern void SysCacheInvalidate(int cacheId, uint32 hashValue);

extern _Bool RelationInvalidatesSnapshotsOnly(Oid relid);
extern _Bool RelationHasSysCache(Oid relid);
extern _Bool RelationSupportsSysCache(Oid relid);
# 74 "db2_fdw.c" 2





# 1 "db2_fdw.h" 1
# 13 "db2_fdw.h"
# 1 "/products1/postgres/PG12.1/include/server/postgres_ext.h" 1
# 14 "db2_fdw.h" 2
# 68 "db2_fdw.h"
typedef struct db2Session db2Session;


typedef enum
{
  SQL_TYPE_VARCHAR,
  SQL_TYPE_CHAR,
  SQL_TYPE_SMALL,
  SQL_TYPE_INTEGER,
  SQL_TYPE_BIG,
  SQL_TYPE_DATE,
  SQL_TYPE_STAMP,
  SQL_TYPE_TIME,
  SQL_TYPE_XML,
  SQL_TYPE_BLOB,
  SQL_TYPE_CLOB,
  SQL_TYPE_DECIMAL,
  SQL_TYPE_GRAPHIC,
  SQL_TYPE_VARGRAPHIC,
  SQL_TYPE_DOUBLE,
  SQL_TYPE_FLOAT,
  SQL_TYPE_BOOLEAN,
  SQL_TYPE_OTHER
} db2Type;






struct db2Column
{
  char *name;
  db2Type db2type;
  int scale;
  char *pgname;
  int pgattnum;
  Oid pgtype;
  int pgtypmod;
  int used;
  int pkey;
  char *val;
  long val_size;
  unsigned short val_len;
  unsigned int val_len4;
  short val_null;
  int varno;
};

struct db2Table
{
  char *name;
  char *pgname;
  int ncols;
  int npgcols;
  struct db2Column **cols;
};



typedef enum
{
  BIND_STRING,
  BIND_NUMBER,
  BIND_LONG,
  BIND_LONGRAW,
  BIND_OUTPUT
} db2BindType;

struct paramDesc
{
  char *name;
  Oid type;
  db2BindType bindType;
  char *value;
  void *node;
  int colnum;
  void *bindh;
  struct paramDesc *next;
};


typedef enum
{
  FDW_ERROR,
  FDW_UNABLE_TO_ESTABLISH_CONNECTION,
  FDW_UNABLE_TO_CREATE_REPLY,
  FDW_UNABLE_TO_CREATE_EXECUTION,
  FDW_TABLE_NOT_FOUND,
  FDW_OUT_OF_MEMORY,
  FDW_SERIALIZATION_FAILURE
} db2error;




extern db2Session *db2GetSession (const char *connectstring, char *user, char *password, const char *nls_lang, const char *tablename, int curlevel);
extern void db2CloseStatement (db2Session * session);
extern void db2CloseConnections (void);
extern void db2Shutdown (void);
extern void db2Cancel (void);
extern void db2EndTransaction (void *arg, int is_commit, int silent);
extern void db2EndSubtransaction (void *arg, int nest_level, int is_commit);
extern int db2IsStatementOpen (db2Session * session);
extern struct db2Table *db2Describe (db2Session * session, char *schema, char *table, char *pgname, long max_long);
extern void db2ExplainOLD (db2Session * session, const char *query, int *nrows, char ***plan);
extern void db2PrepareQuery (db2Session * session, const char *query, const struct db2Table *db2Table, unsigned int prefetch);
extern int db2ExecuteQuery (db2Session * session, const struct db2Table *db2Table, struct paramDesc *paramList);
extern int db2FetchNext (db2Session * session);
extern void db2GetLob (db2Session * session, void *locptr, db2Type type, char **value, long *value_len, unsigned long trunc);
extern void db2ClientVersion (int *major, int *minor, int *update, int *patch, int *port_patch);
extern void db2ServerVersion (const char *connectstring, char *user, char *password, char * version, int len);
extern void *db2GetGeometryType (db2Session * session);
extern int db2GetImportColumn (db2Session * session, char *schema, char **tabname, char **colname, db2Type * type, int *charlen, int *typeprec, int *typescale, int *nullable, int *key);




extern char *db2GetShareFileName (const char *relativename);
extern void db2RegisterCallback (void *arg);
extern void db2UnregisterCallback (void *arg);
extern void *db2Alloc (size_t size);
extern void *db2Realloc (void *p, size_t size);
extern void db2Free (void *p);
extern void db2SetHandlers (void);
extern void db2Error_d (db2error sqlstate, const char *message, const char *detail, ...);
extern void db2Error (db2error sqlstate, const char *message);
extern void db2Debug2 (const char *message,...);
extern void db2Debug3 (const char *message,...);
extern void db2Debug4 (const char *message,...);
extern void db2Debug5 (const char *message,...);
# 80 "db2_fdw.c" 2
# 122 "db2_fdw.c"
extern const Pg_magic_struct *Pg_magic_func(void); const Pg_magic_struct * Pg_magic_func(void) { static const Pg_magic_struct Pg_magic_data = { sizeof(Pg_magic_struct), 120001 / 100, 100, 32, 64, 1, 1 }; return &Pg_magic_data; } extern int no_such_variable;




static _Bool dml_in_transaction = 0;




struct DB2FdwOption
{
  const char *optname;
  Oid optcontext;
  _Bool optrequired;
};
# 157 "db2_fdw.c"
typedef enum
{ CASE_KEEP, CASE_LOWER, CASE_SMART } fold_t;




static struct DB2FdwOption valid_options[] = {
  {"nls_lang", 2328, 0},
  {"dbserver", 1417, 1},
  {"user", 1418, 1},
  {"password", 1418, 1},
  {"schema", 3118, 0},
  {"table", 3118, 1},
  {"max_long", 3118, 0},
  {"readonly", 3118, 0},
  {"sample_percent", 3118, 0},
  {"prefetch", 3118, 0}
  , {"key", 1249, 0}
};
# 185 "db2_fdw.c"
static regproc *output_funcs;
# 195 "db2_fdw.c"
struct DB2FdwState
{
  char *dbserver;
  char *user;
  char *password;
  char *nls_lang;
  db2Session *session;
  char *query;
  List *params;
  struct paramDesc *paramList;
  struct db2Table *db2Table;
  Cost startup_cost;
  Cost total_cost;
  unsigned long rowcount;
  int columnindex;
  MemoryContext temp_cxt;
  unsigned int prefetch;
  char *order_clause;
  char *where_clause;
# 228 "db2_fdw.c"
  List *remote_conds;
  List *local_conds;


  RelOptInfo *outerrel;
  RelOptInfo *innerrel;
  JoinType jointype;
  List *joinclauses;
};




extern Datum db2_fdw_handler (FunctionCallInfo fcinfo);
extern Datum db2_fdw_validator (FunctionCallInfo fcinfo);
extern Datum db2_close_connections (FunctionCallInfo fcinfo);
extern Datum db2_diag (FunctionCallInfo fcinfo);
void db2Explain (void * fdw, ExplainState * es);

extern Datum db2_fdw_handler(FunctionCallInfo fcinfo); extern const Pg_finfo_record * pg_finfo_db2_fdw_handler(void); const Pg_finfo_record * pg_finfo_db2_fdw_handler (void) { static const Pg_finfo_record my_finfo = { 1 }; return &my_finfo; } extern int no_such_variable;
extern Datum db2_fdw_validator(FunctionCallInfo fcinfo); extern const Pg_finfo_record * pg_finfo_db2_fdw_validator(void); const Pg_finfo_record * pg_finfo_db2_fdw_validator (void) { static const Pg_finfo_record my_finfo = { 1 }; return &my_finfo; } extern int no_such_variable;
extern Datum db2_close_connections(FunctionCallInfo fcinfo); extern const Pg_finfo_record * pg_finfo_db2_close_connections(void); const Pg_finfo_record * pg_finfo_db2_close_connections (void) { static const Pg_finfo_record my_finfo = { 1 }; return &my_finfo; } extern int no_such_variable;
extern Datum db2_diag(FunctionCallInfo fcinfo); extern const Pg_finfo_record * pg_finfo_db2_diag(void); const Pg_finfo_record * pg_finfo_db2_diag (void) { static const Pg_finfo_record my_finfo = { 1 }; return &my_finfo; } extern int no_such_variable;




extern void _PG_init (void);




static void db2GetForeignRelSize (PlannerInfo * root, RelOptInfo * baserel, Oid foreigntableid);
static void db2GetForeignPaths (PlannerInfo * root, RelOptInfo * baserel, Oid foreigntableid);
static void db2GetForeignJoinPaths (PlannerInfo * root, RelOptInfo * joinrel, RelOptInfo * outerrel, RelOptInfo * innerrel, JoinType jointype, JoinPathExtraData * extra);
static ForeignScan *db2GetForeignPlan (PlannerInfo * root, RelOptInfo * foreignrel, Oid foreigntableid, ForeignPath * best_path, List * tlist, List * scan_clauses , Plan * outer_plan);
static _Bool db2AnalyzeForeignTable (Relation relation, AcquireSampleRowsFunc * func, BlockNumber * totalpages);
static void db2ExplainForeignScan (ForeignScanState * node, ExplainState * es);
static void db2BeginForeignScan (ForeignScanState * node, int eflags);
static TupleTableSlot *db2IterateForeignScan (ForeignScanState * node);
static void db2EndForeignScan (ForeignScanState * node);
static void db2ReScanForeignScan (ForeignScanState * node);
static void db2AddForeignUpdateTargets (Query * parsetree, RangeTblEntry * target_rte, Relation target_relation);
static List *db2PlanForeignModify (PlannerInfo * root, ModifyTable * plan, Index resultRelation, int subplan_index);
static void db2BeginForeignModify (ModifyTableState * mtstate, ResultRelInfo * rinfo, List * fdw_private, int subplan_index, int eflags);
static TupleTableSlot *db2ExecForeignInsert (EState * estate, ResultRelInfo * rinfo, TupleTableSlot * slot, TupleTableSlot * planSlot);
static TupleTableSlot *db2ExecForeignUpdate (EState * estate, ResultRelInfo * rinfo, TupleTableSlot * slot, TupleTableSlot * planSlot);
static TupleTableSlot *db2ExecForeignDelete (EState * estate, ResultRelInfo * rinfo, TupleTableSlot * slot, TupleTableSlot * planSlot);
static void db2EndForeignModify (EState * estate, ResultRelInfo * rinfo);
static void db2ExplainForeignModify (ModifyTableState * mtstate, ResultRelInfo * rinfo, List * fdw_private, int subplan_index, struct ExplainState *es);
static int db2IsForeignRelUpdatable (Relation rel);
static List *db2ImportForeignSchema (ImportForeignSchemaStmt * stmt, Oid serverOid);




static struct DB2FdwState *getFdwState (Oid foreigntableid, double *sample_percent);
static void db2GetOptions (Oid foreigntableid, List ** options);
static char *createQuery (struct DB2FdwState *fdwState, RelOptInfo * foreignrel, _Bool modify, List * query_pathkeys);
static void deparseFromExprForRel (struct DB2FdwState *fdwState, StringInfo buf, RelOptInfo * joinrel, List ** params_list);
static void appendConditions (List * exprs, StringInfo buf, RelOptInfo * joinrel, List ** params_list);
static _Bool foreign_join_ok (PlannerInfo * root, RelOptInfo * joinrel, JoinType jointype, RelOptInfo * outerrel, RelOptInfo * innerrel, JoinPathExtraData * extra);
static const char *get_jointype_name (JoinType jointype);
static List *build_tlist_to_deparse (RelOptInfo * foreignrel);
static void getColumnData (Oid foreigntableid, struct db2Table *db2Table);
static int acquireSampleRowsFunc (Relation relation, int elevel, HeapTuple * rows, int targrows, double *totalrows, double *totaldeadrows);
static void appendAsType (StringInfoData * dest, const char *s, Oid type);
static char *deparseExpr (db2Session * session, RelOptInfo * foreignrel, Expr * expr, const struct db2Table *db2Table, List ** params);
static char *datumToString (Datum datum, Oid type);
static void getUsedColumns (Expr * expr, struct db2Table *db2Table, int foreignrelid);
static void checkDataType (db2Type db2type, int scale, Oid pgtype, const char *tablename, const char *colname);
static char *deparseWhereConditions (struct DB2FdwState *fdwState, RelOptInfo * baserel, List ** local_conds, List ** remote_conds);
static char *guessNlsLang (char *nls_lang);
static List *serializePlanData (struct DB2FdwState *fdwState);
static Const *serializeString (const char *s);
static Const *serializeLong (long i);
static struct DB2FdwState *deserializePlanData (List * list);
static char *deserializeString (Const * constant);
static long deserializeLong (Const * constant);
static _Bool optionIsTrue (const char *value);
static Expr *find_em_expr_for_rel (EquivalenceClass * ec, RelOptInfo * rel);
static char *deparseDate (Datum datum);
static char *deparseTimestamp (Datum datum, _Bool hasTimezone);
static char *deparseInterval (Datum datum);
static struct DB2FdwState *copyPlanData (struct DB2FdwState *orig);
static void subtransactionCallback (SubXactEvent event, SubTransactionId mySubid, SubTransactionId parentSubid, void *arg);
static void addParam (struct paramDesc **paramList, char *name, Oid pgtype, db2Type db2type, int colnum);
static void setModifyParameters (struct paramDesc *paramList, TupleTableSlot * newslot, TupleTableSlot * oldslot, struct db2Table *db2Table, db2Session * session);
static void transactionCallback (XactEvent event, void *arg);
static void exitHook (int code, Datum arg);
static void db2Die (int postgres_signal_arg);
static char *setSelectParameters (struct paramDesc *paramList, ExprContext * econtext);
static void convertTuple (struct DB2FdwState *fdw_state, Datum * values, _Bool * nulls, _Bool trunc_lob);
static void errorContextCallback (void *arg);
static char *fold_case (char *name, fold_t foldcase);
# 333 "db2_fdw.c"
 Datum
db2_fdw_handler (FunctionCallInfo fcinfo)
{
  FdwRoutine *fdwroutine = ((FdwRoutine *) ({ Node *_result; ((void)1); _result = (Node *) ( ( ((sizeof(FdwRoutine)) & (sizeof(long) - 1)) == 0 && (sizeof(FdwRoutine)) <= 1024 && 1024 != 0 && (0) == 0 ) ? MemoryContextAllocZeroAligned(CurrentMemoryContext, sizeof(FdwRoutine)) : MemoryContextAllocZero(CurrentMemoryContext, sizeof(FdwRoutine)) ); _result->type = (T_FdwRoutine); _result; }));

  fdwroutine->GetForeignRelSize = db2GetForeignRelSize;
  fdwroutine->GetForeignPaths = db2GetForeignPaths;
  fdwroutine->GetForeignJoinPaths = db2GetForeignJoinPaths;
  fdwroutine->GetForeignPlan = db2GetForeignPlan;
  fdwroutine->AnalyzeForeignTable = db2AnalyzeForeignTable;
  fdwroutine->ExplainForeignScan = db2ExplainForeignScan;
  fdwroutine->BeginForeignScan = db2BeginForeignScan;
  fdwroutine->IterateForeignScan = db2IterateForeignScan;
  fdwroutine->ReScanForeignScan = db2ReScanForeignScan;
  fdwroutine->EndForeignScan = db2EndForeignScan;
  fdwroutine->AddForeignUpdateTargets = db2AddForeignUpdateTargets;
  fdwroutine->PlanForeignModify = db2PlanForeignModify;
  fdwroutine->BeginForeignModify = db2BeginForeignModify;
  fdwroutine->ExecForeignInsert = db2ExecForeignInsert;
  fdwroutine->ExecForeignUpdate = db2ExecForeignUpdate;
  fdwroutine->ExecForeignDelete = db2ExecForeignDelete;
  fdwroutine->EndForeignModify = db2EndForeignModify;
  fdwroutine->ExplainForeignModify = db2ExplainForeignModify;
  fdwroutine->IsForeignRelUpdatable = db2IsForeignRelUpdatable;
  fdwroutine->ImportForeignSchema = db2ImportForeignSchema;

  return ((Datum) (fdwroutine));
}
# 370 "db2_fdw.c"
 Datum
db2_fdw_validator (FunctionCallInfo fcinfo)
{
  List *options_list = untransformRelOptions ((fcinfo->args[0].value));
  Oid catalog = ((Oid) ((fcinfo->args[1].value)));
  ListCell *cell;
  _Bool option_given[(sizeof(valid_options)/sizeof(struct DB2FdwOption))] = { 0 };
  int i;






  for ((cell) = list_head(options_list); (cell) != ((void *)0); (cell) = ((cell)->next)) {
    DefElem *def = (DefElem *) ((cell)->data.ptr_value);
    _Bool opt_found = 0;


    for (i = 0; i < (sizeof(valid_options)/sizeof(struct DB2FdwOption)); ++i) {
      if (catalog == valid_options[i].optcontext && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (valid_options[i].optname) && __builtin_constant_p (def->defname) && (__s1_len = strlen (valid_options[i].optname), __s2_len = strlen (def->defname), (!((size_t)(const void *)((valid_options[i].optname) + 1) - (size_t)(const void *)(valid_options[i].optname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s2_len >= 4)) ? __builtin_strcmp (valid_options[i].optname, def->defname) : (__builtin_constant_p (valid_options[i].optname) && ((size_t)(const void *)((valid_options[i].optname) + 1) - (size_t)(const void *)(valid_options[i].optname) == 1) && (__s1_len = strlen (valid_options[i].optname), __s1_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (valid_options[i].optname, def->defname) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (def->defname); int __result = (((const unsigned char *) (const char *) (valid_options[i].optname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (valid_options[i].optname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (valid_options[i].optname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (valid_options[i].optname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s2_len = strlen (def->defname), __s2_len < 4) ? (__builtin_constant_p (valid_options[i].optname) && ((size_t)(const void *)((valid_options[i].optname) + 1) - (size_t)(const void *)(valid_options[i].optname) == 1) ? __builtin_strcmp (valid_options[i].optname, def->defname) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (valid_options[i].optname); register int __result = __s1[0] - ((const unsigned char *) (const char *) (def->defname))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (def->defname))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (def->defname))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (def->defname))[3]); } } __result; }))) : __builtin_strcmp (valid_options[i].optname, def->defname)))); }) == 0) {
 opt_found = 1;
 option_given[i] = 1;
 break;
      }
    }


    if (!opt_found) {

      StringInfoData buf;
      initStringInfo (&buf);
      for (i = 0; i < (sizeof(valid_options)/sizeof(struct DB2FdwOption)); ++i) {
 if (catalog == valid_options[i].optcontext)
   appendStringInfo (&buf, "%s%s", (buf.len > 0) ? ", " : "", valid_options[i].optname);
      }

      do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 407, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('D') - '0') & 0x3F) << 24))), errmsg ("invalid option \"%s\"", def->defname), errhint ("Valid options in this context are: %s", buf.data)); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    }


    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("readonly") && (__s1_len = strlen (def->defname), __s2_len = strlen ("readonly"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("readonly") + 1) - (size_t)(const void *)("readonly") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "readonly") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("readonly") && ((size_t)(const void *)(("readonly") + 1) - (size_t)(const void *)("readonly") == 1) ? __builtin_strcmp (def->defname, "readonly") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("readonly"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("readonly") && ((size_t)(const void *)(("readonly") + 1) - (size_t)(const void *)("readonly") == 1) && (__s2_len = strlen ("readonly"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "readonly") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("readonly"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("readonly"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("readonly"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("readonly"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "readonly")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("key") && (__s1_len = strlen (def->defname), __s2_len = strlen ("key"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("key") + 1) - (size_t)(const void *)("key") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "key") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("key") && ((size_t)(const void *)(("key") + 1) - (size_t)(const void *)("key") == 1) ? __builtin_strcmp (def->defname, "key") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("key"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("key") && ((size_t)(const void *)(("key") + 1) - (size_t)(const void *)("key") == 1) && (__s2_len = strlen ("key"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "key") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("key"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("key"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("key"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("key"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "key")))); }) == 0) {
      char *val = ((Value *) (def->arg))->val.str;
      if (pg_strcasecmp (val, "on") != 0
   && pg_strcasecmp (val, "off") != 0
   && pg_strcasecmp (val, "yes") != 0 && pg_strcasecmp (val, "no") != 0 && pg_strcasecmp (val, "true") != 0 && pg_strcasecmp (val, "false") != 0)
 do { int __errno_location __attribute__((unused)); if (errstart(20,

 "db2_fdw.c"
# 416 "db2_fdw.c"
 ,

 418
# 416 "db2_fdw.c"
 , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('2') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("invalid value for option \"%s\"", def->defname), errhint ("Valid values in this context are: on/yes/true or off/no/false")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)

                                                                                                                                         ;
    }


    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("table") && (__s1_len = strlen (def->defname), __s2_len = strlen ("table"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("table") + 1) - (size_t)(const void *)("table") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "table") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("table") && ((size_t)(const void *)(("table") + 1) - (size_t)(const void *)("table") == 1) ? __builtin_strcmp (def->defname, "table") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("table"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("table") && ((size_t)(const void *)(("table") + 1) - (size_t)(const void *)("table") == 1) && (__s2_len = strlen ("table"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "table") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("table"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("table"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("table"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("table"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "table")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("schema") && (__s1_len = strlen (def->defname), __s2_len = strlen ("schema"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("schema") + 1) - (size_t)(const void *)("schema") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "schema") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("schema") && ((size_t)(const void *)(("schema") + 1) - (size_t)(const void *)("schema") == 1) ? __builtin_strcmp (def->defname, "schema") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("schema"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("schema") && ((size_t)(const void *)(("schema") + 1) - (size_t)(const void *)("schema") == 1) && (__s2_len = strlen ("schema"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "schema") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("schema"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("schema"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("schema"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("schema"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "schema")))); }) == 0) {
      char *val = ((Value *) (def->arg))->val.str;
      if ((__extension__ (__builtin_constant_p ('"') && !__builtin_constant_p (val) && ('"') == '\0' ? (char *) __rawmemchr (val, '"') : __builtin_strchr (val, '"'))) != ((void *)0))
 do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 425, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('2') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("invalid value for option \"%s\"", def->defname), errhint ("Double quotes are not allowed in names.")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    }


    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("max_long") && (__s1_len = strlen (def->defname), __s2_len = strlen ("max_long"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("max_long") + 1) - (size_t)(const void *)("max_long") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "max_long") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("max_long") && ((size_t)(const void *)(("max_long") + 1) - (size_t)(const void *)("max_long") == 1) ? __builtin_strcmp (def->defname, "max_long") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("max_long"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("max_long") && ((size_t)(const void *)(("max_long") + 1) - (size_t)(const void *)("max_long") == 1) && (__s2_len = strlen ("max_long"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "max_long") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("max_long"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("max_long"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("max_long"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("max_long"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "max_long")))); }) == 0) {
      char *val = ((Value *) (def->arg))->val.str;
      char *endptr;
      unsigned long max_long = strtoul (val, &endptr, 0);
      if (val[0] == '\0' || *endptr != '\0' || max_long < 1 || max_long > 1073741823ul)
 do { int __errno_location __attribute__((unused)); if (errstart(20,

 "db2_fdw.c"
# 434 "db2_fdw.c"
 ,

 436
# 434 "db2_fdw.c"
 , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('2') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("invalid value for option \"%s\"", def->defname), errhint ("Valid values in this context are integers between 1 and 1073741823.")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)

                                                                                                                                               ;
    }


    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("sample_percent") && (__s1_len = strlen (def->defname), __s2_len = strlen ("sample_percent"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("sample_percent") + 1) - (size_t)(const void *)("sample_percent") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "sample_percent") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("sample_percent") && ((size_t)(const void *)(("sample_percent") + 1) - (size_t)(const void *)("sample_percent") == 1) ? __builtin_strcmp (def->defname, "sample_percent") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("sample_percent"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("sample_percent") && ((size_t)(const void *)(("sample_percent") + 1) - (size_t)(const void *)("sample_percent") == 1) && (__s2_len = strlen ("sample_percent"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "sample_percent") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("sample_percent"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("sample_percent"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("sample_percent"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("sample_percent"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "sample_percent")))); }) == 0) {
      char *val = ((Value *) (def->arg))->val.str;
      char *endptr;
      double sample_percent;

      (*__errno_location ()) = 0;
      sample_percent = strtod (val, &endptr);
      if (val[0] == '\0' || *endptr != '\0' || (*__errno_location ()) != 0 || sample_percent < 0.000001 || sample_percent > 100.0)
 do { int __errno_location __attribute__((unused)); if (errstart(20,

 "db2_fdw.c"
# 448 "db2_fdw.c"
 ,

 450
# 448 "db2_fdw.c"
 , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('2') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("invalid value for option \"%s\"", def->defname), errhint ("Valid values in this context are numbers between 0.000001 and 100.")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)

                                                                                                                                              ;
    }


    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("prefetch") && (__s1_len = strlen (def->defname), __s2_len = strlen ("prefetch"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("prefetch") + 1) - (size_t)(const void *)("prefetch") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "prefetch") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("prefetch") && ((size_t)(const void *)(("prefetch") + 1) - (size_t)(const void *)("prefetch") == 1) ? __builtin_strcmp (def->defname, "prefetch") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("prefetch"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("prefetch") && ((size_t)(const void *)(("prefetch") + 1) - (size_t)(const void *)("prefetch") == 1) && (__s2_len = strlen ("prefetch"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "prefetch") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("prefetch"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("prefetch"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("prefetch"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("prefetch"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "prefetch")))); }) == 0) {
      char *val = ((Value *) (def->arg))->val.str;
      char *endptr;
      unsigned long prefetch = strtol (val, &endptr, 0);
      if (val[0] == '\0' || *endptr != '\0' || prefetch < 0 || prefetch > 10240)
 do { int __errno_location __attribute__((unused)); if (errstart(20,

 "db2_fdw.c"
# 459 "db2_fdw.c"
 ,

 461
# 459 "db2_fdw.c"
 , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('2') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("invalid value for option \"%s\"", def->defname), errhint ("Valid values in this context are integers between 0 and 10240.")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)

                                                                                                                                          ;
    }
  }


  for (i = 0; i < (sizeof(valid_options)/sizeof(struct DB2FdwOption)); ++i) {
    if (catalog == valid_options[i].optcontext && valid_options[i].optrequired && !option_given[i]) {
      do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 468, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('J') - '0') & 0x3F) << 24))), errmsg ("missing required option \"%s\"", valid_options[i].optname)); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    }
  }

  return (Datum) 0;
}





 Datum
db2_close_connections (FunctionCallInfo fcinfo)
{
  if (dml_in_transaction)
    do { int __errno_location __attribute__((unused)); if (errstart(20,


 "db2_fdw.c"
# 483 "db2_fdw.c"
    ,


 486
# 483 "db2_fdw.c"
    , __func__, ((void *)0))) errfinish (errcode ((((('2') - '0') & 0x3F) + (((('5') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('1') - '0') & 0x3F) << 24))), errmsg ("connections with an active transaction cannot be closed"), errhint ("The transaction that modified DB2 data must be closed first.") ); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)


       ;
  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 487, __func__); elog_finish(14, "db2_fdw: close all DB2 connections"); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);
  db2CloseConnections ();

  return (Datum) 0;
}







 Datum
db2_diag (FunctionCallInfo fcinfo)
{
  Oid srvId = ((Oid) 0);
  char *pgversion;
  char server_version[100];
  int major, minor, update, patch, port_patch;
  StringInfoData version;






  pgversion = GetConfigOptionByName("server_version", ((void *)0), 0);


  db2ClientVersion (&major, &minor, &update, &patch, &port_patch);

  initStringInfo (&version);
  appendStringInfo (&version, "db2_fdw %s, PostgreSQL %s, DB2 client %d.%d.%d.%d.%d", "1.0devel", pgversion, major, minor, update, patch, port_patch);

  if ((fcinfo->args[0].isnull)) {

    static const char *const db2_env[] = {
      "DB2INSTANCE",
      "DB2_HOME",
      "DB2LIB",
      ((void *)0)
    };
    int i;

    for (i = 0; db2_env[i] != ((void *)0); ++i) {
      char *val = getenv (db2_env[i]);

      if (val != ((void *)0))
 appendStringInfo (&version, ", %s=%s", db2_env[i], val);
    }
  }
  else {

    HeapTuple tup;
    Relation rel;
    Name srvname = ((Name) ((Pointer) ((fcinfo->args[0].value))));
    ForeignServer *server;
    UserMapping *mapping;
    ForeignDataWrapper *wrapper;
    List *options;
    ListCell *cell;
    char *nls_lang = ((void *)0), *user = ((void *)0), *password = ((void *)0), *dbserver = ((void *)0);


    rel = table_open (1417, 1);

    tup = SearchSysCacheCopy(FOREIGNSERVERNAME, ((Datum) (((*(srvname)).data))), 0, 0, 0);
    if (!((const void*)(tup) != ((void *)0)))
      do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 555, __func__, ((void *)0))) errfinish (errcode ((((('4') - '0') & 0x3F) + (((('2') - '0') & 0x3F) << 6) + (((('7') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("server \"%s\" does not exist", ((*srvname).data))); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);




     srvId = ((Form_pg_foreign_server)((char *) ((tup)->t_data) + (tup)->t_data->t_hoff))->oid;



    table_close (rel, 1);


    server = GetForeignServer (srvId);
    mapping = GetUserMapping (GetUserId (), srvId);
    wrapper = GetForeignDataWrapper (server->fdwid);


    options = wrapper->options;
    options = list_concat (options, server->options);
    options = list_concat (options, mapping->options);

    for ((cell) = list_head(options); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      DefElem *def = (DefElem *) ((cell)->data.ptr_value);
      if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("nls_lang") && (__s1_len = strlen (def->defname), __s2_len = strlen ("nls_lang"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("nls_lang") + 1) - (size_t)(const void *)("nls_lang") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "nls_lang") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("nls_lang") && ((size_t)(const void *)(("nls_lang") + 1) - (size_t)(const void *)("nls_lang") == 1) ? __builtin_strcmp (def->defname, "nls_lang") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("nls_lang"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("nls_lang") && ((size_t)(const void *)(("nls_lang") + 1) - (size_t)(const void *)("nls_lang") == 1) && (__s2_len = strlen ("nls_lang"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "nls_lang") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("nls_lang"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("nls_lang"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("nls_lang"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("nls_lang"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "nls_lang")))); }) == 0)
 nls_lang = ((Value *) (def->arg))->val.str;
      if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("dbserver") && (__s1_len = strlen (def->defname), __s2_len = strlen ("dbserver"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("dbserver") + 1) - (size_t)(const void *)("dbserver") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "dbserver") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("dbserver") && ((size_t)(const void *)(("dbserver") + 1) - (size_t)(const void *)("dbserver") == 1) ? __builtin_strcmp (def->defname, "dbserver") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("dbserver"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("dbserver") && ((size_t)(const void *)(("dbserver") + 1) - (size_t)(const void *)("dbserver") == 1) && (__s2_len = strlen ("dbserver"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "dbserver") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("dbserver"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("dbserver"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("dbserver"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("dbserver"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "dbserver")))); }) == 0)
 dbserver = ((Value *) (def->arg))->val.str;
      if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("user") && (__s1_len = strlen (def->defname), __s2_len = strlen ("user"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("user") + 1) - (size_t)(const void *)("user") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "user") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("user") && ((size_t)(const void *)(("user") + 1) - (size_t)(const void *)("user") == 1) ? __builtin_strcmp (def->defname, "user") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("user"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("user") && ((size_t)(const void *)(("user") + 1) - (size_t)(const void *)("user") == 1) && (__s2_len = strlen ("user"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "user") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("user"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("user"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("user"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("user"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "user")))); }) == 0)
 user = ((Value *) (def->arg))->val.str;
      if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("password") && (__s1_len = strlen (def->defname), __s2_len = strlen ("password"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("password") + 1) - (size_t)(const void *)("password") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "password") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("password") && ((size_t)(const void *)(("password") + 1) - (size_t)(const void *)("password") == 1) ? __builtin_strcmp (def->defname, "password") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("password"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("password") && ((size_t)(const void *)(("password") + 1) - (size_t)(const void *)("password") == 1) && (__s2_len = strlen ("password"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "password") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("password"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("password"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("password"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("password"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "password")))); }) == 0)
 password = ((Value *) (def->arg))->val.str;
    }


    nls_lang = guessNlsLang (nls_lang);





    db2ServerVersion (dbserver, user, password, server_version,sizeof(server_version));
    appendStringInfo (&version, ", DB2 server %s", server_version);



  }

  return ((Datum) (cstring_to_text (version.data)));
}






void _PG_init (void)
{

  on_proc_exit (&exitHook, ((Datum) (((void *)0))));
}







void
db2GetForeignRelSize (PlannerInfo * root, RelOptInfo * baserel, Oid foreigntableid)
{
  struct DB2FdwState *fdwState;
  int i;
  double ntuples = -1;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 629, __func__); elog_finish(14, "db2_fdw: plan foreign table scan"); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);


  fdwState = getFdwState (foreigntableid, ((void *)0));






  for (i = 0; i < fdwState->db2Table->ncols; ++i) {
    fdwState->db2Table->cols[i]->varno = baserel->relid;
  }







  fdwState->where_clause = deparseWhereConditions (fdwState, baserel, &(fdwState->local_conds), &(fdwState->remote_conds)
    );


  pfree (fdwState->session);
  fdwState->session = ((void *)0);


  fdwState->startup_cost = 10000.0;


  if (baserel->pages > 0)
    ntuples = baserel->tuples;




  if (ntuples != -1) {

    ntuples = ntuples * clauselist_selectivity (root, baserel->baserestrictinfo, 0, JOIN_INNER, ((void *)0));

    ntuples = clamp_row_est (ntuples);
    baserel->rows = ntuples;
  }


  fdwState->total_cost = fdwState->startup_cost + baserel->rows * 10.0;


  baserel->fdw_private = (void *) fdwState;
}




void
db2GetForeignPaths (PlannerInfo * root, RelOptInfo * baserel, Oid foreigntableid)
{
  struct DB2FdwState *fdwState = (struct DB2FdwState *) baserel->fdw_private;





  StringInfoData orderedquery;
  List *usable_pathkeys = ((List *) ((void *)0));
  ListCell *cell;
  char *delim = " ";

  initStringInfo (&orderedquery);

  for ((cell) = list_head(root->query_pathkeys); (cell) != ((void *)0); (cell) = ((cell)->next)) {
    PathKey *pathkey = (PathKey *) ((cell)->data.ptr_value);
    EquivalenceClass *pathkey_ec = pathkey->pk_eclass;
    Expr *em_expr = ((void *)0);
    char *sort_clause;
    Oid em_type;
    _Bool can_pushdown;





    can_pushdown = !pathkey_ec->ec_has_volatile && ((em_expr = find_em_expr_for_rel (pathkey_ec, baserel)) != ((void *)0));

    if (can_pushdown) {
      em_type = exprType ((Node *) em_expr);


      if (em_type != 20 && em_type != 21 && em_type != 23 && em_type != 26
   && em_type != 700 && em_type != 701 && em_type != 1700 && em_type != 1082
   && em_type != 1114 && em_type != 1184
   && em_type != 1083 && em_type != 1266
          && em_type != 1186)
 can_pushdown = 0;
    }

    if (can_pushdown && ((sort_clause = deparseExpr (fdwState->session, baserel, em_expr, fdwState->db2Table, &(fdwState->params))) != ((void *)0))) {

      usable_pathkeys = lappend (usable_pathkeys, pathkey);


      appendStringInfoString (&orderedquery, delim);
      appendStringInfoString (&orderedquery, sort_clause);
      delim = ", ";

      if (pathkey->pk_strategy == 1)
 appendStringInfoString (&orderedquery, " ASC");
      else
 appendStringInfoString (&orderedquery, " DESC");

      if (pathkey->pk_nulls_first)
 appendStringInfoString (&orderedquery, " NULLS FIRST");
      else
 appendStringInfoString (&orderedquery, " NULLS LAST");
    }
    else {







      list_free (usable_pathkeys);
      usable_pathkeys = ((List *) ((void *)0));
      break;
    }
  }


  if (usable_pathkeys != ((List *) ((void *)0)))
    fdwState->order_clause = orderedquery.data;


  add_path (baserel, (Path *) create_foreignscan_path (root, baserel,
             ((void *)0),
             baserel->rows, fdwState->startup_cost, fdwState->total_cost, usable_pathkeys, ((void *)0),
             ((void *)0),
             ((List *) ((void *)0)))
    );
}






static void
db2GetForeignJoinPaths (PlannerInfo * root, RelOptInfo * joinrel, RelOptInfo * outerrel, RelOptInfo * innerrel, JoinType jointype, JoinPathExtraData * extra)
{
  struct DB2FdwState *fdwState;
  ForeignPath *joinpath;
  double joinclauses_selectivity;
  double rows;
  Cost startup_cost;
  Cost total_cost;






  if (root->parse->commandType != CMD_SELECT) {
    do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 793, __func__); elog_finish(13, "db2_fdw: don't push down join because it is no SELECT"); if (__builtin_constant_p(13) && (13) >= 20) __builtin_unreachable(); } while(0);
    return;
  }





  if (!((outerrel)->reloptkind == RELOPT_BASEREL || (outerrel)->reloptkind == RELOPT_OTHER_MEMBER_REL) || !((innerrel)->reloptkind == RELOPT_BASEREL || (innerrel)->reloptkind == RELOPT_OTHER_MEMBER_REL))
    return;


  if (joinrel->fdw_private)
    return;







  fdwState = (struct DB2FdwState *) palloc0 (sizeof (struct DB2FdwState));

  joinrel->fdw_private = fdwState;


  if (!foreign_join_ok (root, joinrel, jointype, outerrel, innerrel, extra))
    return;


  if (outerrel->pages > 0 && innerrel->pages > 0) {

    joinclauses_selectivity = clauselist_selectivity (root, fdwState->joinclauses, 0, JOIN_INNER, extra->sjinfo);
    rows = clamp_row_est (innerrel->tuples * outerrel->tuples * joinclauses_selectivity);
  }
  else {

    rows = 1000.0;
  }


  startup_cost = 10000.0;


  total_cost = startup_cost + rows * 10.0;


  joinrel->rows = rows;
  fdwState->startup_cost = startup_cost;
  fdwState->total_cost = total_cost;


  joinpath = create_foreignscan_path (root, joinrel, ((void *)0),
          rows, startup_cost, total_cost, ((List *) ((void *)0)),
          ((void *)0),
          ((void *)0),
          ((List *) ((void *)0)));


  add_path (joinrel, (Path *) joinpath);
}







ForeignScan * db2GetForeignPlan (PlannerInfo * root, RelOptInfo * foreignrel, Oid foreigntableid, ForeignPath * best_path, List * tlist, List * scan_clauses , Plan * outer_plan)
{
  struct DB2FdwState *fdwState = (struct DB2FdwState *) foreignrel->fdw_private;
  List *fdw_private = ((List *) ((void *)0));
  int i;
  _Bool need_keys = 0, for_update = 0, has_trigger;
  Relation rel;
  Index scan_relid;
  List *local_exprs = fdwState->local_conds;
  List *fdw_scan_tlist = ((List *) ((void *)0));


  if (((foreignrel)->reloptkind == RELOPT_BASEREL || (foreignrel)->reloptkind == RELOPT_OTHER_MEMBER_REL)) {

    scan_relid = foreignrel->relid;


    if (foreignrel->relid == root->parse->resultRelation && (root->parse->commandType == CMD_UPDATE || root->parse->commandType == CMD_DELETE)) {

      need_keys = 1;
    }


    if (need_keys || get_parse_rowmark (root->parse, foreignrel->relid)) {

      for_update = 1;
    }

    if (need_keys) {

      for (i = 0; i < fdwState->db2Table->ncols; ++i)
 if (fdwState->db2Table->cols[i]->pkey)
   fdwState->db2Table->cols[i]->used = 1;
    }





    rel = table_open (foreigntableid, 0);


    has_trigger = (foreignrel->relid == root->parse->resultRelation) && rel->trigdesc && ((root->parse->commandType == CMD_UPDATE && rel->trigdesc->trig_update_after_row)
             || (root->parse->commandType == CMD_DELETE && rel->trigdesc->trig_delete_after_row));

    table_close (rel, 0);

    if (has_trigger) {

      for (i = 0; i < fdwState->db2Table->ncols; ++i)
 if (fdwState->db2Table->cols[i]->pgname)
   fdwState->db2Table->cols[i]->used = 1;
    }
  }
  else {

    scan_relid = 0;
# 926 "db2_fdw.c"
    ((void)1);


    fdw_scan_tlist = build_tlist_to_deparse (foreignrel);
# 939 "db2_fdw.c"
    if (outer_plan) {
      ListCell *lc;

      outer_plan->targetlist = fdw_scan_tlist;

      for ((lc) = list_head(local_exprs); (lc) != ((void *)0); (lc) = ((lc)->next)) {
 Join *join_plan = (Join *) outer_plan;
 Node *qual = ((lc)->data.ptr_value);

 outer_plan->qual = list_delete (outer_plan->qual, qual);





 if (join_plan->jointype == JOIN_INNER)
   join_plan->joinqual = list_delete (join_plan->joinqual, qual);
      }
    }
  }


  fdwState->query = createQuery (fdwState, foreignrel, for_update, best_path->path.pathkeys);
  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 962, __func__); elog_finish(14, "db2_fdw: remote query is: %s", fdwState->query); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);


  for (i = 0; i < fdwState->db2Table->ncols; ++i)
    if (fdwState->db2Table->cols[i]->used)
      checkDataType (fdwState->db2Table->cols[i]->db2type,
       fdwState->db2Table->cols[i]->scale, fdwState->db2Table->cols[i]->pgtype, fdwState->db2Table->pgname, fdwState->db2Table->cols[i]->pgname);

  fdw_private = serializePlanData (fdwState);
# 979 "db2_fdw.c"
  return make_foreignscan (tlist, local_exprs, scan_relid, fdwState->params, fdw_private
      , fdw_scan_tlist, ((List *) ((void *)0)),
      outer_plan
    );
}

_Bool
db2AnalyzeForeignTable (Relation relation, AcquireSampleRowsFunc * func, BlockNumber * totalpages)
{
  *func = acquireSampleRowsFunc;

  *totalpages = 42;

  return 1;
}

void db2Explain (void * fdw, ExplainState * es)
{
  FILE *fp;
  char path[1035];
  char execution_cmd[300];
  struct DB2FdwState * fdw_state = (struct DB2FdwState *) fdw;

  memset(execution_cmd,0x00,sizeof(execution_cmd));
  if (es->verbose) {
    if (strlen(fdw_state->user)){
      pg_sprintf(execution_cmd,"db2expln -t -d %s -u %s %s -q \"%s\" ",fdw_state->dbserver,fdw_state->user,fdw_state->password,fdw_state->query);
    }else{
      pg_sprintf(execution_cmd,"db2expln -t -d %s -q \"%s\" ",fdw_state->dbserver,fdw_state->query);
    }
  } else {
    if (strlen(fdw_state->user)){
      pg_sprintf(execution_cmd,"db2expln -t -d %s -u %s %s -q \"%s\" |grep -E \"Estimated Cost|Estimated Cardinality\" ",fdw_state->dbserver,fdw_state->user,fdw_state->password,fdw_state->query);
    }else{
      pg_sprintf(execution_cmd,"db2expln -t -d %s -q \"%s\" |grep -E \"Estimated Cost|Estimated Cardinality\" ",fdw_state->dbserver,fdw_state->query);
    }
  }


  fp = popen(execution_cmd, "r");
  if (fp == ((void *)0)) {
    do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1020, __func__); elog_finish(20, "db2_fdw: Failed to run command"); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    exit(1);
  }


  while (fgets(path, sizeof(path)-1, fp) != ((void *)0)) {
    path[strlen (path) - 1] = '\0';
    ExplainPropertyText ("DB2 plan", path, es);
  }

  pclose(fp);
}





void
db2ExplainForeignScan (ForeignScanState * node, ExplainState * es)
{
  struct DB2FdwState *fdw_state = (struct DB2FdwState *) node->fdw_state;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1042, __func__); elog_finish(14, "db2_fdw: explain foreign table scan"); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);


  ExplainPropertyText ("DB2 query", fdw_state->query, es);
  db2Explain (fdw_state, es);
}
# 1056 "db2_fdw.c"
void
db2BeginForeignScan (ForeignScanState * node, int eflags)
{
  ForeignScan *fsplan = (ForeignScan *) node->ss.ps.plan;
  List *fdw_private = fsplan->fdw_private;
  List *exec_exprs;
  ListCell *cell;
  int index;
  struct paramDesc *paramDesc;
  struct DB2FdwState *fdw_state;


  fdw_state = deserializePlanData (fdw_private);
  node->fdw_state = (void *) fdw_state;





  exec_exprs = (List *) ExecInitExprList (fsplan->fdw_exprs, (PlanState *) node);



  index = 0;
  for ((cell) = list_head(exec_exprs); (cell) != ((void *)0); (cell) = ((cell)->next)) {
    ExprState *expr = (ExprState *) ((cell)->data.ptr_value);
    char parname[10];


    ++index;
    if (expr == ((void *)0))
      continue;


    paramDesc = (struct paramDesc *) palloc (sizeof (struct paramDesc));
    pg_snprintf (parname, 10, ":p%d", index);
    paramDesc->name = pstrdup (parname);
    paramDesc->type = exprType ((Node *) (expr->expr));

    if (paramDesc->type == 25 || paramDesc->type == 1043
 || paramDesc->type == 1042 || paramDesc->type == 18 || paramDesc->type == 1082 || paramDesc->type == 1114 || paramDesc->type == 1184 || paramDesc->type == 1083 || paramDesc->type == 1266)
      paramDesc->bindType = BIND_STRING;
    else
      paramDesc->bindType = BIND_NUMBER;

    paramDesc->value = ((void *)0);
    paramDesc->node = expr;
    paramDesc->bindh = ((void *)0);
    paramDesc->colnum = -1;
    paramDesc->next = fdw_state->paramList;
    fdw_state->paramList = paramDesc;
  }


  if (strstr (fdw_state->query, ":now") != ((void *)0)) {
    paramDesc = (struct paramDesc *) palloc (sizeof (struct paramDesc));
    paramDesc->name = pstrdup (":now");
    paramDesc->type = 1184;
    paramDesc->bindType = BIND_STRING;
    paramDesc->value = ((void *)0);
    paramDesc->node = ((void *)0);
    paramDesc->bindh = ((void *)0);
    paramDesc->colnum = -1;
    paramDesc->next = fdw_state->paramList;
    fdw_state->paramList = paramDesc;
  }

  if (node->ss.ss_currentRelation)
    do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1124, __func__); elog_finish(14, "db2_fdw: begin foreign table scan on %d", ((node->ss.ss_currentRelation)->rd_id)); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);
  else
    do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1126, __func__); elog_finish(14, "db2_fdw: begin foreign join"); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);


  fdw_state->session = db2GetSession (fdw_state->dbserver, fdw_state->user, fdw_state->password, fdw_state->nls_lang, fdw_state->db2Table->pgname,
          GetCurrentTransactionNestLevel ()
    );


  fdw_state->rowcount = 0;
}
# 1147 "db2_fdw.c"
TupleTableSlot *
db2IterateForeignScan (ForeignScanState * node)
{
  TupleTableSlot *slot = node->ss.ss_ScanTupleSlot;
  ExprContext *econtext = node->ss.ps.ps_ExprContext;
  int have_result;
  struct DB2FdwState *fdw_state = (struct DB2FdwState *) node->fdw_state;

  if (db2IsStatementOpen (fdw_state->session)) {
    do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1156, __func__); elog_finish(12, "db2_fdw: get next row in foreign table scan"); if (__builtin_constant_p(12) && (12) >= 20) __builtin_unreachable(); } while(0);


    have_result = db2FetchNext (fdw_state->session);
  }
  else {

    char *paramInfo = setSelectParameters (fdw_state->paramList, econtext);


    do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1166, __func__); elog_finish(14, "db2_fdw: execute query in foreign table scan %s", paramInfo); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);

    db2PrepareQuery (fdw_state->session, fdw_state->query, fdw_state->db2Table, fdw_state->prefetch);
    have_result = db2ExecuteQuery (fdw_state->session, fdw_state->db2Table, fdw_state->paramList);
  }


  ExecClearTuple (slot);

  if (have_result) {

    ++fdw_state->rowcount;


    convertTuple (fdw_state, slot->tts_values, slot->tts_isnull, 0);


    ExecStoreVirtualTuple (slot);
  }
  else {

    db2CloseStatement (fdw_state->session);
  }

  return slot;
}





void
db2EndForeignScan (ForeignScanState * node)
{
  struct DB2FdwState *fdw_state = (struct DB2FdwState *) node->fdw_state;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1202, __func__); elog_finish(14, "db2_fdw: end foreign table scan"); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);


  db2CloseStatement (fdw_state->session);
  pfree (fdw_state->session);
  fdw_state->session = ((void *)0);
}






void
db2ReScanForeignScan (ForeignScanState * node)
{
  struct DB2FdwState *fdw_state = (struct DB2FdwState *) node->fdw_state;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1220, __func__); elog_finish(14, "db2_fdw: restart foreign table scan"); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);


  db2CloseStatement (fdw_state->session);


  fdw_state->rowcount = 0;
}





void
db2AddForeignUpdateTargets (Query * parsetree, RangeTblEntry * target_rte, Relation target_relation)
{
  Oid relid = ((target_relation)->rd_id);
  TupleDesc tupdesc = target_relation->rd_att;
  int i;
  _Bool has_key = 0;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1241, __func__); elog_finish(14, "db2_fdw: add target columns for update on %d", relid); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);


  for (i = 0; i < tupdesc->natts; ++i) {
    Form_pg_attribute att = (&(tupdesc)->attrs[(i)]);
    AttrNumber attrno = att->attnum;
    List *options;
    ListCell *option;


    options = GetForeignColumnOptions (relid, attrno);
    for ((option) = list_head(options); (option) != ((void *)0); (option) = ((option)->next)) {
      DefElem *def = (DefElem *) ((option)->data.ptr_value);


      if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("key") && (__s1_len = strlen (def->defname), __s2_len = strlen ("key"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("key") + 1) - (size_t)(const void *)("key") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "key") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("key") && ((size_t)(const void *)(("key") + 1) - (size_t)(const void *)("key") == 1) ? __builtin_strcmp (def->defname, "key") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("key"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("key") && ((size_t)(const void *)(("key") + 1) - (size_t)(const void *)("key") == 1) && (__s2_len = strlen ("key"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "key") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("key"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("key"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("key"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("key"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "key")))); }) == 0) {
 if (optionIsTrue (((Value *) (def->arg))->val.str)) {
   Var *var;
   TargetEntry *tle;


   var = makeVar (parsetree->resultRelation, attrno, att->atttypid, att->atttypmod, att->attcollation, 0);


   tle = makeTargetEntry ((Expr *) var, list_length (parsetree->targetList) + 1, pstrdup (((att->attname).data)), 1);


   parsetree->targetList = lappend (parsetree->targetList, tle);

   has_key = 1;
 }
      }
      else {
 do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1274, __func__); elog_finish(20, "impossible column option \"%s\"", def->defname); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
      }
    }
  }

  if (!has_key)
    do { int __errno_location __attribute__((unused)); if (errstart(20,



 "db2_fdw.c"
# 1280 "db2_fdw.c"
    ,



 1284
# 1280 "db2_fdw.c"
    , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('L') - '0') & 0x3F) << 24))), errmsg ("no primary key column specified for foreign DB2 table"), errdetail ("For UPDATE or DELETE, at least one foreign table column must be marked as primary key column."), errhint ("Set the option \"%s\" on the columns that belong to the primary key.", "key")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)



                                                                                                  ;
}







List *
db2PlanForeignModify (PlannerInfo * root, ModifyTable * plan, Index resultRelation, int subplan_index)
{
  CmdType operation = plan->operation;
  RangeTblEntry *rte = ((root)->simple_rte_array ? (root)->simple_rte_array[resultRelation] : ((RangeTblEntry *) list_nth((root)->parse->rtable, (resultRelation)-1)));
  Relation rel = ((void *)0);
  StringInfoData sql;
  List *targetAttrs = ((List *) ((void *)0));
  List *returningList = ((List *) ((void *)0));
  struct DB2FdwState *fdwState;
  int attnum, i;
  ListCell *cell;
  _Bool has_trigger = 0, firstcol;
  struct paramDesc *param;
  char paramName[10];
  TupleDesc tupdesc;
  Bitmapset *tmpset;
  AttrNumber col;


  if (plan->onConflictAction != ONCONFLICT_NONE)
    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 1314, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('L') - '0') & 0x3F) << 24))), errmsg ("INSERT with ON CONFLICT clause is not supported")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);


  if (resultRelation < root->simple_rel_array_size && root->simple_rel_array[resultRelation] != ((void *)0)) {

    fdwState = copyPlanData ((struct DB2FdwState *) (root->simple_rel_array[resultRelation]->fdw_private));
  }
  else {

    fdwState = getFdwState (rte->relid, ((void *)0));
  }

  initStringInfo (&sql);





  rel = table_open (rte->relid, 0);


  switch (operation) {
  case CMD_INSERT:
# 1345 "db2_fdw.c"
    tupdesc = ((rel)->rd_att);

    for (attnum = 1; attnum <= tupdesc->natts; attnum++) {
      Form_pg_attribute attr = (&(tupdesc)->attrs[(attnum - 1)]);

      if (!attr->attisdropped)
 targetAttrs = lappend_int (targetAttrs, attnum);
    }


    has_trigger = rel->trigdesc && rel->trigdesc->trig_insert_after_row;

    break;
  case CMD_UPDATE:
    tmpset = bms_copy (rte->updatedCols);

    while ((col = bms_first_member (tmpset)) >= 0) {
      col += (-7);
      if (col <= 0)
 do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1364, __func__); elog_finish(20, "system-column update is not supported"); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
      targetAttrs = lappend_int (targetAttrs, col);
    }


    has_trigger = rel->trigdesc && rel->trigdesc->trig_update_after_row;

    break;
  case CMD_DELETE:


    has_trigger = rel->trigdesc && rel->trigdesc->trig_delete_after_row;

    break;
  default:
    do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1379, __func__); elog_finish(20, "unexpected operation: %d", (int) operation); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
  }

  table_close (rel, 0);


  if (has_trigger) {

    for (i = 0; i < fdwState->db2Table->ncols; ++i)
      if (fdwState->db2Table->cols[i]->pgname != ((void *)0)) {

 if (fdwState->db2Table->cols[i]->db2type == SQL_TYPE_BIG)
   do { int __errno_location __attribute__((unused)); if (errstart(20,



 "db2_fdw.c"
# 1391 "db2_fdw.c"
   ,



 1395
# 1391 "db2_fdw.c"
   , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("columns with DB2 type LONG or LONG RAW cannot be used in RETURNING clause"), errdetail ("Column \"%s\" of foreign table \"%s\" is of DB2 type LONG%s.", fdwState->db2Table->cols[i]->pgname, fdwState->db2Table->pgname, fdwState->db2Table->cols[i]->db2type == SQL_TYPE_BIG ? "" : " RAW")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)



                                                                                                                                                ;

 fdwState->db2Table->cols[i]->used = 1;
      }
  }
  else {
    Bitmapset *attrs_used = ((void *)0);


    if (plan->returningLists)
      returningList = (List *) list_nth (plan->returningLists, subplan_index);

    if (returningList != ((List *) ((void *)0))) {

      pull_varattnos ((Node *) returningList, resultRelation, &attrs_used);


      for (i = 0; i < fdwState->db2Table->ncols; ++i) {

 if (fdwState->db2Table->cols[i]->pgname == ((void *)0))
   continue;

 if (bms_is_member (fdwState->db2Table->cols[i]->pgattnum - (-7), attrs_used)) {

   fdwState->db2Table->cols[i]->used = 1;
 }
      }
    }
  }


  switch (operation) {
  case CMD_INSERT:
    appendStringInfo (&sql, "INSERT INTO %s (", fdwState->db2Table->name);

    firstcol = 1;
    for (i = 0; i < fdwState->db2Table->ncols; ++i) {

      if (fdwState->db2Table->cols[i]->pgname == ((void *)0))
 continue;

      if (firstcol)
 firstcol = 0;
      else
 appendStringInfo (&sql, ", ");
      appendStringInfo (&sql, "%s", fdwState->db2Table->cols[i]->name);
    }

    appendStringInfo (&sql, ") VALUES (");

    firstcol = 1;
    for (i = 0; i < fdwState->db2Table->ncols; ++i) {

      if (fdwState->db2Table->cols[i]->pgname == ((void *)0))
 continue;


      checkDataType (fdwState->db2Table->cols[i]->db2type,
       fdwState->db2Table->cols[i]->scale, fdwState->db2Table->cols[i]->pgtype, fdwState->db2Table->pgname, fdwState->db2Table->cols[i]->pgname);


      pg_snprintf (paramName, 9, ":p%d", fdwState->db2Table->cols[i]->pgattnum);
      addParam (&fdwState->paramList, paramName, fdwState->db2Table->cols[i]->pgtype, fdwState->db2Table->cols[i]->db2type, i);


      if (firstcol)
 firstcol = 0;
      else
 appendStringInfo (&sql, ", ");

      appendAsType (&sql, paramName, fdwState->db2Table->cols[i]->pgtype);
    }

    appendStringInfo (&sql, ")");

    break;
  case CMD_UPDATE:
    appendStringInfo (&sql, "UPDATE %s SET ", fdwState->db2Table->name);

    firstcol = 1;
    i = 0;
    for ((cell) = list_head(targetAttrs); (cell) != ((void *)0); (cell) = ((cell)->next)) {

      while (i < fdwState->db2Table->ncols && fdwState->db2Table->cols[i]->pgattnum < ((cell)->data.int_value))
 ++i;
      if (i == fdwState->db2Table->ncols)
 break;


      if (fdwState->db2Table->cols[i]->pgtype == 0)
 continue;


      checkDataType (fdwState->db2Table->cols[i]->db2type,
       fdwState->db2Table->cols[i]->scale, fdwState->db2Table->cols[i]->pgtype, fdwState->db2Table->pgname, fdwState->db2Table->cols[i]->pgname);


      pg_snprintf (paramName, 9, ":p%d", ((cell)->data.int_value));
      addParam (&fdwState->paramList, paramName, fdwState->db2Table->cols[i]->pgtype, fdwState->db2Table->cols[i]->db2type, i);


      if (firstcol)
 firstcol = 0;
      else
 appendStringInfo (&sql, ", ");

      appendStringInfo (&sql, "%s = ", fdwState->db2Table->cols[i]->name);
      appendAsType (&sql, paramName, fdwState->db2Table->cols[i]->pgtype);
    }


    if (firstcol)
      do { int __errno_location __attribute__((unused)); if (errstart(20,

 "db2_fdw.c"
# 1507 "db2_fdw.c"
      ,

 1509
# 1507 "db2_fdw.c"
      , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('L') - '0') & 0x3F) << 24))), errmsg ("no DB2 column modified by UPDATE"), errdetail ("The UPDATE statement only changes colums that do not exist in the DB2 table.")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)

                                                                                                                                           ;

    break;
  case CMD_DELETE:
    appendStringInfo (&sql, "DELETE FROM %s", fdwState->db2Table->name);

    break;
  default:
    do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1517, __func__); elog_finish(20, "unexpected operation: %d", (int) operation); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
  }

  if (operation == CMD_UPDATE || operation == CMD_DELETE) {


    firstcol = 1;
    for (i = 0; i < fdwState->db2Table->ncols; ++i) {
      if (fdwState->db2Table->cols[i]->pkey) {

 pg_snprintf (paramName, 9, ":k%d", fdwState->db2Table->cols[i]->pgattnum);
 addParam (&fdwState->paramList, paramName, fdwState->db2Table->cols[i]->pgtype, fdwState->db2Table->cols[i]->db2type, i);


 if (firstcol) {
   appendStringInfo (&sql, " WHERE");
   firstcol = 0;
 }
 else
   appendStringInfo (&sql, " AND");

 appendStringInfo (&sql, " %s = ", fdwState->db2Table->cols[i]->name);
 appendAsType (&sql, paramName, fdwState->db2Table->cols[i]->pgtype);
      }
    }
  }


  firstcol = 1;
  for (i = 0; i < fdwState->db2Table->ncols; ++i)
    if (fdwState->db2Table->cols[i]->used) {
      if (firstcol) {
 firstcol = 0;
 appendStringInfo (&sql, " RETURNING ");
      }
      else
 appendStringInfo (&sql, ", ");
      appendStringInfo (&sql, "%s", fdwState->db2Table->cols[i]->name);
    }


  firstcol = 1;
  for (i = 0; i < fdwState->db2Table->ncols; ++i)
    if (fdwState->db2Table->cols[i]->used) {

      checkDataType (fdwState->db2Table->cols[i]->db2type,
       fdwState->db2Table->cols[i]->scale, fdwState->db2Table->cols[i]->pgtype, fdwState->db2Table->pgname, fdwState->db2Table->cols[i]->pgname);


      param = (struct paramDesc *) palloc (sizeof (struct paramDesc));
      pg_snprintf (paramName, 9, ":r%d", fdwState->db2Table->cols[i]->pgattnum);
      param->name = pstrdup (paramName);
      param->type = fdwState->db2Table->cols[i]->pgtype;
      param->bindType = BIND_OUTPUT;
      param->value = ((void *)0);
      param->node = ((void *)0);
      param->bindh = ((void *)0);
      param->colnum = i;
      param->next = fdwState->paramList;
      fdwState->paramList = param;

      if (firstcol) {
 firstcol = 0;
 appendStringInfo (&sql, " INTO ");
      }
      else
 appendStringInfo (&sql, ", ");
      appendStringInfo (&sql, "%s", paramName);
    }

  fdwState->query = sql.data;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1589, __func__); elog_finish(14, "db2_fdw: remote statement is: %s", fdwState->query); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);


  return serializePlanData (fdwState);
}
# 1602 "db2_fdw.c"
void
db2BeginForeignModify (ModifyTableState * mtstate, ResultRelInfo * rinfo, List * fdw_private, int subplan_index, int eflags)
{
  struct DB2FdwState *fdw_state = deserializePlanData (fdw_private);
  EState *estate = mtstate->ps.state;
  struct paramDesc *param;
  HeapTuple tuple;
  int i;
  Plan *subplan = mtstate->mt_plans[subplan_index]->plan;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1612, __func__); elog_finish(14, "db2_fdw: begin foreign table modify on %d", ((rinfo->ri_RelationDesc)->rd_id)); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);

  rinfo->ri_FdwState = fdw_state;


  fdw_state->session = db2GetSession (fdw_state->dbserver, fdw_state->user, fdw_state->password, fdw_state->nls_lang, fdw_state->db2Table->pgname, GetCurrentTransactionNestLevel ()
    );

  db2PrepareQuery (fdw_state->session, fdw_state->query, fdw_state->db2Table, 0);


  output_funcs = (regproc *) palloc0 (fdw_state->db2Table->ncols * sizeof (regproc *));
  for (param = fdw_state->paramList; param != ((void *)0); param = param->next) {

    if (param->bindType == BIND_OUTPUT)
      continue;

    tuple = SearchSysCache1 (TYPEOID, ((Datum) (fdw_state->db2Table->cols[param->colnum]->pgtype)));
    if (!((const void*)(tuple) != ((void *)0)))
      do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1631, __func__); elog_finish(20, "cache lookup failed for type %u", fdw_state->db2Table->cols[param->colnum]->pgtype); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    output_funcs[param->colnum] = ((Form_pg_type) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->typoutput;
    ReleaseSysCache (tuple);
  }


  for (i = 0; i < fdw_state->db2Table->ncols; ++i) {
    if (!fdw_state->db2Table->cols[i]->pkey)
      continue;


    fdw_state->db2Table->cols[i]->pkey = ExecFindJunkAttributeInTlist (subplan->targetlist, fdw_state->db2Table->cols[i]->pgname);
  }


  fdw_state->temp_cxt = (((void) ({ do { _Static_assert(__builtin_constant_p("db2_fdw temporary data"), "memory context names must be constant strings"); } while(0); 1; })), AllocSetContextCreateInternal(estate->es_query_cxt, "db2_fdw temporary data", 0, (1 * 1024), (8 * 1024)));
}






TupleTableSlot *
db2ExecForeignInsert (EState * estate, ResultRelInfo * rinfo, TupleTableSlot * slot, TupleTableSlot * planSlot)
{
  struct DB2FdwState *fdw_state = (struct DB2FdwState *) rinfo->ri_FdwState;
  int rows;
  MemoryContext oldcontext;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1661, __func__); elog_finish(12, "db2_fdw: execute foreign table insert on %d", ((rinfo->ri_RelationDesc)->rd_id)); if (__builtin_constant_p(12) && (12) >= 20) __builtin_unreachable(); } while(0);

  ++fdw_state->rowcount;
  dml_in_transaction = 1;

  MemoryContextReset (fdw_state->temp_cxt);
  oldcontext = MemoryContextSwitchTo (fdw_state->temp_cxt);


  setModifyParameters (fdw_state->paramList, slot, planSlot, fdw_state->db2Table, fdw_state->session);


  rows = db2ExecuteQuery (fdw_state->session, fdw_state->db2Table, fdw_state->paramList);

  if (rows != 1)
    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 1676, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('L') - '0') & 0x3F) << 24))), errmsg ("INSERT on DB2 table added %d rows instead of one in iteration %lu", rows, fdw_state->rowcount)); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);

  MemoryContextSwitchTo (oldcontext);


  ExecClearTuple (slot);


  convertTuple (fdw_state, slot->tts_values, slot->tts_isnull, 0);


  ExecStoreVirtualTuple (slot);

  return slot;
}






TupleTableSlot *
db2ExecForeignUpdate (EState * estate, ResultRelInfo * rinfo, TupleTableSlot * slot, TupleTableSlot * planSlot)
{
  struct DB2FdwState *fdw_state = (struct DB2FdwState *) rinfo->ri_FdwState;
  int rows;
  MemoryContext oldcontext;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1704, __func__); elog_finish(12, "db2_fdw: execute foreign table update on %d", ((rinfo->ri_RelationDesc)->rd_id)); if (__builtin_constant_p(12) && (12) >= 20) __builtin_unreachable(); } while(0);

  ++fdw_state->rowcount;
  dml_in_transaction = 1;

  MemoryContextReset (fdw_state->temp_cxt);
  oldcontext = MemoryContextSwitchTo (fdw_state->temp_cxt);


  setModifyParameters (fdw_state->paramList, slot, planSlot, fdw_state->db2Table, fdw_state->session);


  rows = db2ExecuteQuery (fdw_state->session, fdw_state->db2Table, fdw_state->paramList);

  if (rows != 1)
    do { int __errno_location __attribute__((unused)); if (errstart(20,


 "db2_fdw.c"
# 1719 "db2_fdw.c"
    ,


 1722
# 1719 "db2_fdw.c"
    , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('L') - '0') & 0x3F) << 24))), errmsg ("UPDATE on DB2 table changed %d rows instead of one in iteration %lu", rows, fdw_state->rowcount), errhint ("This probably means that you did not set the \"key\" option on all primary key columns.")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)


                                                                                                            ;

  MemoryContextSwitchTo (oldcontext);


  ExecClearTuple (slot);


  convertTuple (fdw_state, slot->tts_values, slot->tts_isnull, 0);


  ExecStoreVirtualTuple (slot);

  return slot;
}






TupleTableSlot *
db2ExecForeignDelete (EState * estate, ResultRelInfo * rinfo, TupleTableSlot * slot, TupleTableSlot * planSlot)
{
  struct DB2FdwState *fdw_state = (struct DB2FdwState *) rinfo->ri_FdwState;
  int rows;
  MemoryContext oldcontext;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1750, __func__); elog_finish(12, "db2_fdw: execute foreign table delete on %d", ((rinfo->ri_RelationDesc)->rd_id)); if (__builtin_constant_p(12) && (12) >= 20) __builtin_unreachable(); } while(0);

  ++fdw_state->rowcount;
  dml_in_transaction = 1;

  MemoryContextReset (fdw_state->temp_cxt);
  oldcontext = MemoryContextSwitchTo (fdw_state->temp_cxt);


  setModifyParameters (fdw_state->paramList, slot, planSlot, fdw_state->db2Table, fdw_state->session);


  rows = db2ExecuteQuery (fdw_state->session, fdw_state->db2Table, fdw_state->paramList);

  if (rows != 1)
    do { int __errno_location __attribute__((unused)); if (errstart(20,


 "db2_fdw.c"
# 1765 "db2_fdw.c"
    ,


 1768
# 1765 "db2_fdw.c"
    , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('L') - '0') & 0x3F) << 24))), errmsg ("DELETE on DB2 table removed %d rows instead of one in iteration %lu", rows, fdw_state->rowcount), errhint ("This probably means that you did not set the \"key\" option on all primary key columns.")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)


                                                                                                            ;

  MemoryContextSwitchTo (oldcontext);


  ExecClearTuple (slot);


  convertTuple (fdw_state, slot->tts_values, slot->tts_isnull, 0);


  ExecStoreVirtualTuple (slot);

  return slot;
}





void
db2EndForeignModify (EState * estate, ResultRelInfo * rinfo)
{
  struct DB2FdwState *fdw_state = (struct DB2FdwState *) rinfo->ri_FdwState;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1793, __func__); elog_finish(14, "db2_fdw: end foreign table modify on %d", ((rinfo->ri_RelationDesc)->rd_id)); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);

  MemoryContextDelete (fdw_state->temp_cxt);


  db2CloseStatement (fdw_state->session);
  pfree (fdw_state->session);
  fdw_state->session = ((void *)0);
}






void
db2ExplainForeignModify (ModifyTableState * mtstate, ResultRelInfo * rinfo, List * fdw_private, int subplan_index, struct ExplainState *es)
{
  struct DB2FdwState *fdw_state = (struct DB2FdwState *) rinfo->ri_FdwState;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1813, __func__); elog_finish(14, "db2_fdw: explain foreign table modify on %d", ((rinfo->ri_RelationDesc)->rd_id)); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);


  ExplainPropertyText ("DB2 statement", fdw_state->query, es);
}





int
db2IsForeignRelUpdatable (Relation rel)
{
  ListCell *cell;


  for ((cell) = list_head(GetForeignTable (((rel)->rd_id))->options); (cell) != ((void *)0); (cell) = ((cell)->next)) {
    DefElem *def = (DefElem *) ((cell)->data.ptr_value);
    char *value = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("readonly") && (__s1_len = strlen (def->defname), __s2_len = strlen ("readonly"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("readonly") + 1) - (size_t)(const void *)("readonly") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "readonly") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("readonly") && ((size_t)(const void *)(("readonly") + 1) - (size_t)(const void *)("readonly") == 1) ? __builtin_strcmp (def->defname, "readonly") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("readonly"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("readonly") && ((size_t)(const void *)(("readonly") + 1) - (size_t)(const void *)("readonly") == 1) && (__s2_len = strlen ("readonly"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "readonly") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("readonly"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("readonly"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("readonly"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("readonly"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "readonly")))); }) == 0 && optionIsTrue (value))
      return 0;
  }

  return (1 << CMD_UPDATE) | (1 << CMD_INSERT) | (1 << CMD_DELETE);
}





List *
db2ImportForeignSchema (ImportForeignSchemaStmt * stmt, Oid serverOid)
{
  ForeignServer *server;
  UserMapping *mapping;
  ForeignDataWrapper *wrapper;
  char *tabname, *colname, oldtabname[129] = { '\0' }, *foldedname;
  char *nls_lang = ((void *)0), *user = ((void *)0), *password = ((void *)0), *dbserver = ((void *)0);
  db2Type type;
  int charlen, typeprec, typescale, nullable, key, rc;
  List *options, *result = ((List *) ((void *)0));
  ListCell *cell;
  db2Session *session;
  fold_t foldcase = CASE_SMART;
  StringInfoData buf;
  _Bool readonly = 0, firstcol = 1;


  server = GetForeignServer (serverOid);
  mapping = GetUserMapping (GetUserId (), serverOid);
  wrapper = GetForeignDataWrapper (server->fdwid);


  options = wrapper->options;
  options = list_concat (options, server->options);
  options = list_concat (options, mapping->options);

  for ((cell) = list_head(options); (cell) != ((void *)0); (cell) = ((cell)->next)) {
    DefElem *def = (DefElem *) ((cell)->data.ptr_value);
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("nls_lang") && (__s1_len = strlen (def->defname), __s2_len = strlen ("nls_lang"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("nls_lang") + 1) - (size_t)(const void *)("nls_lang") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "nls_lang") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("nls_lang") && ((size_t)(const void *)(("nls_lang") + 1) - (size_t)(const void *)("nls_lang") == 1) ? __builtin_strcmp (def->defname, "nls_lang") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("nls_lang"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("nls_lang") && ((size_t)(const void *)(("nls_lang") + 1) - (size_t)(const void *)("nls_lang") == 1) && (__s2_len = strlen ("nls_lang"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "nls_lang") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("nls_lang"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("nls_lang"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("nls_lang"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("nls_lang"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "nls_lang")))); }) == 0)
      nls_lang = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("dbserver") && (__s1_len = strlen (def->defname), __s2_len = strlen ("dbserver"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("dbserver") + 1) - (size_t)(const void *)("dbserver") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "dbserver") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("dbserver") && ((size_t)(const void *)(("dbserver") + 1) - (size_t)(const void *)("dbserver") == 1) ? __builtin_strcmp (def->defname, "dbserver") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("dbserver"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("dbserver") && ((size_t)(const void *)(("dbserver") + 1) - (size_t)(const void *)("dbserver") == 1) && (__s2_len = strlen ("dbserver"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "dbserver") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("dbserver"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("dbserver"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("dbserver"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("dbserver"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "dbserver")))); }) == 0)
      dbserver = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("user") && (__s1_len = strlen (def->defname), __s2_len = strlen ("user"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("user") + 1) - (size_t)(const void *)("user") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "user") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("user") && ((size_t)(const void *)(("user") + 1) - (size_t)(const void *)("user") == 1) ? __builtin_strcmp (def->defname, "user") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("user"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("user") && ((size_t)(const void *)(("user") + 1) - (size_t)(const void *)("user") == 1) && (__s2_len = strlen ("user"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "user") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("user"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("user"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("user"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("user"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "user")))); }) == 0)
      user = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("password") && (__s1_len = strlen (def->defname), __s2_len = strlen ("password"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("password") + 1) - (size_t)(const void *)("password") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "password") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("password") && ((size_t)(const void *)(("password") + 1) - (size_t)(const void *)("password") == 1) ? __builtin_strcmp (def->defname, "password") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("password"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("password") && ((size_t)(const void *)(("password") + 1) - (size_t)(const void *)("password") == 1) && (__s2_len = strlen ("password"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "password") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("password"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("password"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("password"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("password"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "password")))); }) == 0)
      password = ((Value *) (def->arg))->val.str;
  }


  for ((cell) = list_head(stmt->options); (cell) != ((void *)0); (cell) = ((cell)->next)) {
    DefElem *def = (DefElem *) ((cell)->data.ptr_value);

    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("case") && (__s1_len = strlen (def->defname), __s2_len = strlen ("case"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("case") + 1) - (size_t)(const void *)("case") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "case") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("case") && ((size_t)(const void *)(("case") + 1) - (size_t)(const void *)("case") == 1) ? __builtin_strcmp (def->defname, "case") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("case"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("case") && ((size_t)(const void *)(("case") + 1) - (size_t)(const void *)("case") == 1) && (__s2_len = strlen ("case"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "case") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("case"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("case"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("case"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("case"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "case")))); }) == 0) {
      char *s = ((Value *) (def->arg))->val.str;
      if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (s) && __builtin_constant_p ("keep") && (__s1_len = strlen (s), __s2_len = strlen ("keep"), (!((size_t)(const void *)((s) + 1) - (size_t)(const void *)(s) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("keep") + 1) - (size_t)(const void *)("keep") == 1) || __s2_len >= 4)) ? __builtin_strcmp (s, "keep") : (__builtin_constant_p (s) && ((size_t)(const void *)((s) + 1) - (size_t)(const void *)(s) == 1) && (__s1_len = strlen (s), __s1_len < 4) ? (__builtin_constant_p ("keep") && ((size_t)(const void *)(("keep") + 1) - (size_t)(const void *)("keep") == 1) ? __builtin_strcmp (s, "keep") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("keep"); int __result = (((const unsigned char *) (const char *) (s))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (s))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (s))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (s))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("keep") && ((size_t)(const void *)(("keep") + 1) - (size_t)(const void *)("keep") == 1) && (__s2_len = strlen ("keep"), __s2_len < 4) ? (__builtin_constant_p (s) && ((size_t)(const void *)((s) + 1) - (size_t)(const void *)(s) == 1) ? __builtin_strcmp (s, "keep") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (s); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("keep"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("keep"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("keep"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("keep"))[3]); } } __result; }))) : __builtin_strcmp (s, "keep")))); }) == 0)
 foldcase = CASE_KEEP;
      else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (s) && __builtin_constant_p ("lower") && (__s1_len = strlen (s), __s2_len = strlen ("lower"), (!((size_t)(const void *)((s) + 1) - (size_t)(const void *)(s) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("lower") + 1) - (size_t)(const void *)("lower") == 1) || __s2_len >= 4)) ? __builtin_strcmp (s, "lower") : (__builtin_constant_p (s) && ((size_t)(const void *)((s) + 1) - (size_t)(const void *)(s) == 1) && (__s1_len = strlen (s), __s1_len < 4) ? (__builtin_constant_p ("lower") && ((size_t)(const void *)(("lower") + 1) - (size_t)(const void *)("lower") == 1) ? __builtin_strcmp (s, "lower") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("lower"); int __result = (((const unsigned char *) (const char *) (s))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (s))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (s))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (s))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("lower") && ((size_t)(const void *)(("lower") + 1) - (size_t)(const void *)("lower") == 1) && (__s2_len = strlen ("lower"), __s2_len < 4) ? (__builtin_constant_p (s) && ((size_t)(const void *)((s) + 1) - (size_t)(const void *)(s) == 1) ? __builtin_strcmp (s, "lower") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (s); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("lower"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("lower"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("lower"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("lower"))[3]); } } __result; }))) : __builtin_strcmp (s, "lower")))); }) == 0)
 foldcase = CASE_LOWER;
      else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (s) && __builtin_constant_p ("smart") && (__s1_len = strlen (s), __s2_len = strlen ("smart"), (!((size_t)(const void *)((s) + 1) - (size_t)(const void *)(s) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("smart") + 1) - (size_t)(const void *)("smart") == 1) || __s2_len >= 4)) ? __builtin_strcmp (s, "smart") : (__builtin_constant_p (s) && ((size_t)(const void *)((s) + 1) - (size_t)(const void *)(s) == 1) && (__s1_len = strlen (s), __s1_len < 4) ? (__builtin_constant_p ("smart") && ((size_t)(const void *)(("smart") + 1) - (size_t)(const void *)("smart") == 1) ? __builtin_strcmp (s, "smart") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("smart"); int __result = (((const unsigned char *) (const char *) (s))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (s))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (s))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (s))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("smart") && ((size_t)(const void *)(("smart") + 1) - (size_t)(const void *)("smart") == 1) && (__s2_len = strlen ("smart"), __s2_len < 4) ? (__builtin_constant_p (s) && ((size_t)(const void *)((s) + 1) - (size_t)(const void *)(s) == 1) ? __builtin_strcmp (s, "smart") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (s); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("smart"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("smart"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("smart"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("smart"))[3]); } } __result; }))) : __builtin_strcmp (s, "smart")))); }) == 0)
 foldcase = CASE_SMART;
      else
 do { int __errno_location __attribute__((unused)); if (errstart(20,

 "db2_fdw.c"
# 1895 "db2_fdw.c"
 ,

 1897
# 1895 "db2_fdw.c"
 , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('2') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("invalid value for option \"%s\"", def->defname), errhint ("Valid values in this context are: %s", "keep, lower, smart")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)

                                                                                                                                      ;
      continue;
    }
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("readonly") && (__s1_len = strlen (def->defname), __s2_len = strlen ("readonly"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("readonly") + 1) - (size_t)(const void *)("readonly") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "readonly") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("readonly") && ((size_t)(const void *)(("readonly") + 1) - (size_t)(const void *)("readonly") == 1) ? __builtin_strcmp (def->defname, "readonly") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("readonly"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("readonly") && ((size_t)(const void *)(("readonly") + 1) - (size_t)(const void *)("readonly") == 1) && (__s2_len = strlen ("readonly"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "readonly") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("readonly"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("readonly"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("readonly"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("readonly"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "readonly")))); }) == 0) {
      char *s = ((Value *) (def->arg))->val.str;
      if (pg_strcasecmp (s, "on") != 0 || pg_strcasecmp (s, "yes") != 0 || pg_strcasecmp (s, "true") != 0)
 readonly = 1;
      else if (pg_strcasecmp (s, "off") != 0 || pg_strcasecmp (s, "no") != 0 || pg_strcasecmp (s, "false") != 0)
 readonly = 0;
      else
 do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 1907, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('2') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("invalid value for option \"%s\"", def->defname)); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
      continue;
    }

    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 1911, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('D') - '0') & 0x3F) << 24))), errmsg ("invalid option \"%s\"", def->defname), errhint ("Valid options in this context are: %s", "case, readonly")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
  }

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 1914, __func__); elog_finish(14, "db2_fdw: import schema \"%s\" from foreign server \"%s\"", stmt->remote_schema, server->servername); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);


  nls_lang = guessNlsLang (nls_lang);


  session = db2GetSession (dbserver, user, password, nls_lang, ((void *)0), 1);

  initStringInfo (&buf);
  do {

    rc = db2GetImportColumn (session, stmt->remote_schema, &tabname, &colname, &type, &charlen, &typeprec, &typescale, &nullable, &key);

    if (rc == -1) {

      do { int __errno_location __attribute__((unused)); if (errstart(20,

 "db2_fdw.c"
# 1929 "db2_fdw.c"
      ,

 1931
# 1929 "db2_fdw.c"
      , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('Q') - '0') & 0x3F) << 24))), errmsg ("remote schema \"%s\" does not exist", stmt->remote_schema), errhint ("Enclose the schema name in double quotes to prevent case folding.")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)

                                                                                                                                                      ;

      return ((List *) ((void *)0));
    }

    if ((rc == 0 && oldtabname[0] != '\0')
 || (rc == 1 && oldtabname[0] != '\0' && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (tabname) && __builtin_constant_p (oldtabname) && (__s1_len = strlen (tabname), __s2_len = strlen (oldtabname), (!((size_t)(const void *)((tabname) + 1) - (size_t)(const void *)(tabname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((oldtabname) + 1) - (size_t)(const void *)(oldtabname) == 1) || __s2_len >= 4)) ? __builtin_strcmp (tabname, oldtabname) : (__builtin_constant_p (tabname) && ((size_t)(const void *)((tabname) + 1) - (size_t)(const void *)(tabname) == 1) && (__s1_len = strlen (tabname), __s1_len < 4) ? (__builtin_constant_p (oldtabname) && ((size_t)(const void *)((oldtabname) + 1) - (size_t)(const void *)(oldtabname) == 1) ? __builtin_strcmp (tabname, oldtabname) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (oldtabname); int __result = (((const unsigned char *) (const char *) (tabname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (tabname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (tabname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (tabname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (oldtabname) && ((size_t)(const void *)((oldtabname) + 1) - (size_t)(const void *)(oldtabname) == 1) && (__s2_len = strlen (oldtabname), __s2_len < 4) ? (__builtin_constant_p (tabname) && ((size_t)(const void *)((tabname) + 1) - (size_t)(const void *)(tabname) == 1) ? __builtin_strcmp (tabname, oldtabname) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (tabname); register int __result = __s1[0] - ((const unsigned char *) (const char *) (oldtabname))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (oldtabname))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (oldtabname))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (oldtabname))[3]); } } __result; }))) : __builtin_strcmp (tabname, oldtabname)))); }))) {

      appendStringInfo (&buf, ") SERVER \"%s\" OPTIONS (schema '%s', table '%s'", server->servername, stmt->remote_schema, oldtabname);
      if (readonly)
 appendStringInfo (&buf, ", readonly 'true'");
      appendStringInfo (&buf, ")");

      result = lappend (result, pstrdup (buf.data));
    }

    if (rc == 1 && (oldtabname[0] == '\0' || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (tabname) && __builtin_constant_p (oldtabname) && (__s1_len = strlen (tabname), __s2_len = strlen (oldtabname), (!((size_t)(const void *)((tabname) + 1) - (size_t)(const void *)(tabname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((oldtabname) + 1) - (size_t)(const void *)(oldtabname) == 1) || __s2_len >= 4)) ? __builtin_strcmp (tabname, oldtabname) : (__builtin_constant_p (tabname) && ((size_t)(const void *)((tabname) + 1) - (size_t)(const void *)(tabname) == 1) && (__s1_len = strlen (tabname), __s1_len < 4) ? (__builtin_constant_p (oldtabname) && ((size_t)(const void *)((oldtabname) + 1) - (size_t)(const void *)(oldtabname) == 1) ? __builtin_strcmp (tabname, oldtabname) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (oldtabname); int __result = (((const unsigned char *) (const char *) (tabname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (tabname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (tabname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (tabname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (oldtabname) && ((size_t)(const void *)((oldtabname) + 1) - (size_t)(const void *)(oldtabname) == 1) && (__s2_len = strlen (oldtabname), __s2_len < 4) ? (__builtin_constant_p (tabname) && ((size_t)(const void *)((tabname) + 1) - (size_t)(const void *)(tabname) == 1) ? __builtin_strcmp (tabname, oldtabname) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (tabname); register int __result = __s1[0] - ((const unsigned char *) (const char *) (oldtabname))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (oldtabname))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (oldtabname))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (oldtabname))[3]); } } __result; }))) : __builtin_strcmp (tabname, oldtabname)))); }))) {

      resetStringInfo (&buf);
      foldedname = fold_case (tabname, foldcase);
      appendStringInfo (&buf, "CREATE FOREIGN TABLE \"%s\" (", foldedname);
      pfree (foldedname);

      firstcol = 1;
      strcpy (oldtabname, tabname);
    }

    if (rc == 1) {




      if (firstcol)
 firstcol = 0;
      else
 appendStringInfo (&buf, ", ");


      foldedname = fold_case (colname, foldcase);
      appendStringInfo (&buf, "\"%s\" ", foldedname);
      pfree (foldedname);


      switch (type) {
      case SQL_TYPE_CHAR:
 appendStringInfo (&buf, "character(%d)", charlen == 0 ? 1 : charlen);
 break;
      case SQL_TYPE_VARCHAR:
 appendStringInfo (&buf, "character varying(%d)", charlen == 0 ? 1 : charlen);
 break;
      case SQL_TYPE_CLOB:
      case SQL_TYPE_VARGRAPHIC:
      case SQL_TYPE_GRAPHIC:
 appendStringInfo (&buf, "text");
 break;
      case SQL_TYPE_SMALL:
 appendStringInfo (&buf, "smallint");
 break;
      case SQL_TYPE_INTEGER:
 appendStringInfo (&buf, "integer");
 break;
      case SQL_TYPE_BIG:
 appendStringInfo (&buf, "bigint");
 break;
      case SQL_TYPE_FLOAT:
      case SQL_TYPE_DECIMAL:
      case SQL_TYPE_DOUBLE:
 if (typeprec < 54)
          if (typeprec == 0)
     appendStringInfo (&buf, "float(1)");
          else
     appendStringInfo (&buf, "float(%d)", typeprec);
 else
   appendStringInfo (&buf, "numeric");
 break;
      case SQL_TYPE_XML:
 appendStringInfo (&buf, "bytea");
 break;
      case SQL_TYPE_BLOB:
 appendStringInfo (&buf, "bytea");
 break;
      case SQL_TYPE_DATE:
 appendStringInfo (&buf, "date");
 break;
      case SQL_TYPE_STAMP:
 appendStringInfo (&buf, "timestamp(%d) without time zone", (typescale > 6) ? 6 : typescale);
 break;
      case SQL_TYPE_TIME:
 appendStringInfo (&buf, "time(%d) without time zone", (typescale > 6) ? 6 : typescale);
 break;
      default:
 do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 2022, __func__); elog_finish(13, "column \"%s\" of table \"%s\" has an untranslatable data type", colname, tabname); if (__builtin_constant_p(13) && (13) >= 20) __builtin_unreachable(); } while(0);
 appendStringInfo (&buf, "text");
      }


      if (key)
 appendStringInfo (&buf, " OPTIONS (key 'true')");


      if (!nullable)
 appendStringInfo (&buf, " NOT NULL");
    }
  }
  while (rc == 1);

  return result;
}
# 2048 "db2_fdw.c"
struct DB2FdwState *
getFdwState (Oid foreigntableid, double *sample_percent)
{
  struct DB2FdwState *fdwState = palloc0 (sizeof (struct DB2FdwState));
  char *pgtablename = get_rel_name (foreigntableid);
  List *options;
  ListCell *cell;
  char *schema = ((void *)0), *table = ((void *)0), *maxlong = ((void *)0), *sample = ((void *)0), *fetch = ((void *)0);
  long max_long;





  db2GetOptions (foreigntableid, &options);
  for ((cell) = list_head(options); (cell) != ((void *)0); (cell) = ((cell)->next)) {
    DefElem *def = (DefElem *) ((cell)->data.ptr_value);
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("nls_lang") && (__s1_len = strlen (def->defname), __s2_len = strlen ("nls_lang"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("nls_lang") + 1) - (size_t)(const void *)("nls_lang") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "nls_lang") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("nls_lang") && ((size_t)(const void *)(("nls_lang") + 1) - (size_t)(const void *)("nls_lang") == 1) ? __builtin_strcmp (def->defname, "nls_lang") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("nls_lang"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("nls_lang") && ((size_t)(const void *)(("nls_lang") + 1) - (size_t)(const void *)("nls_lang") == 1) && (__s2_len = strlen ("nls_lang"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "nls_lang") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("nls_lang"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("nls_lang"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("nls_lang"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("nls_lang"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "nls_lang")))); }) == 0)
      fdwState->nls_lang = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("dbserver") && (__s1_len = strlen (def->defname), __s2_len = strlen ("dbserver"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("dbserver") + 1) - (size_t)(const void *)("dbserver") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "dbserver") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("dbserver") && ((size_t)(const void *)(("dbserver") + 1) - (size_t)(const void *)("dbserver") == 1) ? __builtin_strcmp (def->defname, "dbserver") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("dbserver"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("dbserver") && ((size_t)(const void *)(("dbserver") + 1) - (size_t)(const void *)("dbserver") == 1) && (__s2_len = strlen ("dbserver"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "dbserver") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("dbserver"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("dbserver"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("dbserver"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("dbserver"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "dbserver")))); }) == 0)
      fdwState->dbserver = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("user") && (__s1_len = strlen (def->defname), __s2_len = strlen ("user"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("user") + 1) - (size_t)(const void *)("user") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "user") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("user") && ((size_t)(const void *)(("user") + 1) - (size_t)(const void *)("user") == 1) ? __builtin_strcmp (def->defname, "user") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("user"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("user") && ((size_t)(const void *)(("user") + 1) - (size_t)(const void *)("user") == 1) && (__s2_len = strlen ("user"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "user") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("user"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("user"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("user"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("user"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "user")))); }) == 0)
      fdwState->user = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("password") && (__s1_len = strlen (def->defname), __s2_len = strlen ("password"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("password") + 1) - (size_t)(const void *)("password") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "password") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("password") && ((size_t)(const void *)(("password") + 1) - (size_t)(const void *)("password") == 1) ? __builtin_strcmp (def->defname, "password") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("password"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("password") && ((size_t)(const void *)(("password") + 1) - (size_t)(const void *)("password") == 1) && (__s2_len = strlen ("password"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "password") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("password"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("password"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("password"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("password"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "password")))); }) == 0)
      fdwState->password = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("schema") && (__s1_len = strlen (def->defname), __s2_len = strlen ("schema"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("schema") + 1) - (size_t)(const void *)("schema") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "schema") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("schema") && ((size_t)(const void *)(("schema") + 1) - (size_t)(const void *)("schema") == 1) ? __builtin_strcmp (def->defname, "schema") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("schema"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("schema") && ((size_t)(const void *)(("schema") + 1) - (size_t)(const void *)("schema") == 1) && (__s2_len = strlen ("schema"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "schema") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("schema"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("schema"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("schema"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("schema"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "schema")))); }) == 0)
      schema = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("table") && (__s1_len = strlen (def->defname), __s2_len = strlen ("table"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("table") + 1) - (size_t)(const void *)("table") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "table") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("table") && ((size_t)(const void *)(("table") + 1) - (size_t)(const void *)("table") == 1) ? __builtin_strcmp (def->defname, "table") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("table"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("table") && ((size_t)(const void *)(("table") + 1) - (size_t)(const void *)("table") == 1) && (__s2_len = strlen ("table"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "table") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("table"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("table"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("table"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("table"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "table")))); }) == 0)
      table = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("max_long") && (__s1_len = strlen (def->defname), __s2_len = strlen ("max_long"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("max_long") + 1) - (size_t)(const void *)("max_long") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "max_long") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("max_long") && ((size_t)(const void *)(("max_long") + 1) - (size_t)(const void *)("max_long") == 1) ? __builtin_strcmp (def->defname, "max_long") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("max_long"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("max_long") && ((size_t)(const void *)(("max_long") + 1) - (size_t)(const void *)("max_long") == 1) && (__s2_len = strlen ("max_long"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "max_long") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("max_long"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("max_long"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("max_long"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("max_long"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "max_long")))); }) == 0)
      maxlong = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("sample_percent") && (__s1_len = strlen (def->defname), __s2_len = strlen ("sample_percent"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("sample_percent") + 1) - (size_t)(const void *)("sample_percent") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "sample_percent") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("sample_percent") && ((size_t)(const void *)(("sample_percent") + 1) - (size_t)(const void *)("sample_percent") == 1) ? __builtin_strcmp (def->defname, "sample_percent") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("sample_percent"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("sample_percent") && ((size_t)(const void *)(("sample_percent") + 1) - (size_t)(const void *)("sample_percent") == 1) && (__s2_len = strlen ("sample_percent"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "sample_percent") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("sample_percent"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("sample_percent"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("sample_percent"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("sample_percent"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "sample_percent")))); }) == 0)
      sample = ((Value *) (def->arg))->val.str;
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("prefetch") && (__s1_len = strlen (def->defname), __s2_len = strlen ("prefetch"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("prefetch") + 1) - (size_t)(const void *)("prefetch") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "prefetch") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("prefetch") && ((size_t)(const void *)(("prefetch") + 1) - (size_t)(const void *)("prefetch") == 1) ? __builtin_strcmp (def->defname, "prefetch") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("prefetch"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("prefetch") && ((size_t)(const void *)(("prefetch") + 1) - (size_t)(const void *)("prefetch") == 1) && (__s2_len = strlen ("prefetch"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "prefetch") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("prefetch"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("prefetch"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("prefetch"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("prefetch"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "prefetch")))); }) == 0)
      fetch = ((Value *) (def->arg))->val.str;
  }


  if (maxlong == ((void *)0))
    max_long = 32767;
  else
    max_long = strtol (maxlong, ((void *)0), 0);


  if (sample_percent != ((void *)0)) {
    if (sample == ((void *)0))
      *sample_percent = 100.0;
    else
      *sample_percent = strtod (sample, ((void *)0));
  }


  if (fetch == ((void *)0))
    fdwState->prefetch = 200;
  else
    fdwState->prefetch = (unsigned int) strtoul (fetch, ((void *)0), 0);


  if (table == ((void *)0))
    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 2107, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('J') - '0') & 0x3F) << 24))), errmsg ("required option \"%s\" in foreign table \"%s\" missing", "table", pgtablename)); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);


  fdwState->nls_lang = guessNlsLang (fdwState->nls_lang);


  fdwState->session = db2GetSession (fdwState->dbserver, fdwState->user, fdwState->password, fdwState->nls_lang, pgtablename,
         GetCurrentTransactionNestLevel ()
    );


  fdwState->db2Table = db2Describe (fdwState->session, schema, table, pgtablename, max_long);


  getColumnData (foreigntableid, fdwState->db2Table);

  return fdwState;
}
# 2133 "db2_fdw.c"
void
db2GetOptions (Oid foreigntableid, List ** options)
{
  ForeignTable *table;
  ForeignServer *server;
  UserMapping *mapping;
  ForeignDataWrapper *wrapper;




  table = GetForeignTable (foreigntableid);
  server = GetForeignServer (table->serverid);
  mapping = GetUserMapping (GetUserId (), table->serverid);
  wrapper = GetForeignDataWrapper (server->fdwid);


  *options = ((List *) ((void *)0));
  *options = list_concat (*options, wrapper->options);
  *options = list_concat (*options, server->options);
  if (mapping != ((void *)0))
    *options = list_concat (*options, mapping->options);
  *options = list_concat (*options, table->options);
}







void
getColumnData (Oid foreigntableid, struct db2Table *db2Table)
{
  Relation rel;
  TupleDesc tupdesc;
  int i, index;

  rel = table_open (foreigntableid, 0);
  tupdesc = rel->rd_att;


  db2Table->npgcols = tupdesc->natts;


  index = 0;
  for (i = 0; i < tupdesc->natts; ++i) {
    Form_pg_attribute att_tuple = (&(tupdesc)->attrs[(i)]);
    List *options;
    ListCell *option;


    if (att_tuple->attisdropped)
      continue;

    ++index;

    if (index <= db2Table->ncols) {
      db2Table->cols[index - 1]->pgattnum = att_tuple->attnum;
      db2Table->cols[index - 1]->pgtype = att_tuple->atttypid;
      db2Table->cols[index - 1]->pgtypmod = att_tuple->atttypmod;
      db2Table->cols[index - 1]->pgname = pstrdup (((att_tuple->attname).data));
    }


    options = GetForeignColumnOptions (foreigntableid, att_tuple->attnum);
    for ((option) = list_head(options); (option) != ((void *)0); (option) = ((option)->next)) {
      DefElem *def = (DefElem *) ((option)->data.ptr_value);


      if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (def->defname) && __builtin_constant_p ("key") && (__s1_len = strlen (def->defname), __s2_len = strlen ("key"), (!((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("key") + 1) - (size_t)(const void *)("key") == 1) || __s2_len >= 4)) ? __builtin_strcmp (def->defname, "key") : (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) && (__s1_len = strlen (def->defname), __s1_len < 4) ? (__builtin_constant_p ("key") && ((size_t)(const void *)(("key") + 1) - (size_t)(const void *)("key") == 1) ? __builtin_strcmp (def->defname, "key") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("key"); int __result = (((const unsigned char *) (const char *) (def->defname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (def->defname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (def->defname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("key") && ((size_t)(const void *)(("key") + 1) - (size_t)(const void *)("key") == 1) && (__s2_len = strlen ("key"), __s2_len < 4) ? (__builtin_constant_p (def->defname) && ((size_t)(const void *)((def->defname) + 1) - (size_t)(const void *)(def->defname) == 1) ? __builtin_strcmp (def->defname, "key") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (def->defname); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("key"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("key"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("key"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("key"))[3]); } } __result; }))) : __builtin_strcmp (def->defname, "key")))); }) == 0 && optionIsTrue (((Value *) (def->arg))->val.str)) {

 db2Table->cols[index - 1]->pkey = 1;
      }
    }
  }

  table_close (rel, 0);
}
# 2223 "db2_fdw.c"
char *
createQuery (struct DB2FdwState *fdwState, RelOptInfo * foreignrel, _Bool modify, List * query_pathkeys)
{
  ListCell *cell;
  _Bool in_quote = 0;
  int i, index;
  char *wherecopy, *p, md5[33], parname[10], *separator = "";
  StringInfoData query, result;
  List *columnlist, *conditions = foreignrel->baserestrictinfo;

  columnlist = foreignrel->reltarget->exprs;



  columnlist = foreignrel->reltarget->exprs;


  if (((foreignrel)->reloptkind == RELOPT_BASEREL || (foreignrel)->reloptkind == RELOPT_OTHER_MEMBER_REL))
  {



    for ((cell) = list_head(columnlist); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), fdwState->db2Table,foreignrel->relid);
    }


    for ((cell) = list_head(conditions); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), fdwState->db2Table,foreignrel->relid);
    }
  }


  initStringInfo (&query);
  for (i = 0; i < fdwState->db2Table->ncols; ++i) {
    if (fdwState->db2Table->cols[i]->used) {
      StringInfoData alias;
      initStringInfo (&alias);

      appendStringInfo((&alias), "%s%d.", "r", (fdwState->db2Table->cols[i]->varno));


      appendStringInfo (&query, "%s%s%s", separator, alias.data, fdwState->db2Table->cols[i]->name);
      separator = ", ";
    }
  }


  if (separator[0] == '\0')
    appendStringInfo (&query, "'1'");


  appendStringInfo (&query, " FROM ");
  deparseFromExprForRel (fdwState, &query, foreignrel, &(fdwState->params));






  if (((foreignrel)->reloptkind == RELOPT_BASEREL || (foreignrel)->reloptkind == RELOPT_OTHER_MEMBER_REL))
  {

    if (fdwState->where_clause)
      appendStringInfo (&query, "%s", fdwState->where_clause);
  }


  if (fdwState->order_clause)
    appendStringInfo (&query, " ORDER BY%s", fdwState->order_clause);


  if (modify)
    appendStringInfo (&query, " FOR UPDATE");


  wherecopy = pstrdup (query.data);
  for (p = wherecopy; *p != '\0'; ++p) {
    if (*p == '\'')
      in_quote = !in_quote;
    if (in_quote)
      *p = ' ';
  }


  index = 0;
  for ((cell) = list_head(fdwState->params); (cell) != ((void *)0); (cell) = ((cell)->next)) {
    ++index;
    pg_snprintf (parname, 10, ":p%d", index);
    if (strstr (wherecopy, parname) == ((void *)0)) {

      ((cell)->data.ptr_value) = ((void *)0);
    }
  }

  pfree (wherecopy);





  if (!pg_md5_hash (query.data, strlen (query.data), md5)) {
    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 2325, __func__, ((void *)0))) errfinish (errcode ((((('5') - '0') & 0x3F) + (((('3') - '0') & 0x3F) << 6) + (((('2') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('0') - '0') & 0x3F) << 24))), errmsg ("out of memory")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
  }


  initStringInfo (&result);
  appendStringInfo (&result, "SELECT /*%s*/ %s", md5, query.data);
  pfree (query.data);

  return result.data;
}
# 2343 "db2_fdw.c"
static void
deparseFromExprForRel (struct DB2FdwState *fdwState, StringInfo buf, RelOptInfo * foreignrel, List ** params_list)
{
  if (((foreignrel)->reloptkind == RELOPT_BASEREL || (foreignrel)->reloptkind == RELOPT_OTHER_MEMBER_REL)) {
    appendStringInfo (buf, "%s", fdwState->db2Table->name);

    appendStringInfo (buf, " %s%d", "r", foreignrel->relid);
  }
  else {

    RelOptInfo *rel_o = fdwState->outerrel;
    RelOptInfo *rel_i = fdwState->innerrel;
    StringInfoData join_sql_o;
    StringInfoData join_sql_i;
    struct DB2FdwState *fdwState_o = (struct DB2FdwState *) rel_o->fdw_private;
    struct DB2FdwState *fdwState_i = (struct DB2FdwState *) rel_i->fdw_private;


    initStringInfo (&join_sql_o);
    deparseFromExprForRel (fdwState_o, &join_sql_o, rel_o, params_list);


    initStringInfo (&join_sql_i);
    deparseFromExprForRel (fdwState_i, &join_sql_i, rel_i, params_list);






    appendStringInfo (buf, "(%s %s JOIN %s ON ", join_sql_o.data, get_jointype_name (fdwState->jointype), join_sql_i.data);


    ((void)1);
    appendConditions (fdwState->joinclauses, buf, foreignrel, params_list);


    appendStringInfo (buf, ")");
  }
}







static void
appendConditions (List * exprs, StringInfo buf, RelOptInfo * joinrel, List ** params_list)
{
  ListCell *lc;
  _Bool is_first = 1;
  char *where;

  for ((lc) = list_head(exprs); (lc) != ((void *)0); (lc) = ((lc)->next)) {
    Expr *expr = (Expr *) ((lc)->data.ptr_value);


    if (!is_first)
      appendStringInfo (buf, " AND ");


    where = deparseExpr (((void *)0), joinrel, expr, ((void *)0), params_list);
    appendStringInfo (buf, "%s", where);

    is_first = 0;
  }
}







static _Bool
foreign_join_ok (PlannerInfo * root, RelOptInfo * joinrel, JoinType jointype, RelOptInfo * outerrel, RelOptInfo * innerrel, JoinPathExtraData * extra)
{
  struct DB2FdwState *fdwState;
  struct DB2FdwState *fdwState_o;
  struct DB2FdwState *fdwState_i;

  struct db2Table *db2Table_o;
  struct db2Table *db2Table_i;

  ListCell *lc;
  List *otherclauses;

  char *tabname;


  if (jointype != JOIN_INNER)
    return 0;

  fdwState = (struct DB2FdwState *) joinrel->fdw_private;
  fdwState_o = (struct DB2FdwState *) outerrel->fdw_private;
  fdwState_i = (struct DB2FdwState *) innerrel->fdw_private;
  ((void)1);

  fdwState->outerrel = outerrel;
  fdwState->innerrel = innerrel;
  fdwState->jointype = jointype;






  if (fdwState_o->local_conds || fdwState_i->local_conds)
    return 0;
# 2461 "db2_fdw.c"
  otherclauses = extract_actual_clauses (extra->restrictlist, 0);





  for ((lc) = list_head(otherclauses); (lc) != ((void *)0); (lc) = ((lc)->next)) {
    char *tmp = ((void *)0);
    Expr *expr = (Expr *) ((lc)->data.ptr_value);

    tmp = deparseExpr (fdwState->session, joinrel, expr, fdwState->db2Table, &(fdwState->params));

    if (tmp == ((void *)0))
      fdwState->local_conds = lappend (fdwState->local_conds, expr);
    else
      fdwState->remote_conds = lappend (fdwState->remote_conds, expr);
  }
# 2493 "db2_fdw.c"
  if (fdwState->local_conds != ((List *) ((void *)0)))
    return 0;


  if (fdwState->remote_conds == ((List *) ((void *)0)))
    return 0;
# 2512 "db2_fdw.c"
  fdwState->remote_conds = list_concat (fdwState->remote_conds, list_copy (fdwState_i->remote_conds));
  fdwState->remote_conds = list_concat (fdwState->remote_conds, list_copy (fdwState_o->remote_conds));






  fdwState->joinclauses = fdwState->remote_conds;
  fdwState->remote_conds = ((List *) ((void *)0));


  if (fdwState_o->prefetch < fdwState_i->prefetch)
    fdwState->prefetch = fdwState_o->prefetch;
  else
    fdwState->prefetch = fdwState_i->prefetch;


  fdwState->dbserver = fdwState_o->dbserver;
  fdwState->user = fdwState_o->user;
  fdwState->password = fdwState_o->password;
  fdwState->nls_lang = fdwState_o->nls_lang;


  db2Table_o = fdwState_o->db2Table;
  db2Table_i = fdwState_i->db2Table;

  fdwState->db2Table = (struct db2Table *) palloc0 (sizeof (struct db2Table));
  fdwState->db2Table->name = pstrdup ("");
  fdwState->db2Table->pgname = pstrdup ("");
  fdwState->db2Table->ncols = 0;
  fdwState->db2Table->npgcols = 0;
  fdwState->db2Table->cols = (struct db2Column **) palloc0 (sizeof (struct db2Column *) * (db2Table_o->ncols + db2Table_i->ncols));






  tabname = "?";
  for ((lc) = list_head(joinrel->reltarget->exprs); (lc) != ((void *)0); (lc) = ((lc)->next)) {
    int i;
    Var *var = (Var *) ((lc)->data.ptr_value);
    struct db2Column *col = ((void *)0);
    struct db2Column *newcol;
    int used_flag = 0;

    ((void)1);

    for (i = 0; i < db2Table_o->ncols; ++i) {
      struct db2Column *tmp = db2Table_o->cols[i];

      if (tmp->varno == var->varno) {
 tabname = db2Table_o->pgname;

 if (tmp->pgattnum == var->varattno) {
   col = tmp;
   break;
 }
      }
    }
    if (!col) {
      for (i = 0; i < db2Table_i->ncols; ++i) {
 struct db2Column *tmp = db2Table_i->cols[i];

 if (tmp->varno == var->varno) {
   tabname = db2Table_i->pgname;

   if (tmp->pgattnum == var->varattno) {
     col = tmp;
     break;
   }
 }
      }
    }

    newcol = (struct db2Column *) palloc0 (sizeof (struct db2Column));
    if (col) {
      memcpy (newcol, col, sizeof (struct db2Column));
      used_flag = 1;
    }
    else

      do { int __errno_location __attribute__((unused)); if (errstart(19,
 "db2_fdw.c"
# 2595 "db2_fdw.c"
      ,
 2596
# 2595 "db2_fdw.c"
      , __func__, ((void *)0))) errfinish (errcode ((((('0') - '0') & 0x3F) + (((('1') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('0') - '0') & 0x3F) << 24))), errmsg ("column number %d of foreign table \"%s\" does not exist in foreign DB2 table, will be replaced by NULL", var->varattno, tabname)); if (__builtin_constant_p(19) && (19) >= 20) __builtin_unreachable(); } while(0)
                                                                                                                                                                               ;

    newcol->used = used_flag;

    newcol->pgattnum = fdwState->db2Table->ncols + 1;

    fdwState->db2Table->cols[fdwState->db2Table->ncols++] = newcol;
  }

  fdwState->db2Table->npgcols = fdwState->db2Table->ncols;

  return 1;
}


const char *
get_jointype_name (JoinType jointype)
{
  switch (jointype) {
  case JOIN_INNER:
    return "INNER";

  case JOIN_LEFT:
    return "LEFT";

  case JOIN_RIGHT:
    return "RIGHT";

  case JOIN_FULL:
    return "FULL";

  default:

    do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 2629, __func__); elog_finish(20, "unsupported join type %d", jointype); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
  }


  return ((void *)0);
}







List *
build_tlist_to_deparse (RelOptInfo * foreignrel)
{
  List *tlist = ((List *) ((void *)0));
  struct DB2FdwState *fdwState = (struct DB2FdwState *) foreignrel->fdw_private;





  tlist = add_to_flat_tlist (tlist, pull_var_clause ((Node *) foreignrel->reltarget->exprs, 0x0020));
  tlist = add_to_flat_tlist (tlist, pull_var_clause ((Node *) fdwState->local_conds, 0x0020));

  return tlist;
}







int
acquireSampleRowsFunc (Relation relation, int elevel, HeapTuple * rows, int targrows, double *totalrows, double *totaldeadrows)
{
  int collected_rows = 0, i;
  struct DB2FdwState *fdw_state;
  _Bool first_column = 1;
  StringInfoData query;
  TupleDesc tupDesc = ((relation)->rd_att);
  Datum *values = (Datum *) palloc (tupDesc->natts * sizeof (Datum));
  _Bool *nulls = (_Bool *) palloc (tupDesc->natts * sizeof (_Bool));
  double rstate, rowstoskip = -1, sample_percent;
  MemoryContext old_cxt, tmp_cxt;

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 2677, __func__); elog_finish(14, "db2_fdw: analyze foreign table %d", ((relation)->rd_id)); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);

  *totalrows = 0;


  tmp_cxt = (((void) ({ do { _Static_assert(__builtin_constant_p("db2_fdw temporary data"), "memory context names must be constant strings"); } while(0); 1; })), AllocSetContextCreateInternal(CurrentMemoryContext, "db2_fdw temporary data", 0, (1 * 1024), (8 * 1024)));


  rstate = anl_init_selection_state (targrows);


  fdw_state = getFdwState (((relation)->rd_id), &sample_percent);
  fdw_state->paramList = ((void *)0);
  fdw_state->rowcount = 0;


  initStringInfo (&query);
  appendStringInfo (&query, "SELECT ");


  for (i = 0; i < fdw_state->db2Table->ncols; ++i) {

    if (fdw_state->db2Table->cols[i]->db2type == SQL_TYPE_BIG || fdw_state->db2Table->cols[i]->db2type == SQL_TYPE_OTHER) {
      fdw_state->db2Table->cols[i]->used = 0;
    }
    else {

      fdw_state->db2Table->cols[i]->used = 1;


      fdw_state->db2Table->cols[i]->val = (char *) palloc (fdw_state->db2Table->cols[i]->val_size);
      fdw_state->db2Table->cols[i]->val_len = 0;
      fdw_state->db2Table->cols[i]->val_len4 = 0;
      fdw_state->db2Table->cols[i]->val_null = 1;

      if (first_column)
 first_column = 0;
      else
 appendStringInfo (&query, ", ");


      appendStringInfo (&query, "%s", fdw_state->db2Table->cols[i]->name);
    }
  }


  if (first_column)
    appendStringInfo (&query, "NULL");


  appendStringInfo (&query, " FROM %s", fdw_state->db2Table->name);


  if (sample_percent < 100.0)
    appendStringInfo (&query, " SAMPLE BLOCK (%f)", sample_percent);

  fdw_state->query = query.data;
  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 2734, __func__); elog_finish(14, "db2_fdw: remote query is %s", fdw_state->query); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);


  for (i = 0; i < fdw_state->db2Table->ncols; ++i)
    if (fdw_state->db2Table->cols[i]->used)
      checkDataType (fdw_state->db2Table->cols[i]->db2type,
       fdw_state->db2Table->cols[i]->scale, fdw_state->db2Table->cols[i]->pgtype, fdw_state->db2Table->pgname, fdw_state->db2Table->cols[i]->pgname);


  while (db2IsStatementOpen (fdw_state->session)
  ? db2FetchNext (fdw_state->session)
  : (db2PrepareQuery (fdw_state->session, fdw_state->query, fdw_state->db2Table, fdw_state->prefetch),
     db2ExecuteQuery (fdw_state->session, fdw_state->db2Table, fdw_state->paramList))) {

    vacuum_delay_point ();

    ++fdw_state->rowcount;

    if (collected_rows < targrows) {



      old_cxt = MemoryContextSwitchTo (tmp_cxt);
      convertTuple (fdw_state, values, nulls, 1);
      MemoryContextSwitchTo (old_cxt);

      rows[collected_rows++] = heap_form_tuple (tupDesc, values, nulls);
      MemoryContextReset (tmp_cxt);
    }
    else {




      if (rowstoskip < 0)
 rowstoskip = anl_get_next_S (*totalrows, targrows, &rstate);

      if (rowstoskip <= 0) {
 int k = (int) (targrows * anl_random_fract ());

 heap_freetuple (rows[k]);


 old_cxt = MemoryContextSwitchTo (tmp_cxt);
 convertTuple (fdw_state, values, nulls, 1);
 MemoryContextSwitchTo (old_cxt);

 rows[k] = heap_form_tuple (tupDesc, values, nulls);
 MemoryContextReset (tmp_cxt);
      }
    }
  }

  MemoryContextDelete (tmp_cxt);

  *totalrows = (double) fdw_state->rowcount / sample_percent * 100.0;
  *totaldeadrows = 0;


  do { int __errno_location __attribute__((unused)); if (errstart(elevel, "db2_fdw.c", 2793, __func__, ((void *)0))) errfinish (errmsg ("\"%s\": table contains %lu rows; %d rows in sample", ((((relation)->rd_rel->relname).data)), fdw_state->rowcount, collected_rows)); if (__builtin_constant_p(elevel) && (elevel) >= 20) __builtin_unreachable(); } while(0);

  return collected_rows;
}





void
appendAsType (StringInfoData * dest, const char *s, Oid type)
{
  switch (type) {
  case 1082:
    appendStringInfo (dest, "CAST (%s AS DATE)", s);
    break;
  case 1114:
    appendStringInfo (dest, "CAST (%s AS TIMESTAMP)", s);
    break;
  case 1184:
    appendStringInfo (dest, "CAST (%s AS TIMESTAMP WITH TIME ZONE)", s);
    break;
  case 1083:
    appendStringInfo (dest, "(CAST ('%s' AS TIME))", s);
    break;
  case 1266:
    appendStringInfo (dest, "(CAST ('%s' AS TIME WITH TIME ZONE))", s);
    break;
  default:
    appendStringInfo (dest, "%s", s);
  }
}
# 2843 "db2_fdw.c"
char *
deparseExpr (db2Session * session, RelOptInfo * foreignrel, Expr * expr, const struct db2Table *db2Table, List ** params)
{
  char *opername, *left, *right, *arg, oprkind;

  char parname[10];

  Const *constant;
  OpExpr *oper;
  ScalarArrayOpExpr *arrayoper;
  CaseExpr *caseexpr;
  BoolExpr *boolexpr;
  CoalesceExpr *coalesceexpr;
  CoerceViaIO *coerce;
  Param *param;
  Var *variable;
  FuncExpr *func;
  Expr *rightexpr;
  ArrayExpr *array;
  ArrayCoerceExpr *arraycoerce;

  SQLValueFunction *sqlvalfunc;

  regproc typoutput;
  HeapTuple tuple;
  ListCell *cell;
  StringInfoData result;
  Oid leftargtype, rightargtype, schema;
  db2Type db2type;
  ArrayIterator iterator;
  Datum datum;
  _Bool first_arg, isNull;
  int index;
  StringInfoData alias;
  const struct db2Table *var_table;

  if (expr == ((void *)0))
    return ((void *)0);

  switch (expr->type) {
  case T_Const:
    constant = (Const *) expr;
    if (constant->constisnull) {

      if (((constant->consttype) == 25 || (constant->consttype) == 18 || (constant->consttype) == 1042 || (constant->consttype) == 1043 || (constant->consttype) == 19 || (constant->consttype) == 20 || (constant->consttype) == 21 || (constant->consttype) == 23 || (constant->consttype) == 26 || (constant->consttype) == 700 || (constant->consttype) == 701 || (constant->consttype) == 1700 || (constant->consttype) == 1082 || (constant->consttype) == 1083 || (constant->consttype) == 1114 || (constant->consttype) == 1184 || (constant->consttype) == 1186)) {
 initStringInfo (&result);
 appendStringInfo (&result, "NULL");
      }
      else
 return ((void *)0);
    }
    else {

      char *c = datumToString (constant->constvalue, constant->consttype);
      if (c == ((void *)0))
 return ((void *)0);
      else {
 initStringInfo (&result);
 appendStringInfo (&result, "%s", c);
      }
    }
    break;
  case T_Param:
    param = (Param *) expr;





    if (!((param->paramtype) == 25 || (param->paramtype) == 18 || (param->paramtype) == 1042 || (param->paramtype) == 1043 || (param->paramtype) == 19 || (param->paramtype) == 20 || (param->paramtype) == 21 || (param->paramtype) == 23 || (param->paramtype) == 26 || (param->paramtype) == 700 || (param->paramtype) == 701 || (param->paramtype) == 1700 || (param->paramtype) == 1082 || (param->paramtype) == 1083 || (param->paramtype) == 1114 || (param->paramtype) == 1184 || (param->paramtype) == 1186) || param->paramtype == 1186)
      return ((void *)0);


    index = 0;
    for ((cell) = list_head(*params); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      ++index;
      if (equal (param, (Node *) ((cell)->data.ptr_value)))
 break;
    }
    if (cell == ((void *)0)) {

      ++index;
      *params = lappend (*params, param);
    }


    pg_snprintf (parname, 10, ":p%d", index);
    initStringInfo (&result);
    appendAsType (&result, parname, param->paramtype);

    break;

  case T_Var:
    variable = (Var *) expr;
    var_table = ((void *)0);



    if (((foreignrel)->reloptkind == RELOPT_BASEREL || (foreignrel)->reloptkind == RELOPT_OTHER_MEMBER_REL)) {

      if (variable->varno == foreignrel->relid && variable->varlevelsup == 0)
 var_table = db2Table;

    }
    else {
      struct DB2FdwState *joinstate = (struct DB2FdwState *) foreignrel->fdw_private;
      struct DB2FdwState *outerstate = (struct DB2FdwState *) joinstate->outerrel->fdw_private;
      struct DB2FdwState *innerstate = (struct DB2FdwState *) joinstate->innerrel->fdw_private;


      if (variable->varno == outerstate->db2Table->cols[0]->varno && variable->varlevelsup == 0)
 var_table = outerstate->db2Table;
      if (variable->varno == innerstate->db2Table->cols[0]->varno && variable->varlevelsup == 0)
 var_table = innerstate->db2Table;
    }


    if (var_table) {



      if (variable->varattno < 1)
 return ((void *)0);





      if (!(((variable->vartype) == 25 || (variable->vartype) == 18 || (variable->vartype) == 1042 || (variable->vartype) == 1043 || (variable->vartype) == 19 || (variable->vartype) == 20 || (variable->vartype) == 21 || (variable->vartype) == 23 || (variable->vartype) == 26 || (variable->vartype) == 700 || (variable->vartype) == 701 || (variable->vartype) == 1700 || (variable->vartype) == 1082 || (variable->vartype) == 1083 || (variable->vartype) == 1114 || (variable->vartype) == 1184 || (variable->vartype) == 1186) || variable->vartype == 16))
 return ((void *)0);


      index = var_table->ncols - 1;
      while (index >= 0 && var_table->cols[index]->pgattnum != variable->varattno)
 --index;


      if (index == -1) {
 initStringInfo (&result);
 appendStringInfo (&result, "NULL");
 break;
      }






      db2type = var_table->cols[index]->db2type;
      if ((variable->vartype == 25 || variable->vartype == 1042 || variable->vartype == 1043)
   && db2type != SQL_TYPE_VARCHAR && db2type != SQL_TYPE_CHAR)
 return ((void *)0);

      initStringInfo (&result);


      if (variable->vartype == 16) {
 appendStringInfo (&result, "(");
      }


      initStringInfo (&alias);
      appendStringInfo((&alias), "%s%d.", "r", (var_table->cols[index]->varno));

      appendStringInfo (&result, "%s%s", alias.data, var_table->cols[index]->name);


      if (variable->vartype == 16) {
 appendStringInfo (&result, " <> 0)");
      }
    }
    else {






      if (!((variable->vartype) == 25 || (variable->vartype) == 18 || (variable->vartype) == 1042 || (variable->vartype) == 1043 || (variable->vartype) == 19 || (variable->vartype) == 20 || (variable->vartype) == 21 || (variable->vartype) == 23 || (variable->vartype) == 26 || (variable->vartype) == 700 || (variable->vartype) == 701 || (variable->vartype) == 1700 || (variable->vartype) == 1082 || (variable->vartype) == 1083 || (variable->vartype) == 1114 || (variable->vartype) == 1184 || (variable->vartype) == 1186) || variable->vartype == 1186)
 return ((void *)0);


      index = 0;
      for ((cell) = list_head(*params); (cell) != ((void *)0); (cell) = ((cell)->next)) {
 ++index;
 if (equal (variable, (Node *) ((cell)->data.ptr_value)))
   break;
      }
      if (cell == ((void *)0)) {

 ++index;
 *params = lappend (*params, variable);
      }


      initStringInfo (&result);
      appendStringInfo (&result, ":p%d", index);

    }

    break;
  case T_OpExpr:
    oper = (OpExpr *) expr;


    tuple = SearchSysCache1 (OPEROID, ((Datum) (oper->opno)));
    if (!((const void*)(tuple) != ((void *)0))) {
      do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 3050, __func__); elog_finish(20, "cache lookup failed for operator %u", oper->opno); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    }
    opername = pstrdup (((Form_pg_operator) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->oprname.data);
    oprkind = ((Form_pg_operator) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->oprkind;
    leftargtype = ((Form_pg_operator) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->oprleft;
    rightargtype = ((Form_pg_operator) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->oprright;
    schema = ((Form_pg_operator) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->oprnamespace;
    ReleaseSysCache (tuple);


    if (schema != 11)
      return ((void *)0);

    if (!((rightargtype) == 25 || (rightargtype) == 18 || (rightargtype) == 1042 || (rightargtype) == 1043 || (rightargtype) == 19 || (rightargtype) == 20 || (rightargtype) == 21 || (rightargtype) == 23 || (rightargtype) == 26 || (rightargtype) == 700 || (rightargtype) == 701 || (rightargtype) == 1700 || (rightargtype) == 1082 || (rightargtype) == 1083 || (rightargtype) == 1114 || (rightargtype) == 1184 || (rightargtype) == 1186))
      return ((void *)0);





    if (leftargtype == 1186 && rightargtype == 1186)
      return ((void *)0);


    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("=") && (__s1_len = strlen (opername), __s2_len = strlen ("="), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("=") + 1) - (size_t)(const void *)("=") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "=") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("=") && ((size_t)(const void *)(("=") + 1) - (size_t)(const void *)("=") == 1) ? __builtin_strcmp (opername, "=") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("="); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("=") && ((size_t)(const void *)(("=") + 1) - (size_t)(const void *)("=") == 1) && (__s2_len = strlen ("="), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "=") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("="))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("="))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("="))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("="))[3]); } } __result; }))) : __builtin_strcmp (opername, "=")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("<>") && (__s1_len = strlen (opername), __s2_len = strlen ("<>"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("<>") + 1) - (size_t)(const void *)("<>") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "<>") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("<>") && ((size_t)(const void *)(("<>") + 1) - (size_t)(const void *)("<>") == 1) ? __builtin_strcmp (opername, "<>") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("<>"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("<>") && ((size_t)(const void *)(("<>") + 1) - (size_t)(const void *)("<>") == 1) && (__s2_len = strlen ("<>"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "<>") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("<>"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("<>"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("<>"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("<>"))[3]); } } __result; }))) : __builtin_strcmp (opername, "<>")))); }) == 0

 || (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p (">") && (__s1_len = strlen (opername), __s2_len = strlen (">"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((">") + 1) - (size_t)(const void *)(">") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, ">") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p (">") && ((size_t)(const void *)((">") + 1) - (size_t)(const void *)(">") == 1) ? __builtin_strcmp (opername, ">") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (">"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (">") && ((size_t)(const void *)((">") + 1) - (size_t)(const void *)(">") == 1) && (__s2_len = strlen (">"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, ">") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) (">"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (">"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (">"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (">"))[3]); } } __result; }))) : __builtin_strcmp (opername, ">")))); }) == 0 && rightargtype != 25 && rightargtype != 1042 && rightargtype != 19 && rightargtype != 18)
 || (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("<") && (__s1_len = strlen (opername), __s2_len = strlen ("<"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("<") + 1) - (size_t)(const void *)("<") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "<") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("<") && ((size_t)(const void *)(("<") + 1) - (size_t)(const void *)("<") == 1) ? __builtin_strcmp (opername, "<") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("<"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("<") && ((size_t)(const void *)(("<") + 1) - (size_t)(const void *)("<") == 1) && (__s2_len = strlen ("<"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "<") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("<"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("<"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("<"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("<"))[3]); } } __result; }))) : __builtin_strcmp (opername, "<")))); }) == 0 && rightargtype != 25 && rightargtype != 1042 && rightargtype != 19 && rightargtype != 18)
 || (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p (">=") && (__s1_len = strlen (opername), __s2_len = strlen (">="), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((">=") + 1) - (size_t)(const void *)(">=") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, ">=") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p (">=") && ((size_t)(const void *)((">=") + 1) - (size_t)(const void *)(">=") == 1) ? __builtin_strcmp (opername, ">=") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (">="); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (">=") && ((size_t)(const void *)((">=") + 1) - (size_t)(const void *)(">=") == 1) && (__s2_len = strlen (">="), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, ">=") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) (">="))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (">="))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (">="))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (">="))[3]); } } __result; }))) : __builtin_strcmp (opername, ">=")))); }) == 0 && rightargtype != 25 && rightargtype != 1042 && rightargtype != 19 && rightargtype != 18)
 || (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("<=") && (__s1_len = strlen (opername), __s2_len = strlen ("<="), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("<=") + 1) - (size_t)(const void *)("<=") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "<=") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("<=") && ((size_t)(const void *)(("<=") + 1) - (size_t)(const void *)("<=") == 1) ? __builtin_strcmp (opername, "<=") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("<="); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("<=") && ((size_t)(const void *)(("<=") + 1) - (size_t)(const void *)("<=") == 1) && (__s2_len = strlen ("<="), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "<=") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("<="))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("<="))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("<="))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("<="))[3]); } } __result; }))) : __builtin_strcmp (opername, "<=")))); }) == 0 && rightargtype != 25 && rightargtype != 1042 && rightargtype != 19 && rightargtype != 18)
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("+") && (__s1_len = strlen (opername), __s2_len = strlen ("+"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("+") + 1) - (size_t)(const void *)("+") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "+") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("+") && ((size_t)(const void *)(("+") + 1) - (size_t)(const void *)("+") == 1) ? __builtin_strcmp (opername, "+") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("+"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("+") && ((size_t)(const void *)(("+") + 1) - (size_t)(const void *)("+") == 1) && (__s2_len = strlen ("+"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "+") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("+"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("+"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("+"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("+"))[3]); } } __result; }))) : __builtin_strcmp (opername, "+")))); }) == 0

 || (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("-") && (__s1_len = strlen (opername), __s2_len = strlen ("-"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("-") + 1) - (size_t)(const void *)("-") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "-") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("-") && ((size_t)(const void *)(("-") + 1) - (size_t)(const void *)("-") == 1) ? __builtin_strcmp (opername, "-") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("-"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("-") && ((size_t)(const void *)(("-") + 1) - (size_t)(const void *)("-") == 1) && (__s2_len = strlen ("-"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "-") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("-"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("-"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("-"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("-"))[3]); } } __result; }))) : __builtin_strcmp (opername, "-")))); }) == 0 && rightargtype != 1082 && rightargtype != 1114 && rightargtype != 1184)
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("*") && (__s1_len = strlen (opername), __s2_len = strlen ("*"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("*") + 1) - (size_t)(const void *)("*") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "*") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("*") && ((size_t)(const void *)(("*") + 1) - (size_t)(const void *)("*") == 1) ? __builtin_strcmp (opername, "*") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("*"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("*") && ((size_t)(const void *)(("*") + 1) - (size_t)(const void *)("*") == 1) && (__s2_len = strlen ("*"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "*") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("*"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("*"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("*"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("*"))[3]); } } __result; }))) : __builtin_strcmp (opername, "*")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("~~") && (__s1_len = strlen (opername), __s2_len = strlen ("~~"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("~~") + 1) - (size_t)(const void *)("~~") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "~~") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("~~") && ((size_t)(const void *)(("~~") + 1) - (size_t)(const void *)("~~") == 1) ? __builtin_strcmp (opername, "~~") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("~~"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("~~") && ((size_t)(const void *)(("~~") + 1) - (size_t)(const void *)("~~") == 1) && (__s2_len = strlen ("~~"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "~~") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("~~"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("~~"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("~~"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("~~"))[3]); } } __result; }))) : __builtin_strcmp (opername, "~~")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("!~~") && (__s1_len = strlen (opername), __s2_len = strlen ("!~~"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("!~~") + 1) - (size_t)(const void *)("!~~") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "!~~") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("!~~") && ((size_t)(const void *)(("!~~") + 1) - (size_t)(const void *)("!~~") == 1) ? __builtin_strcmp (opername, "!~~") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("!~~"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("!~~") && ((size_t)(const void *)(("!~~") + 1) - (size_t)(const void *)("!~~") == 1) && (__s2_len = strlen ("!~~"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "!~~") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("!~~"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("!~~"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("!~~"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("!~~"))[3]); } } __result; }))) : __builtin_strcmp (opername, "!~~")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("~~*") && (__s1_len = strlen (opername), __s2_len = strlen ("~~*"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("~~*") + 1) - (size_t)(const void *)("~~*") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "~~*") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("~~*") && ((size_t)(const void *)(("~~*") + 1) - (size_t)(const void *)("~~*") == 1) ? __builtin_strcmp (opername, "~~*") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("~~*"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("~~*") && ((size_t)(const void *)(("~~*") + 1) - (size_t)(const void *)("~~*") == 1) && (__s2_len = strlen ("~~*"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "~~*") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("~~*"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("~~*"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("~~*"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("~~*"))[3]); } } __result; }))) : __builtin_strcmp (opername, "~~*")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("!~~*") && (__s1_len = strlen (opername), __s2_len = strlen ("!~~*"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("!~~*") + 1) - (size_t)(const void *)("!~~*") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "!~~*") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("!~~*") && ((size_t)(const void *)(("!~~*") + 1) - (size_t)(const void *)("!~~*") == 1) ? __builtin_strcmp (opername, "!~~*") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("!~~*"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("!~~*") && ((size_t)(const void *)(("!~~*") + 1) - (size_t)(const void *)("!~~*") == 1) && (__s2_len = strlen ("!~~*"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "!~~*") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("!~~*"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("!~~*"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("!~~*"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("!~~*"))[3]); } } __result; }))) : __builtin_strcmp (opername, "!~~*")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("^") && (__s1_len = strlen (opername), __s2_len = strlen ("^"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("^") + 1) - (size_t)(const void *)("^") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "^") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("^") && ((size_t)(const void *)(("^") + 1) - (size_t)(const void *)("^") == 1) ? __builtin_strcmp (opername, "^") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("^"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("^") && ((size_t)(const void *)(("^") + 1) - (size_t)(const void *)("^") == 1) && (__s2_len = strlen ("^"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "^") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("^"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("^"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("^"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("^"))[3]); } } __result; }))) : __builtin_strcmp (opername, "^")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("%") && (__s1_len = strlen (opername), __s2_len = strlen ("%"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("%") + 1) - (size_t)(const void *)("%") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "%") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("%") && ((size_t)(const void *)(("%") + 1) - (size_t)(const void *)("%") == 1) ? __builtin_strcmp (opername, "%") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("%"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("%") && ((size_t)(const void *)(("%") + 1) - (size_t)(const void *)("%") == 1) && (__s2_len = strlen ("%"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "%") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("%"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("%"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("%"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("%"))[3]); } } __result; }))) : __builtin_strcmp (opername, "%")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("&") && (__s1_len = strlen (opername), __s2_len = strlen ("&"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("&") + 1) - (size_t)(const void *)("&") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "&") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("&") && ((size_t)(const void *)(("&") + 1) - (size_t)(const void *)("&") == 1) ? __builtin_strcmp (opername, "&") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("&"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("&") && ((size_t)(const void *)(("&") + 1) - (size_t)(const void *)("&") == 1) && (__s2_len = strlen ("&"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "&") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("&"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("&"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("&"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("&"))[3]); } } __result; }))) : __builtin_strcmp (opername, "&")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("|/") && (__s1_len = strlen (opername), __s2_len = strlen ("|/"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("|/") + 1) - (size_t)(const void *)("|/") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "|/") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("|/") && ((size_t)(const void *)(("|/") + 1) - (size_t)(const void *)("|/") == 1) ? __builtin_strcmp (opername, "|/") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("|/"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("|/") && ((size_t)(const void *)(("|/") + 1) - (size_t)(const void *)("|/") == 1) && (__s2_len = strlen ("|/"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "|/") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("|/"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("|/"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("|/"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("|/"))[3]); } } __result; }))) : __builtin_strcmp (opername, "|/")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("@") && (__s1_len = strlen (opername), __s2_len = strlen ("@"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("@") + 1) - (size_t)(const void *)("@") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "@") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("@") && ((size_t)(const void *)(("@") + 1) - (size_t)(const void *)("@") == 1) ? __builtin_strcmp (opername, "@") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("@"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("@") && ((size_t)(const void *)(("@") + 1) - (size_t)(const void *)("@") == 1) && (__s2_len = strlen ("@"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "@") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("@"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("@"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("@"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("@"))[3]); } } __result; }))) : __builtin_strcmp (opername, "@")))); }) == 0) {
      left = deparseExpr (session, foreignrel, ((list_head(oper->args))->data.ptr_value), db2Table, params);
      if (left == ((void *)0)) {
 pfree (opername);
 return ((void *)0);
      }

      if (oprkind == 'b') {

 right = deparseExpr (session, foreignrel, ((((list_head(oper->args))->next))->data.ptr_value), db2Table, params);
 if (right == ((void *)0)) {
   pfree (left);
   pfree (opername);
   return ((void *)0);
 }

 initStringInfo (&result);
 if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("~~") && (__s1_len = strlen (opername), __s2_len = strlen ("~~"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("~~") + 1) - (size_t)(const void *)("~~") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "~~") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("~~") && ((size_t)(const void *)(("~~") + 1) - (size_t)(const void *)("~~") == 1) ? __builtin_strcmp (opername, "~~") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("~~"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("~~") && ((size_t)(const void *)(("~~") + 1) - (size_t)(const void *)("~~") == 1) && (__s2_len = strlen ("~~"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "~~") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("~~"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("~~"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("~~"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("~~"))[3]); } } __result; }))) : __builtin_strcmp (opername, "~~")))); }) == 0) {
   appendStringInfo (&result, "(%s LIKE %s ESCAPE '\\')", left, right);
 }
 else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("!~~") && (__s1_len = strlen (opername), __s2_len = strlen ("!~~"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("!~~") + 1) - (size_t)(const void *)("!~~") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "!~~") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("!~~") && ((size_t)(const void *)(("!~~") + 1) - (size_t)(const void *)("!~~") == 1) ? __builtin_strcmp (opername, "!~~") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("!~~"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("!~~") && ((size_t)(const void *)(("!~~") + 1) - (size_t)(const void *)("!~~") == 1) && (__s2_len = strlen ("!~~"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "!~~") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("!~~"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("!~~"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("!~~"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("!~~"))[3]); } } __result; }))) : __builtin_strcmp (opername, "!~~")))); }) == 0) {
   appendStringInfo (&result, "(%s NOT LIKE %s ESCAPE '\\')", left, right);
 }
 else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("~~*") && (__s1_len = strlen (opername), __s2_len = strlen ("~~*"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("~~*") + 1) - (size_t)(const void *)("~~*") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "~~*") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("~~*") && ((size_t)(const void *)(("~~*") + 1) - (size_t)(const void *)("~~*") == 1) ? __builtin_strcmp (opername, "~~*") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("~~*"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("~~*") && ((size_t)(const void *)(("~~*") + 1) - (size_t)(const void *)("~~*") == 1) && (__s2_len = strlen ("~~*"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "~~*") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("~~*"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("~~*"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("~~*"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("~~*"))[3]); } } __result; }))) : __builtin_strcmp (opername, "~~*")))); }) == 0) {
   appendStringInfo (&result, "(UPPER(%s) LIKE UPPER(%s) ESCAPE '\\')", left, right);
 }
 else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("!~~*") && (__s1_len = strlen (opername), __s2_len = strlen ("!~~*"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("!~~*") + 1) - (size_t)(const void *)("!~~*") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "!~~*") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("!~~*") && ((size_t)(const void *)(("!~~*") + 1) - (size_t)(const void *)("!~~*") == 1) ? __builtin_strcmp (opername, "!~~*") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("!~~*"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("!~~*") && ((size_t)(const void *)(("!~~*") + 1) - (size_t)(const void *)("!~~*") == 1) && (__s2_len = strlen ("!~~*"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "!~~*") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("!~~*"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("!~~*"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("!~~*"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("!~~*"))[3]); } } __result; }))) : __builtin_strcmp (opername, "!~~*")))); }) == 0) {
   appendStringInfo (&result, "(UPPER(%s) NOT LIKE UPPER(%s) ESCAPE '\\')", left, right);
 }
 else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("^") && (__s1_len = strlen (opername), __s2_len = strlen ("^"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("^") + 1) - (size_t)(const void *)("^") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "^") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("^") && ((size_t)(const void *)(("^") + 1) - (size_t)(const void *)("^") == 1) ? __builtin_strcmp (opername, "^") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("^"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("^") && ((size_t)(const void *)(("^") + 1) - (size_t)(const void *)("^") == 1) && (__s2_len = strlen ("^"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "^") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("^"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("^"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("^"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("^"))[3]); } } __result; }))) : __builtin_strcmp (opername, "^")))); }) == 0) {
   appendStringInfo (&result, "POWER(%s, %s)", left, right);
 }
 else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("%") && (__s1_len = strlen (opername), __s2_len = strlen ("%"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("%") + 1) - (size_t)(const void *)("%") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "%") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("%") && ((size_t)(const void *)(("%") + 1) - (size_t)(const void *)("%") == 1) ? __builtin_strcmp (opername, "%") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("%"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("%") && ((size_t)(const void *)(("%") + 1) - (size_t)(const void *)("%") == 1) && (__s2_len = strlen ("%"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "%") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("%"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("%"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("%"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("%"))[3]); } } __result; }))) : __builtin_strcmp (opername, "%")))); }) == 0) {
   appendStringInfo (&result, "MOD(%s, %s)", left, right);
 }
 else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("&") && (__s1_len = strlen (opername), __s2_len = strlen ("&"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("&") + 1) - (size_t)(const void *)("&") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "&") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("&") && ((size_t)(const void *)(("&") + 1) - (size_t)(const void *)("&") == 1) ? __builtin_strcmp (opername, "&") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("&"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("&") && ((size_t)(const void *)(("&") + 1) - (size_t)(const void *)("&") == 1) && (__s2_len = strlen ("&"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "&") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("&"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("&"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("&"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("&"))[3]); } } __result; }))) : __builtin_strcmp (opername, "&")))); }) == 0) {
   appendStringInfo (&result, "BITAND(%s, %s)", left, right);
 }
 else {

   appendStringInfo (&result, "(%s %s %s)", left, opername, right);
 }
 pfree (right);
 pfree (left);
      }
      else {

 initStringInfo (&result);
 if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("|/") && (__s1_len = strlen (opername), __s2_len = strlen ("|/"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("|/") + 1) - (size_t)(const void *)("|/") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "|/") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("|/") && ((size_t)(const void *)(("|/") + 1) - (size_t)(const void *)("|/") == 1) ? __builtin_strcmp (opername, "|/") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("|/"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("|/") && ((size_t)(const void *)(("|/") + 1) - (size_t)(const void *)("|/") == 1) && (__s2_len = strlen ("|/"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "|/") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("|/"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("|/"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("|/"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("|/"))[3]); } } __result; }))) : __builtin_strcmp (opername, "|/")))); }) == 0) {
   appendStringInfo (&result, "SQRT(%s)", left);
 }
 else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("@") && (__s1_len = strlen (opername), __s2_len = strlen ("@"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("@") + 1) - (size_t)(const void *)("@") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "@") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("@") && ((size_t)(const void *)(("@") + 1) - (size_t)(const void *)("@") == 1) ? __builtin_strcmp (opername, "@") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("@"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("@") && ((size_t)(const void *)(("@") + 1) - (size_t)(const void *)("@") == 1) && (__s2_len = strlen ("@"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "@") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("@"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("@"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("@"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("@"))[3]); } } __result; }))) : __builtin_strcmp (opername, "@")))); }) == 0) {
   appendStringInfo (&result, "ABS(%s)", left);
 }
 else {

   appendStringInfo (&result, "(%s%s)", opername, left);
 }
 pfree (left);
      }
    }
    else {

      pfree (opername);
      return ((void *)0);
    }

    pfree (opername);
    break;
  case T_ScalarArrayOpExpr:
    arrayoper = (ScalarArrayOpExpr *) expr;


    tuple = SearchSysCache1 (OPEROID, ((Datum) (arrayoper->opno)));
    if (!((const void*)(tuple) != ((void *)0))) {
      do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 3163, __func__); elog_finish(20, "cache lookup failed for operator %u", arrayoper->opno); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    }
    opername = pstrdup (((Form_pg_operator) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->oprname.data);
    leftargtype = ((Form_pg_operator) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->oprleft;
    schema = ((Form_pg_operator) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->oprnamespace;
    ReleaseSysCache (tuple);


    tuple = SearchSysCache1 (TYPEOID, ((Datum) (leftargtype)));
    if (!((const void*)(tuple) != ((void *)0))) {
      do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 3173, __func__); elog_finish(20, "cache lookup failed for type %u", leftargtype); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    }
    typoutput = ((Form_pg_type) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->typoutput;
    ReleaseSysCache (tuple);


    if (schema != 11)
      return ((void *)0);


    if ((__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("=") && (__s1_len = strlen (opername), __s2_len = strlen ("="), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("=") + 1) - (size_t)(const void *)("=") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "=") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("=") && ((size_t)(const void *)(("=") + 1) - (size_t)(const void *)("=") == 1) ? __builtin_strcmp (opername, "=") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("="); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("=") && ((size_t)(const void *)(("=") + 1) - (size_t)(const void *)("=") == 1) && (__s2_len = strlen ("="), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "=") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("="))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("="))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("="))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("="))[3]); } } __result; }))) : __builtin_strcmp (opername, "=")))); }) != 0 || !arrayoper->useOr)
 && (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("<>") && (__s1_len = strlen (opername), __s2_len = strlen ("<>"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("<>") + 1) - (size_t)(const void *)("<>") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "<>") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("<>") && ((size_t)(const void *)(("<>") + 1) - (size_t)(const void *)("<>") == 1) ? __builtin_strcmp (opername, "<>") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("<>"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("<>") && ((size_t)(const void *)(("<>") + 1) - (size_t)(const void *)("<>") == 1) && (__s2_len = strlen ("<>"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "<>") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("<>"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("<>"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("<>"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("<>"))[3]); } } __result; }))) : __builtin_strcmp (opername, "<>")))); }) != 0 || arrayoper->useOr))
      return ((void *)0);

    if (!((leftargtype) == 25 || (leftargtype) == 18 || (leftargtype) == 1042 || (leftargtype) == 1043 || (leftargtype) == 19 || (leftargtype) == 20 || (leftargtype) == 21 || (leftargtype) == 23 || (leftargtype) == 26 || (leftargtype) == 700 || (leftargtype) == 701 || (leftargtype) == 1700 || (leftargtype) == 1082 || (leftargtype) == 1083 || (leftargtype) == 1114 || (leftargtype) == 1184 || (leftargtype) == 1186))
      return ((void *)0);

    left = deparseExpr (session, foreignrel, ((list_head(arrayoper->args))->data.ptr_value), db2Table, params);
    if (left == ((void *)0))
      return ((void *)0);


    initStringInfo (&result);
    appendStringInfo (&result, "(%s %s (", left, arrayoper->useOr ? "IN" : "NOT IN");


    rightexpr = (Expr *) ((list_tail(arrayoper->args))->data.ptr_value);
    switch (rightexpr->type) {
    case T_Const:

      constant = (Const *) rightexpr;


      if (constant->constisnull)
 appendStringInfo (&result, "NULL");
      else {

 iterator = array_create_iterator(((ArrayType *) pg_detoast_datum((struct varlena *) ((Pointer) (constant->constvalue)))), 0, ((void *)0));
 first_arg = 1;
 while (array_iterate (iterator, &datum, &isNull)) {
   char *c;

   if (isNull)
     c = "NULL";
   else {
     c = datumToString (datum, leftargtype);
     if (c == ((void *)0)) {
       array_free_iterator (iterator);
       return ((void *)0);
     }
   }


   appendStringInfo (&result, "%s%s", first_arg ? "" : ", ", c);
   first_arg = 0;
 }
 array_free_iterator (iterator);


 if (first_arg)
   return ((void *)0);
      }

      break;

    case T_ArrayCoerceExpr:

      arraycoerce = (ArrayCoerceExpr *) rightexpr;






      if (arraycoerce->elemexpr && arraycoerce->elemexpr->type != T_RelabelType)
 return ((void *)0);



      rightexpr = arraycoerce->arg;



    case T_ArrayExpr:

      array = (ArrayExpr *) rightexpr;


      first_arg = 1;
      for ((cell) = list_head(array->elements); (cell) != ((void *)0); (cell) = ((cell)->next)) {

 char *element = deparseExpr (session, foreignrel, (Expr *) ((cell)->data.ptr_value), db2Table, params);


 if (element == ((void *)0))
   return ((void *)0);


 appendStringInfo (&result, "%s%s", first_arg ? "" : ", ", element);
 first_arg = 0;
      }


      if (first_arg)
 return ((void *)0);

      break;

    default:
      return ((void *)0);
    }


    appendStringInfo (&result, "))");

    break;
  case T_DistinctExpr:

    tuple = SearchSysCache1 (OPEROID, ((Datum) (((DistinctExpr *) expr)->opno)));
    if (!((const void*)(tuple) != ((void *)0))) {
      do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 3293, __func__); elog_finish(20, "cache lookup failed for operator %u", ((DistinctExpr *) expr)->opno); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    }
    rightargtype = ((Form_pg_operator) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->oprright;
    ReleaseSysCache (tuple);

    if (!((rightargtype) == 25 || (rightargtype) == 18 || (rightargtype) == 1042 || (rightargtype) == 1043 || (rightargtype) == 19 || (rightargtype) == 20 || (rightargtype) == 21 || (rightargtype) == 23 || (rightargtype) == 26 || (rightargtype) == 700 || (rightargtype) == 701 || (rightargtype) == 1700 || (rightargtype) == 1082 || (rightargtype) == 1083 || (rightargtype) == 1114 || (rightargtype) == 1184 || (rightargtype) == 1186))
      return ((void *)0);

    left = deparseExpr (session, foreignrel, ((list_head(((DistinctExpr *) expr)->args))->data.ptr_value), db2Table, params);
    if (left == ((void *)0)) {
      return ((void *)0);
    }
    right = deparseExpr (session, foreignrel, ((((list_head(((DistinctExpr *) expr)->args))->next))->data.ptr_value), db2Table, params);
    if (right == ((void *)0)) {
      pfree (left);
      return ((void *)0);
    }

    initStringInfo (&result);
    appendStringInfo (&result, "(%s IS DISTINCT FROM %s)", left, right);

    break;
  case T_NullIfExpr:

    tuple = SearchSysCache1 (OPEROID, ((Datum) (((NullIfExpr *) expr)->opno)));
    if (!((const void*)(tuple) != ((void *)0))) {
      do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 3319, __func__); elog_finish(20, "cache lookup failed for operator %u", ((NullIfExpr *) expr)->opno); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    }
    rightargtype = ((Form_pg_operator) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->oprright;
    ReleaseSysCache (tuple);

    if (!((rightargtype) == 25 || (rightargtype) == 18 || (rightargtype) == 1042 || (rightargtype) == 1043 || (rightargtype) == 19 || (rightargtype) == 20 || (rightargtype) == 21 || (rightargtype) == 23 || (rightargtype) == 26 || (rightargtype) == 700 || (rightargtype) == 701 || (rightargtype) == 1700 || (rightargtype) == 1082 || (rightargtype) == 1083 || (rightargtype) == 1114 || (rightargtype) == 1184 || (rightargtype) == 1186))
      return ((void *)0);

    left = deparseExpr (session, foreignrel, ((list_head(((NullIfExpr *) expr)->args))->data.ptr_value), db2Table, params);
    if (left == ((void *)0)) {
      return ((void *)0);
    }
    right = deparseExpr (session, foreignrel, ((((list_head(((NullIfExpr *) expr)->args))->next))->data.ptr_value), db2Table, params);
    if (right == ((void *)0)) {
      pfree (left);
      return ((void *)0);
    }

    initStringInfo (&result);
    appendStringInfo (&result, "NULLIF(%s, %s)", left, right);

    break;
  case T_BoolExpr:
    boolexpr = (BoolExpr *) expr;

    arg = deparseExpr (session, foreignrel, ((list_head(boolexpr->args))->data.ptr_value), db2Table, params);
    if (arg == ((void *)0))
      return ((void *)0);

    initStringInfo (&result);
    appendStringInfo (&result, "(%s%s", boolexpr->boolop == NOT_EXPR ? "NOT " : "", arg);

    for ((cell) = (((list_head (boolexpr->args))->next)); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      arg = deparseExpr (session, foreignrel, (Expr *) ((cell)->data.ptr_value), db2Table, params);
      if (arg == ((void *)0)) {
 pfree (result.data);
 return ((void *)0);
      }

      appendStringInfo (&result, " %s %s", boolexpr->boolop == AND_EXPR ? "AND" : "OR", arg);
    }
    appendStringInfo (&result, ")");

    break;
  case T_RelabelType:
    return deparseExpr (session, foreignrel, ((RelabelType *) expr)->arg, db2Table, params);
    break;
  case T_CoerceToDomain:
    return deparseExpr (session, foreignrel, ((CoerceToDomain *) expr)->arg, db2Table, params);
    break;
  case T_CaseExpr:
    caseexpr = (CaseExpr *) expr;

    if (!((caseexpr->casetype) == 25 || (caseexpr->casetype) == 18 || (caseexpr->casetype) == 1042 || (caseexpr->casetype) == 1043 || (caseexpr->casetype) == 19 || (caseexpr->casetype) == 20 || (caseexpr->casetype) == 21 || (caseexpr->casetype) == 23 || (caseexpr->casetype) == 26 || (caseexpr->casetype) == 700 || (caseexpr->casetype) == 701 || (caseexpr->casetype) == 1700 || (caseexpr->casetype) == 1082 || (caseexpr->casetype) == 1083 || (caseexpr->casetype) == 1114 || (caseexpr->casetype) == 1184 || (caseexpr->casetype) == 1186))
      return ((void *)0);

    initStringInfo (&result);
    appendStringInfo (&result, "CASE");


    if (caseexpr->arg != ((void *)0)) {
      arg = deparseExpr (session, foreignrel, caseexpr->arg, db2Table, params);
      if (arg == ((void *)0)) {
 pfree (result.data);
 return ((void *)0);
      }
      else {
 appendStringInfo (&result, " %s", arg);
      }
    }


    for ((cell) = list_head(caseexpr->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      CaseWhen *whenclause = (CaseWhen *) ((cell)->data.ptr_value);


      if (caseexpr->arg == ((void *)0)) {

 arg = deparseExpr (session, foreignrel, whenclause->expr, db2Table, params);
      }
      else {

 arg = deparseExpr (session, foreignrel, ((((list_head(((OpExpr *) whenclause->expr)->args))->next))->data.ptr_value), db2Table, params);
      }

      if (arg == ((void *)0)) {
 pfree (result.data);
 return ((void *)0);
      }
      else {
 appendStringInfo (&result, " WHEN %s", arg);
 pfree (arg);
      }


      arg = deparseExpr (session, foreignrel, whenclause->result, db2Table, params);
      if (arg == ((void *)0)) {
 pfree (result.data);
 return ((void *)0);
      }
      else {
 appendStringInfo (&result, " THEN %s", arg);
 pfree (arg);
      }
    }


    if (caseexpr->defresult != ((void *)0)) {
      arg = deparseExpr (session, foreignrel, caseexpr->defresult, db2Table, params);
      if (arg == ((void *)0)) {
 pfree (result.data);
 return ((void *)0);
      }
      else {
 appendStringInfo (&result, " ELSE %s", arg);
 pfree (arg);
      }
    }


    appendStringInfo (&result, " END");
    break;
  case T_CoalesceExpr:
    coalesceexpr = (CoalesceExpr *) expr;

    if (!((coalesceexpr->coalescetype) == 25 || (coalesceexpr->coalescetype) == 18 || (coalesceexpr->coalescetype) == 1042 || (coalesceexpr->coalescetype) == 1043 || (coalesceexpr->coalescetype) == 19 || (coalesceexpr->coalescetype) == 20 || (coalesceexpr->coalescetype) == 21 || (coalesceexpr->coalescetype) == 23 || (coalesceexpr->coalescetype) == 26 || (coalesceexpr->coalescetype) == 700 || (coalesceexpr->coalescetype) == 701 || (coalesceexpr->coalescetype) == 1700 || (coalesceexpr->coalescetype) == 1082 || (coalesceexpr->coalescetype) == 1083 || (coalesceexpr->coalescetype) == 1114 || (coalesceexpr->coalescetype) == 1184 || (coalesceexpr->coalescetype) == 1186))
      return ((void *)0);

    initStringInfo (&result);
    appendStringInfo (&result, "COALESCE(");

    first_arg = 1;
    for ((cell) = list_head(coalesceexpr->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      arg = deparseExpr (session, foreignrel, (Expr *) ((cell)->data.ptr_value), db2Table, params);
      if (arg == ((void *)0)) {
 pfree (result.data);
 return ((void *)0);
      }

      if (first_arg) {
 appendStringInfo (&result, "%s", arg);
 first_arg = 0;
      }
      else {
 appendStringInfo (&result, ", %s", arg);
      }
      pfree (arg);
    }

    appendStringInfo (&result, ")");

    break;
  case T_NullTest:
    arg = deparseExpr (session, foreignrel, ((NullTest *) expr)->arg, db2Table, params);
    if (arg == ((void *)0))
      return ((void *)0);

    initStringInfo (&result);
    appendStringInfo (&result, "(%s IS %sNULL)", arg, ((NullTest *) expr)->nulltesttype == IS_NOT_NULL ? "NOT " : "");
    break;
  case T_FuncExpr:
    func = (FuncExpr *) expr;

    if (!((func->funcresulttype) == 25 || (func->funcresulttype) == 18 || (func->funcresulttype) == 1042 || (func->funcresulttype) == 1043 || (func->funcresulttype) == 19 || (func->funcresulttype) == 20 || (func->funcresulttype) == 21 || (func->funcresulttype) == 23 || (func->funcresulttype) == 26 || (func->funcresulttype) == 700 || (func->funcresulttype) == 701 || (func->funcresulttype) == 1700 || (func->funcresulttype) == 1082 || (func->funcresulttype) == 1083 || (func->funcresulttype) == 1114 || (func->funcresulttype) == 1184 || (func->funcresulttype) == 1186))
      return ((void *)0);


    if (func->funcformat == COERCE_IMPLICIT_CAST)
      return deparseExpr (session, foreignrel, ((list_head(func->args))->data.ptr_value), db2Table, params);


    tuple = SearchSysCache1 (PROCOID, ((Datum) (func->funcid)));
    if (!((const void*)(tuple) != ((void *)0))) {
      do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 3492, __func__); elog_finish(20, "cache lookup failed for function %u", func->funcid); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    }
    opername = pstrdup (((Form_pg_proc) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->proname.data);
    schema = ((Form_pg_proc) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->pronamespace;
    ReleaseSysCache (tuple);


    if (schema != 11)
      return ((void *)0);


    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("abs") && (__s1_len = strlen (opername), __s2_len = strlen ("abs"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("abs") + 1) - (size_t)(const void *)("abs") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "abs") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("abs") && ((size_t)(const void *)(("abs") + 1) - (size_t)(const void *)("abs") == 1) ? __builtin_strcmp (opername, "abs") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("abs"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("abs") && ((size_t)(const void *)(("abs") + 1) - (size_t)(const void *)("abs") == 1) && (__s2_len = strlen ("abs"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "abs") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("abs"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("abs"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("abs"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("abs"))[3]); } } __result; }))) : __builtin_strcmp (opername, "abs")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("acos") && (__s1_len = strlen (opername), __s2_len = strlen ("acos"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("acos") + 1) - (size_t)(const void *)("acos") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "acos") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("acos") && ((size_t)(const void *)(("acos") + 1) - (size_t)(const void *)("acos") == 1) ? __builtin_strcmp (opername, "acos") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("acos"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("acos") && ((size_t)(const void *)(("acos") + 1) - (size_t)(const void *)("acos") == 1) && (__s2_len = strlen ("acos"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "acos") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("acos"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("acos"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("acos"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("acos"))[3]); } } __result; }))) : __builtin_strcmp (opername, "acos")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("asin") && (__s1_len = strlen (opername), __s2_len = strlen ("asin"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("asin") + 1) - (size_t)(const void *)("asin") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "asin") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("asin") && ((size_t)(const void *)(("asin") + 1) - (size_t)(const void *)("asin") == 1) ? __builtin_strcmp (opername, "asin") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("asin"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("asin") && ((size_t)(const void *)(("asin") + 1) - (size_t)(const void *)("asin") == 1) && (__s2_len = strlen ("asin"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "asin") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("asin"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("asin"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("asin"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("asin"))[3]); } } __result; }))) : __builtin_strcmp (opername, "asin")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("atan") && (__s1_len = strlen (opername), __s2_len = strlen ("atan"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("atan") + 1) - (size_t)(const void *)("atan") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "atan") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("atan") && ((size_t)(const void *)(("atan") + 1) - (size_t)(const void *)("atan") == 1) ? __builtin_strcmp (opername, "atan") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("atan"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("atan") && ((size_t)(const void *)(("atan") + 1) - (size_t)(const void *)("atan") == 1) && (__s2_len = strlen ("atan"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "atan") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("atan"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("atan"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("atan"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("atan"))[3]); } } __result; }))) : __builtin_strcmp (opername, "atan")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("atan2") && (__s1_len = strlen (opername), __s2_len = strlen ("atan2"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("atan2") + 1) - (size_t)(const void *)("atan2") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "atan2") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("atan2") && ((size_t)(const void *)(("atan2") + 1) - (size_t)(const void *)("atan2") == 1) ? __builtin_strcmp (opername, "atan2") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("atan2"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("atan2") && ((size_t)(const void *)(("atan2") + 1) - (size_t)(const void *)("atan2") == 1) && (__s2_len = strlen ("atan2"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "atan2") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("atan2"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("atan2"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("atan2"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("atan2"))[3]); } } __result; }))) : __builtin_strcmp (opername, "atan2")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("ceil") && (__s1_len = strlen (opername), __s2_len = strlen ("ceil"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("ceil") + 1) - (size_t)(const void *)("ceil") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "ceil") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("ceil") && ((size_t)(const void *)(("ceil") + 1) - (size_t)(const void *)("ceil") == 1) ? __builtin_strcmp (opername, "ceil") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("ceil"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("ceil") && ((size_t)(const void *)(("ceil") + 1) - (size_t)(const void *)("ceil") == 1) && (__s2_len = strlen ("ceil"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "ceil") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("ceil"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("ceil"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("ceil"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("ceil"))[3]); } } __result; }))) : __builtin_strcmp (opername, "ceil")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("ceiling") && (__s1_len = strlen (opername), __s2_len = strlen ("ceiling"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("ceiling") + 1) - (size_t)(const void *)("ceiling") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "ceiling") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("ceiling") && ((size_t)(const void *)(("ceiling") + 1) - (size_t)(const void *)("ceiling") == 1) ? __builtin_strcmp (opername, "ceiling") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("ceiling"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("ceiling") && ((size_t)(const void *)(("ceiling") + 1) - (size_t)(const void *)("ceiling") == 1) && (__s2_len = strlen ("ceiling"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "ceiling") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("ceiling"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("ceiling"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("ceiling"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("ceiling"))[3]); } } __result; }))) : __builtin_strcmp (opername, "ceiling")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("char_length") && (__s1_len = strlen (opername), __s2_len = strlen ("char_length"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("char_length") + 1) - (size_t)(const void *)("char_length") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "char_length") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("char_length") && ((size_t)(const void *)(("char_length") + 1) - (size_t)(const void *)("char_length") == 1) ? __builtin_strcmp (opername, "char_length") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("char_length"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("char_length") && ((size_t)(const void *)(("char_length") + 1) - (size_t)(const void *)("char_length") == 1) && (__s2_len = strlen ("char_length"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "char_length") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("char_length"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("char_length"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("char_length"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("char_length"))[3]); } } __result; }))) : __builtin_strcmp (opername, "char_length")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("character_length") && (__s1_len = strlen (opername), __s2_len = strlen ("character_length"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("character_length") + 1) - (size_t)(const void *)("character_length") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "character_length") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("character_length") && ((size_t)(const void *)(("character_length") + 1) - (size_t)(const void *)("character_length") == 1) ? __builtin_strcmp (opername, "character_length") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("character_length"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("character_length") && ((size_t)(const void *)(("character_length") + 1) - (size_t)(const void *)("character_length") == 1) && (__s2_len = strlen ("character_length"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "character_length") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("character_length"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("character_length"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("character_length"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("character_length"))[3]); } } __result; }))) : __builtin_strcmp (opername, "character_length")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("concat") && (__s1_len = strlen (opername), __s2_len = strlen ("concat"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("concat") + 1) - (size_t)(const void *)("concat") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "concat") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("concat") && ((size_t)(const void *)(("concat") + 1) - (size_t)(const void *)("concat") == 1) ? __builtin_strcmp (opername, "concat") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("concat"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("concat") && ((size_t)(const void *)(("concat") + 1) - (size_t)(const void *)("concat") == 1) && (__s2_len = strlen ("concat"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "concat") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("concat"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("concat"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("concat"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("concat"))[3]); } } __result; }))) : __builtin_strcmp (opername, "concat")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("cos") && (__s1_len = strlen (opername), __s2_len = strlen ("cos"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("cos") + 1) - (size_t)(const void *)("cos") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "cos") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("cos") && ((size_t)(const void *)(("cos") + 1) - (size_t)(const void *)("cos") == 1) ? __builtin_strcmp (opername, "cos") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("cos"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("cos") && ((size_t)(const void *)(("cos") + 1) - (size_t)(const void *)("cos") == 1) && (__s2_len = strlen ("cos"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "cos") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("cos"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("cos"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("cos"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("cos"))[3]); } } __result; }))) : __builtin_strcmp (opername, "cos")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("exp") && (__s1_len = strlen (opername), __s2_len = strlen ("exp"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("exp") + 1) - (size_t)(const void *)("exp") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "exp") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("exp") && ((size_t)(const void *)(("exp") + 1) - (size_t)(const void *)("exp") == 1) ? __builtin_strcmp (opername, "exp") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("exp"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("exp") && ((size_t)(const void *)(("exp") + 1) - (size_t)(const void *)("exp") == 1) && (__s2_len = strlen ("exp"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "exp") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("exp"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("exp"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("exp"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("exp"))[3]); } } __result; }))) : __builtin_strcmp (opername, "exp")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("initcap") && (__s1_len = strlen (opername), __s2_len = strlen ("initcap"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("initcap") + 1) - (size_t)(const void *)("initcap") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "initcap") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("initcap") && ((size_t)(const void *)(("initcap") + 1) - (size_t)(const void *)("initcap") == 1) ? __builtin_strcmp (opername, "initcap") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("initcap"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("initcap") && ((size_t)(const void *)(("initcap") + 1) - (size_t)(const void *)("initcap") == 1) && (__s2_len = strlen ("initcap"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "initcap") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("initcap"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("initcap"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("initcap"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("initcap"))[3]); } } __result; }))) : __builtin_strcmp (opername, "initcap")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("length") && (__s1_len = strlen (opername), __s2_len = strlen ("length"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("length") + 1) - (size_t)(const void *)("length") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "length") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("length") && ((size_t)(const void *)(("length") + 1) - (size_t)(const void *)("length") == 1) ? __builtin_strcmp (opername, "length") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("length"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("length") && ((size_t)(const void *)(("length") + 1) - (size_t)(const void *)("length") == 1) && (__s2_len = strlen ("length"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "length") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("length"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("length"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("length"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("length"))[3]); } } __result; }))) : __builtin_strcmp (opername, "length")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("lower") && (__s1_len = strlen (opername), __s2_len = strlen ("lower"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("lower") + 1) - (size_t)(const void *)("lower") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "lower") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("lower") && ((size_t)(const void *)(("lower") + 1) - (size_t)(const void *)("lower") == 1) ? __builtin_strcmp (opername, "lower") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("lower"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("lower") && ((size_t)(const void *)(("lower") + 1) - (size_t)(const void *)("lower") == 1) && (__s2_len = strlen ("lower"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "lower") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("lower"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("lower"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("lower"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("lower"))[3]); } } __result; }))) : __builtin_strcmp (opername, "lower")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("lpad") && (__s1_len = strlen (opername), __s2_len = strlen ("lpad"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("lpad") + 1) - (size_t)(const void *)("lpad") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "lpad") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("lpad") && ((size_t)(const void *)(("lpad") + 1) - (size_t)(const void *)("lpad") == 1) ? __builtin_strcmp (opername, "lpad") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("lpad"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("lpad") && ((size_t)(const void *)(("lpad") + 1) - (size_t)(const void *)("lpad") == 1) && (__s2_len = strlen ("lpad"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "lpad") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("lpad"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("lpad"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("lpad"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("lpad"))[3]); } } __result; }))) : __builtin_strcmp (opername, "lpad")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("ltrim") && (__s1_len = strlen (opername), __s2_len = strlen ("ltrim"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("ltrim") + 1) - (size_t)(const void *)("ltrim") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "ltrim") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("ltrim") && ((size_t)(const void *)(("ltrim") + 1) - (size_t)(const void *)("ltrim") == 1) ? __builtin_strcmp (opername, "ltrim") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("ltrim"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("ltrim") && ((size_t)(const void *)(("ltrim") + 1) - (size_t)(const void *)("ltrim") == 1) && (__s2_len = strlen ("ltrim"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "ltrim") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("ltrim"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("ltrim"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("ltrim"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("ltrim"))[3]); } } __result; }))) : __builtin_strcmp (opername, "ltrim")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("mod") && (__s1_len = strlen (opername), __s2_len = strlen ("mod"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("mod") + 1) - (size_t)(const void *)("mod") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "mod") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("mod") && ((size_t)(const void *)(("mod") + 1) - (size_t)(const void *)("mod") == 1) ? __builtin_strcmp (opername, "mod") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("mod"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("mod") && ((size_t)(const void *)(("mod") + 1) - (size_t)(const void *)("mod") == 1) && (__s2_len = strlen ("mod"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "mod") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("mod"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("mod"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("mod"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("mod"))[3]); } } __result; }))) : __builtin_strcmp (opername, "mod")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("octet_length") && (__s1_len = strlen (opername), __s2_len = strlen ("octet_length"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("octet_length") + 1) - (size_t)(const void *)("octet_length") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "octet_length") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("octet_length") && ((size_t)(const void *)(("octet_length") + 1) - (size_t)(const void *)("octet_length") == 1) ? __builtin_strcmp (opername, "octet_length") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("octet_length"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("octet_length") && ((size_t)(const void *)(("octet_length") + 1) - (size_t)(const void *)("octet_length") == 1) && (__s2_len = strlen ("octet_length"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "octet_length") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("octet_length"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("octet_length"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("octet_length"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("octet_length"))[3]); } } __result; }))) : __builtin_strcmp (opername, "octet_length")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("position") && (__s1_len = strlen (opername), __s2_len = strlen ("position"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("position") + 1) - (size_t)(const void *)("position") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "position") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("position") && ((size_t)(const void *)(("position") + 1) - (size_t)(const void *)("position") == 1) ? __builtin_strcmp (opername, "position") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("position"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("position") && ((size_t)(const void *)(("position") + 1) - (size_t)(const void *)("position") == 1) && (__s2_len = strlen ("position"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "position") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("position"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("position"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("position"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("position"))[3]); } } __result; }))) : __builtin_strcmp (opername, "position")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("pow") && (__s1_len = strlen (opername), __s2_len = strlen ("pow"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("pow") + 1) - (size_t)(const void *)("pow") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "pow") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("pow") && ((size_t)(const void *)(("pow") + 1) - (size_t)(const void *)("pow") == 1) ? __builtin_strcmp (opername, "pow") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("pow"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("pow") && ((size_t)(const void *)(("pow") + 1) - (size_t)(const void *)("pow") == 1) && (__s2_len = strlen ("pow"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "pow") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("pow"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("pow"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("pow"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("pow"))[3]); } } __result; }))) : __builtin_strcmp (opername, "pow")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("power") && (__s1_len = strlen (opername), __s2_len = strlen ("power"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("power") + 1) - (size_t)(const void *)("power") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "power") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("power") && ((size_t)(const void *)(("power") + 1) - (size_t)(const void *)("power") == 1) ? __builtin_strcmp (opername, "power") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("power"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("power") && ((size_t)(const void *)(("power") + 1) - (size_t)(const void *)("power") == 1) && (__s2_len = strlen ("power"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "power") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("power"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("power"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("power"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("power"))[3]); } } __result; }))) : __builtin_strcmp (opername, "power")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("replace") && (__s1_len = strlen (opername), __s2_len = strlen ("replace"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("replace") + 1) - (size_t)(const void *)("replace") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "replace") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("replace") && ((size_t)(const void *)(("replace") + 1) - (size_t)(const void *)("replace") == 1) ? __builtin_strcmp (opername, "replace") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("replace"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("replace") && ((size_t)(const void *)(("replace") + 1) - (size_t)(const void *)("replace") == 1) && (__s2_len = strlen ("replace"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "replace") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("replace"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("replace"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("replace"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("replace"))[3]); } } __result; }))) : __builtin_strcmp (opername, "replace")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("round") && (__s1_len = strlen (opername), __s2_len = strlen ("round"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("round") + 1) - (size_t)(const void *)("round") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "round") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("round") && ((size_t)(const void *)(("round") + 1) - (size_t)(const void *)("round") == 1) ? __builtin_strcmp (opername, "round") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("round"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("round") && ((size_t)(const void *)(("round") + 1) - (size_t)(const void *)("round") == 1) && (__s2_len = strlen ("round"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "round") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("round"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("round"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("round"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("round"))[3]); } } __result; }))) : __builtin_strcmp (opername, "round")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("rpad") && (__s1_len = strlen (opername), __s2_len = strlen ("rpad"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("rpad") + 1) - (size_t)(const void *)("rpad") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "rpad") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("rpad") && ((size_t)(const void *)(("rpad") + 1) - (size_t)(const void *)("rpad") == 1) ? __builtin_strcmp (opername, "rpad") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("rpad"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("rpad") && ((size_t)(const void *)(("rpad") + 1) - (size_t)(const void *)("rpad") == 1) && (__s2_len = strlen ("rpad"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "rpad") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("rpad"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("rpad"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("rpad"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("rpad"))[3]); } } __result; }))) : __builtin_strcmp (opername, "rpad")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("rtrim") && (__s1_len = strlen (opername), __s2_len = strlen ("rtrim"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("rtrim") + 1) - (size_t)(const void *)("rtrim") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "rtrim") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("rtrim") && ((size_t)(const void *)(("rtrim") + 1) - (size_t)(const void *)("rtrim") == 1) ? __builtin_strcmp (opername, "rtrim") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("rtrim"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("rtrim") && ((size_t)(const void *)(("rtrim") + 1) - (size_t)(const void *)("rtrim") == 1) && (__s2_len = strlen ("rtrim"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "rtrim") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("rtrim"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("rtrim"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("rtrim"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("rtrim"))[3]); } } __result; }))) : __builtin_strcmp (opername, "rtrim")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("sign") && (__s1_len = strlen (opername), __s2_len = strlen ("sign"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("sign") + 1) - (size_t)(const void *)("sign") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "sign") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("sign") && ((size_t)(const void *)(("sign") + 1) - (size_t)(const void *)("sign") == 1) ? __builtin_strcmp (opername, "sign") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("sign"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("sign") && ((size_t)(const void *)(("sign") + 1) - (size_t)(const void *)("sign") == 1) && (__s2_len = strlen ("sign"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "sign") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("sign"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("sign"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("sign"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("sign"))[3]); } } __result; }))) : __builtin_strcmp (opername, "sign")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("sin") && (__s1_len = strlen (opername), __s2_len = strlen ("sin"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("sin") + 1) - (size_t)(const void *)("sin") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "sin") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("sin") && ((size_t)(const void *)(("sin") + 1) - (size_t)(const void *)("sin") == 1) ? __builtin_strcmp (opername, "sin") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("sin"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("sin") && ((size_t)(const void *)(("sin") + 1) - (size_t)(const void *)("sin") == 1) && (__s2_len = strlen ("sin"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "sin") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("sin"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("sin"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("sin"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("sin"))[3]); } } __result; }))) : __builtin_strcmp (opername, "sin")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("sqrt") && (__s1_len = strlen (opername), __s2_len = strlen ("sqrt"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("sqrt") + 1) - (size_t)(const void *)("sqrt") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "sqrt") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("sqrt") && ((size_t)(const void *)(("sqrt") + 1) - (size_t)(const void *)("sqrt") == 1) ? __builtin_strcmp (opername, "sqrt") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("sqrt"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("sqrt") && ((size_t)(const void *)(("sqrt") + 1) - (size_t)(const void *)("sqrt") == 1) && (__s2_len = strlen ("sqrt"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "sqrt") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("sqrt"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("sqrt"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("sqrt"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("sqrt"))[3]); } } __result; }))) : __builtin_strcmp (opername, "sqrt")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("strpos") && (__s1_len = strlen (opername), __s2_len = strlen ("strpos"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("strpos") + 1) - (size_t)(const void *)("strpos") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "strpos") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("strpos") && ((size_t)(const void *)(("strpos") + 1) - (size_t)(const void *)("strpos") == 1) ? __builtin_strcmp (opername, "strpos") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("strpos"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("strpos") && ((size_t)(const void *)(("strpos") + 1) - (size_t)(const void *)("strpos") == 1) && (__s2_len = strlen ("strpos"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "strpos") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("strpos"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("strpos"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("strpos"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("strpos"))[3]); } } __result; }))) : __builtin_strcmp (opername, "strpos")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("substr") && (__s1_len = strlen (opername), __s2_len = strlen ("substr"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("substr") + 1) - (size_t)(const void *)("substr") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "substr") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("substr") && ((size_t)(const void *)(("substr") + 1) - (size_t)(const void *)("substr") == 1) ? __builtin_strcmp (opername, "substr") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("substr"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("substr") && ((size_t)(const void *)(("substr") + 1) - (size_t)(const void *)("substr") == 1) && (__s2_len = strlen ("substr"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "substr") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("substr"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("substr"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("substr"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("substr"))[3]); } } __result; }))) : __builtin_strcmp (opername, "substr")))); }) == 0 || (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("substring") && (__s1_len = strlen (opername), __s2_len = strlen ("substring"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("substring") + 1) - (size_t)(const void *)("substring") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "substring") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("substring") && ((size_t)(const void *)(("substring") + 1) - (size_t)(const void *)("substring") == 1) ? __builtin_strcmp (opername, "substring") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("substring"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("substring") && ((size_t)(const void *)(("substring") + 1) - (size_t)(const void *)("substring") == 1) && (__s2_len = strlen ("substring"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "substring") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("substring"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("substring"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("substring"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("substring"))[3]); } } __result; }))) : __builtin_strcmp (opername, "substring")))); }) == 0 && list_length (func->args) == 3)
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("tan") && (__s1_len = strlen (opername), __s2_len = strlen ("tan"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("tan") + 1) - (size_t)(const void *)("tan") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "tan") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("tan") && ((size_t)(const void *)(("tan") + 1) - (size_t)(const void *)("tan") == 1) ? __builtin_strcmp (opername, "tan") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("tan"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("tan") && ((size_t)(const void *)(("tan") + 1) - (size_t)(const void *)("tan") == 1) && (__s2_len = strlen ("tan"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "tan") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("tan"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("tan"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("tan"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("tan"))[3]); } } __result; }))) : __builtin_strcmp (opername, "tan")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("to_char") && (__s1_len = strlen (opername), __s2_len = strlen ("to_char"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("to_char") + 1) - (size_t)(const void *)("to_char") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "to_char") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("to_char") && ((size_t)(const void *)(("to_char") + 1) - (size_t)(const void *)("to_char") == 1) ? __builtin_strcmp (opername, "to_char") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("to_char"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("to_char") && ((size_t)(const void *)(("to_char") + 1) - (size_t)(const void *)("to_char") == 1) && (__s2_len = strlen ("to_char"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "to_char") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("to_char"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("to_char"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("to_char"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("to_char"))[3]); } } __result; }))) : __builtin_strcmp (opername, "to_char")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("to_date") && (__s1_len = strlen (opername), __s2_len = strlen ("to_date"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("to_date") + 1) - (size_t)(const void *)("to_date") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "to_date") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("to_date") && ((size_t)(const void *)(("to_date") + 1) - (size_t)(const void *)("to_date") == 1) ? __builtin_strcmp (opername, "to_date") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("to_date"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("to_date") && ((size_t)(const void *)(("to_date") + 1) - (size_t)(const void *)("to_date") == 1) && (__s2_len = strlen ("to_date"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "to_date") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("to_date"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("to_date"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("to_date"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("to_date"))[3]); } } __result; }))) : __builtin_strcmp (opername, "to_date")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("to_number") && (__s1_len = strlen (opername), __s2_len = strlen ("to_number"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("to_number") + 1) - (size_t)(const void *)("to_number") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "to_number") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("to_number") && ((size_t)(const void *)(("to_number") + 1) - (size_t)(const void *)("to_number") == 1) ? __builtin_strcmp (opername, "to_number") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("to_number"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("to_number") && ((size_t)(const void *)(("to_number") + 1) - (size_t)(const void *)("to_number") == 1) && (__s2_len = strlen ("to_number"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "to_number") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("to_number"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("to_number"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("to_number"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("to_number"))[3]); } } __result; }))) : __builtin_strcmp (opername, "to_number")))); }) == 0
 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("to_timestamp") && (__s1_len = strlen (opername), __s2_len = strlen ("to_timestamp"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("to_timestamp") + 1) - (size_t)(const void *)("to_timestamp") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "to_timestamp") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("to_timestamp") && ((size_t)(const void *)(("to_timestamp") + 1) - (size_t)(const void *)("to_timestamp") == 1) ? __builtin_strcmp (opername, "to_timestamp") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("to_timestamp"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("to_timestamp") && ((size_t)(const void *)(("to_timestamp") + 1) - (size_t)(const void *)("to_timestamp") == 1) && (__s2_len = strlen ("to_timestamp"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "to_timestamp") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("to_timestamp"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("to_timestamp"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("to_timestamp"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("to_timestamp"))[3]); } } __result; }))) : __builtin_strcmp (opername, "to_timestamp")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("translate") && (__s1_len = strlen (opername), __s2_len = strlen ("translate"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("translate") + 1) - (size_t)(const void *)("translate") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "translate") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("translate") && ((size_t)(const void *)(("translate") + 1) - (size_t)(const void *)("translate") == 1) ? __builtin_strcmp (opername, "translate") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("translate"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("translate") && ((size_t)(const void *)(("translate") + 1) - (size_t)(const void *)("translate") == 1) && (__s2_len = strlen ("translate"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "translate") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("translate"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("translate"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("translate"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("translate"))[3]); } } __result; }))) : __builtin_strcmp (opername, "translate")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("trunc") && (__s1_len = strlen (opername), __s2_len = strlen ("trunc"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("trunc") + 1) - (size_t)(const void *)("trunc") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "trunc") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("trunc") && ((size_t)(const void *)(("trunc") + 1) - (size_t)(const void *)("trunc") == 1) ? __builtin_strcmp (opername, "trunc") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("trunc"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("trunc") && ((size_t)(const void *)(("trunc") + 1) - (size_t)(const void *)("trunc") == 1) && (__s2_len = strlen ("trunc"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "trunc") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("trunc"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("trunc"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("trunc"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("trunc"))[3]); } } __result; }))) : __builtin_strcmp (opername, "trunc")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("upper") && (__s1_len = strlen (opername), __s2_len = strlen ("upper"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("upper") + 1) - (size_t)(const void *)("upper") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "upper") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("upper") && ((size_t)(const void *)(("upper") + 1) - (size_t)(const void *)("upper") == 1) ? __builtin_strcmp (opername, "upper") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("upper"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("upper") && ((size_t)(const void *)(("upper") + 1) - (size_t)(const void *)("upper") == 1) && (__s2_len = strlen ("upper"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "upper") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("upper"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("upper"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("upper"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("upper"))[3]); } } __result; }))) : __builtin_strcmp (opername, "upper")))); }) == 0) {
      initStringInfo (&result);

      if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("ceiling") && (__s1_len = strlen (opername), __s2_len = strlen ("ceiling"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("ceiling") + 1) - (size_t)(const void *)("ceiling") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "ceiling") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("ceiling") && ((size_t)(const void *)(("ceiling") + 1) - (size_t)(const void *)("ceiling") == 1) ? __builtin_strcmp (opername, "ceiling") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("ceiling"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("ceiling") && ((size_t)(const void *)(("ceiling") + 1) - (size_t)(const void *)("ceiling") == 1) && (__s2_len = strlen ("ceiling"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "ceiling") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("ceiling"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("ceiling"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("ceiling"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("ceiling"))[3]); } } __result; }))) : __builtin_strcmp (opername, "ceiling")))); }) == 0)
 appendStringInfo (&result, "CEIL(");
      else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("char_length") && (__s1_len = strlen (opername), __s2_len = strlen ("char_length"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("char_length") + 1) - (size_t)(const void *)("char_length") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "char_length") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("char_length") && ((size_t)(const void *)(("char_length") + 1) - (size_t)(const void *)("char_length") == 1) ? __builtin_strcmp (opername, "char_length") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("char_length"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("char_length") && ((size_t)(const void *)(("char_length") + 1) - (size_t)(const void *)("char_length") == 1) && (__s2_len = strlen ("char_length"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "char_length") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("char_length"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("char_length"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("char_length"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("char_length"))[3]); } } __result; }))) : __builtin_strcmp (opername, "char_length")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("character_length") && (__s1_len = strlen (opername), __s2_len = strlen ("character_length"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("character_length") + 1) - (size_t)(const void *)("character_length") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "character_length") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("character_length") && ((size_t)(const void *)(("character_length") + 1) - (size_t)(const void *)("character_length") == 1) ? __builtin_strcmp (opername, "character_length") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("character_length"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("character_length") && ((size_t)(const void *)(("character_length") + 1) - (size_t)(const void *)("character_length") == 1) && (__s2_len = strlen ("character_length"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "character_length") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("character_length"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("character_length"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("character_length"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("character_length"))[3]); } } __result; }))) : __builtin_strcmp (opername, "character_length")))); }) == 0)
 appendStringInfo (&result, "LENGTH(");
      else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("pow") && (__s1_len = strlen (opername), __s2_len = strlen ("pow"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("pow") + 1) - (size_t)(const void *)("pow") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "pow") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("pow") && ((size_t)(const void *)(("pow") + 1) - (size_t)(const void *)("pow") == 1) ? __builtin_strcmp (opername, "pow") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("pow"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("pow") && ((size_t)(const void *)(("pow") + 1) - (size_t)(const void *)("pow") == 1) && (__s2_len = strlen ("pow"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "pow") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("pow"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("pow"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("pow"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("pow"))[3]); } } __result; }))) : __builtin_strcmp (opername, "pow")))); }) == 0)
 appendStringInfo (&result, "POWER(");
      else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("octet_length") && (__s1_len = strlen (opername), __s2_len = strlen ("octet_length"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("octet_length") + 1) - (size_t)(const void *)("octet_length") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "octet_length") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("octet_length") && ((size_t)(const void *)(("octet_length") + 1) - (size_t)(const void *)("octet_length") == 1) ? __builtin_strcmp (opername, "octet_length") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("octet_length"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("octet_length") && ((size_t)(const void *)(("octet_length") + 1) - (size_t)(const void *)("octet_length") == 1) && (__s2_len = strlen ("octet_length"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "octet_length") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("octet_length"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("octet_length"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("octet_length"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("octet_length"))[3]); } } __result; }))) : __builtin_strcmp (opername, "octet_length")))); }) == 0)
 appendStringInfo (&result, "LENGTHB(");
      else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("position") && (__s1_len = strlen (opername), __s2_len = strlen ("position"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("position") + 1) - (size_t)(const void *)("position") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "position") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("position") && ((size_t)(const void *)(("position") + 1) - (size_t)(const void *)("position") == 1) ? __builtin_strcmp (opername, "position") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("position"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("position") && ((size_t)(const void *)(("position") + 1) - (size_t)(const void *)("position") == 1) && (__s2_len = strlen ("position"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "position") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("position"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("position"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("position"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("position"))[3]); } } __result; }))) : __builtin_strcmp (opername, "position")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("strpos") && (__s1_len = strlen (opername), __s2_len = strlen ("strpos"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("strpos") + 1) - (size_t)(const void *)("strpos") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "strpos") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("strpos") && ((size_t)(const void *)(("strpos") + 1) - (size_t)(const void *)("strpos") == 1) ? __builtin_strcmp (opername, "strpos") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("strpos"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("strpos") && ((size_t)(const void *)(("strpos") + 1) - (size_t)(const void *)("strpos") == 1) && (__s2_len = strlen ("strpos"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "strpos") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("strpos"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("strpos"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("strpos"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("strpos"))[3]); } } __result; }))) : __builtin_strcmp (opername, "strpos")))); }) == 0)
 appendStringInfo (&result, "INSTR(");
      else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("substring") && (__s1_len = strlen (opername), __s2_len = strlen ("substring"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("substring") + 1) - (size_t)(const void *)("substring") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "substring") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("substring") && ((size_t)(const void *)(("substring") + 1) - (size_t)(const void *)("substring") == 1) ? __builtin_strcmp (opername, "substring") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("substring"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("substring") && ((size_t)(const void *)(("substring") + 1) - (size_t)(const void *)("substring") == 1) && (__s2_len = strlen ("substring"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "substring") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("substring"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("substring"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("substring"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("substring"))[3]); } } __result; }))) : __builtin_strcmp (opername, "substring")))); }) == 0)
 appendStringInfo (&result, "SUBSTR(");
      else
 appendStringInfo (&result, "%s(", opername);

      first_arg = 1;
      for ((cell) = list_head(func->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
 arg = deparseExpr (session, foreignrel, ((cell)->data.ptr_value), db2Table, params);
 if (arg == ((void *)0)) {
   pfree (result.data);
   pfree (opername);
   return ((void *)0);
 }

 if (first_arg) {
   first_arg = 0;
   appendStringInfo (&result, "%s", arg);
 }
 else {
   appendStringInfo (&result, ", %s", arg);
 }
 pfree (arg);
      }

      appendStringInfo (&result, ")");
    }
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("date_part") && (__s1_len = strlen (opername), __s2_len = strlen ("date_part"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("date_part") + 1) - (size_t)(const void *)("date_part") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "date_part") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("date_part") && ((size_t)(const void *)(("date_part") + 1) - (size_t)(const void *)("date_part") == 1) ? __builtin_strcmp (opername, "date_part") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("date_part"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("date_part") && ((size_t)(const void *)(("date_part") + 1) - (size_t)(const void *)("date_part") == 1) && (__s2_len = strlen ("date_part"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "date_part") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("date_part"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("date_part"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("date_part"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("date_part"))[3]); } } __result; }))) : __builtin_strcmp (opername, "date_part")))); }) == 0) {

      left = deparseExpr (session, foreignrel, ((list_head(func->args))->data.ptr_value), db2Table, params);
      if (left == ((void *)0)) {
 pfree (opername);
 return ((void *)0);
      }


      if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (left) && __builtin_constant_p ("'year'") && (__s1_len = strlen (left), __s2_len = strlen ("'year'"), (!((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("'year'") + 1) - (size_t)(const void *)("'year'") == 1) || __s2_len >= 4)) ? __builtin_strcmp (left, "'year'") : (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) && (__s1_len = strlen (left), __s1_len < 4) ? (__builtin_constant_p ("'year'") && ((size_t)(const void *)(("'year'") + 1) - (size_t)(const void *)("'year'") == 1) ? __builtin_strcmp (left, "'year'") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("'year'"); int __result = (((const unsigned char *) (const char *) (left))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (left))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("'year'") && ((size_t)(const void *)(("'year'") + 1) - (size_t)(const void *)("'year'") == 1) && (__s2_len = strlen ("'year'"), __s2_len < 4) ? (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) ? __builtin_strcmp (left, "'year'") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (left); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("'year'"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("'year'"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("'year'"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("'year'"))[3]); } } __result; }))) : __builtin_strcmp (left, "'year'")))); }) == 0
   || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (left) && __builtin_constant_p ("'month'") && (__s1_len = strlen (left), __s2_len = strlen ("'month'"), (!((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("'month'") + 1) - (size_t)(const void *)("'month'") == 1) || __s2_len >= 4)) ? __builtin_strcmp (left, "'month'") : (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) && (__s1_len = strlen (left), __s1_len < 4) ? (__builtin_constant_p ("'month'") && ((size_t)(const void *)(("'month'") + 1) - (size_t)(const void *)("'month'") == 1) ? __builtin_strcmp (left, "'month'") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("'month'"); int __result = (((const unsigned char *) (const char *) (left))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (left))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("'month'") && ((size_t)(const void *)(("'month'") + 1) - (size_t)(const void *)("'month'") == 1) && (__s2_len = strlen ("'month'"), __s2_len < 4) ? (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) ? __builtin_strcmp (left, "'month'") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (left); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("'month'"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("'month'"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("'month'"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("'month'"))[3]); } } __result; }))) : __builtin_strcmp (left, "'month'")))); }) == 0
   || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (left) && __builtin_constant_p ("'day'") && (__s1_len = strlen (left), __s2_len = strlen ("'day'"), (!((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("'day'") + 1) - (size_t)(const void *)("'day'") == 1) || __s2_len >= 4)) ? __builtin_strcmp (left, "'day'") : (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) && (__s1_len = strlen (left), __s1_len < 4) ? (__builtin_constant_p ("'day'") && ((size_t)(const void *)(("'day'") + 1) - (size_t)(const void *)("'day'") == 1) ? __builtin_strcmp (left, "'day'") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("'day'"); int __result = (((const unsigned char *) (const char *) (left))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (left))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("'day'") && ((size_t)(const void *)(("'day'") + 1) - (size_t)(const void *)("'day'") == 1) && (__s2_len = strlen ("'day'"), __s2_len < 4) ? (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) ? __builtin_strcmp (left, "'day'") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (left); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("'day'"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("'day'"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("'day'"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("'day'"))[3]); } } __result; }))) : __builtin_strcmp (left, "'day'")))); }) == 0
   || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (left) && __builtin_constant_p ("'hour'") && (__s1_len = strlen (left), __s2_len = strlen ("'hour'"), (!((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("'hour'") + 1) - (size_t)(const void *)("'hour'") == 1) || __s2_len >= 4)) ? __builtin_strcmp (left, "'hour'") : (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) && (__s1_len = strlen (left), __s1_len < 4) ? (__builtin_constant_p ("'hour'") && ((size_t)(const void *)(("'hour'") + 1) - (size_t)(const void *)("'hour'") == 1) ? __builtin_strcmp (left, "'hour'") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("'hour'"); int __result = (((const unsigned char *) (const char *) (left))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (left))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("'hour'") && ((size_t)(const void *)(("'hour'") + 1) - (size_t)(const void *)("'hour'") == 1) && (__s2_len = strlen ("'hour'"), __s2_len < 4) ? (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) ? __builtin_strcmp (left, "'hour'") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (left); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("'hour'"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("'hour'"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("'hour'"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("'hour'"))[3]); } } __result; }))) : __builtin_strcmp (left, "'hour'")))); }) == 0
   || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (left) && __builtin_constant_p ("'minute'") && (__s1_len = strlen (left), __s2_len = strlen ("'minute'"), (!((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("'minute'") + 1) - (size_t)(const void *)("'minute'") == 1) || __s2_len >= 4)) ? __builtin_strcmp (left, "'minute'") : (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) && (__s1_len = strlen (left), __s1_len < 4) ? (__builtin_constant_p ("'minute'") && ((size_t)(const void *)(("'minute'") + 1) - (size_t)(const void *)("'minute'") == 1) ? __builtin_strcmp (left, "'minute'") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("'minute'"); int __result = (((const unsigned char *) (const char *) (left))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (left))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("'minute'") && ((size_t)(const void *)(("'minute'") + 1) - (size_t)(const void *)("'minute'") == 1) && (__s2_len = strlen ("'minute'"), __s2_len < 4) ? (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) ? __builtin_strcmp (left, "'minute'") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (left); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("'minute'"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("'minute'"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("'minute'"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("'minute'"))[3]); } } __result; }))) : __builtin_strcmp (left, "'minute'")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (left) && __builtin_constant_p ("'second'") && (__s1_len = strlen (left), __s2_len = strlen ("'second'"), (!((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("'second'") + 1) - (size_t)(const void *)("'second'") == 1) || __s2_len >= 4)) ? __builtin_strcmp (left, "'second'") : (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) && (__s1_len = strlen (left), __s1_len < 4) ? (__builtin_constant_p ("'second'") && ((size_t)(const void *)(("'second'") + 1) - (size_t)(const void *)("'second'") == 1) ? __builtin_strcmp (left, "'second'") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("'second'"); int __result = (((const unsigned char *) (const char *) (left))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (left))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("'second'") && ((size_t)(const void *)(("'second'") + 1) - (size_t)(const void *)("'second'") == 1) && (__s2_len = strlen ("'second'"), __s2_len < 4) ? (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) ? __builtin_strcmp (left, "'second'") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (left); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("'second'"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("'second'"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("'second'"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("'second'"))[3]); } } __result; }))) : __builtin_strcmp (left, "'second'")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (left) && __builtin_constant_p ("'timezone_hour'") && (__s1_len = strlen (left), __s2_len = strlen ("'timezone_hour'"), (!((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("'timezone_hour'") + 1) - (size_t)(const void *)("'timezone_hour'") == 1) || __s2_len >= 4)) ? __builtin_strcmp (left, "'timezone_hour'") : (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) && (__s1_len = strlen (left), __s1_len < 4) ? (__builtin_constant_p ("'timezone_hour'") && ((size_t)(const void *)(("'timezone_hour'") + 1) - (size_t)(const void *)("'timezone_hour'") == 1) ? __builtin_strcmp (left, "'timezone_hour'") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("'timezone_hour'"); int __result = (((const unsigned char *) (const char *) (left))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (left))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("'timezone_hour'") && ((size_t)(const void *)(("'timezone_hour'") + 1) - (size_t)(const void *)("'timezone_hour'") == 1) && (__s2_len = strlen ("'timezone_hour'"), __s2_len < 4) ? (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) ? __builtin_strcmp (left, "'timezone_hour'") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (left); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("'timezone_hour'"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("'timezone_hour'"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("'timezone_hour'"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("'timezone_hour'"))[3]); } } __result; }))) : __builtin_strcmp (left, "'timezone_hour'")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (left) && __builtin_constant_p ("'timezone_minute'") && (__s1_len = strlen (left), __s2_len = strlen ("'timezone_minute'"), (!((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("'timezone_minute'") + 1) - (size_t)(const void *)("'timezone_minute'") == 1) || __s2_len >= 4)) ? __builtin_strcmp (left, "'timezone_minute'") : (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) && (__s1_len = strlen (left), __s1_len < 4) ? (__builtin_constant_p ("'timezone_minute'") && ((size_t)(const void *)(("'timezone_minute'") + 1) - (size_t)(const void *)("'timezone_minute'") == 1) ? __builtin_strcmp (left, "'timezone_minute'") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("'timezone_minute'"); int __result = (((const unsigned char *) (const char *) (left))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (left))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (left))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("'timezone_minute'") && ((size_t)(const void *)(("'timezone_minute'") + 1) - (size_t)(const void *)("'timezone_minute'") == 1) && (__s2_len = strlen ("'timezone_minute'"), __s2_len < 4) ? (__builtin_constant_p (left) && ((size_t)(const void *)((left) + 1) - (size_t)(const void *)(left) == 1) ? __builtin_strcmp (left, "'timezone_minute'") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (left); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("'timezone_minute'"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("'timezone_minute'"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("'timezone_minute'"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("'timezone_minute'"))[3]); } } __result; }))) : __builtin_strcmp (left, "'timezone_minute'")))); }) == 0) {

 left[strlen (left) - 1] = '\0';

 right = deparseExpr (session, foreignrel, ((((list_head(func->args))->next))->data.ptr_value), db2Table, params);
 if (right == ((void *)0)) {
   pfree (opername);
   pfree (left);
   return ((void *)0);
 }

 initStringInfo (&result);
 appendStringInfo (&result, "EXTRACT(%s FROM %s)", left + 1, right);
      }
      else {
 pfree (opername);
 pfree (left);
 return ((void *)0);
      }

      pfree (left);
      pfree (right);
    }
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("now") && (__s1_len = strlen (opername), __s2_len = strlen ("now"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("now") + 1) - (size_t)(const void *)("now") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "now") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("now") && ((size_t)(const void *)(("now") + 1) - (size_t)(const void *)("now") == 1) ? __builtin_strcmp (opername, "now") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("now"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("now") && ((size_t)(const void *)(("now") + 1) - (size_t)(const void *)("now") == 1) && (__s2_len = strlen ("now"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "now") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("now"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("now"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("now"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("now"))[3]); } } __result; }))) : __builtin_strcmp (opername, "now")))); }) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (opername) && __builtin_constant_p ("transaction_timestamp") && (__s1_len = strlen (opername), __s2_len = strlen ("transaction_timestamp"), (!((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("transaction_timestamp") + 1) - (size_t)(const void *)("transaction_timestamp") == 1) || __s2_len >= 4)) ? __builtin_strcmp (opername, "transaction_timestamp") : (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) && (__s1_len = strlen (opername), __s1_len < 4) ? (__builtin_constant_p ("transaction_timestamp") && ((size_t)(const void *)(("transaction_timestamp") + 1) - (size_t)(const void *)("transaction_timestamp") == 1) ? __builtin_strcmp (opername, "transaction_timestamp") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("transaction_timestamp"); int __result = (((const unsigned char *) (const char *) (opername))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (opername))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (opername))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("transaction_timestamp") && ((size_t)(const void *)(("transaction_timestamp") + 1) - (size_t)(const void *)("transaction_timestamp") == 1) && (__s2_len = strlen ("transaction_timestamp"), __s2_len < 4) ? (__builtin_constant_p (opername) && ((size_t)(const void *)((opername) + 1) - (size_t)(const void *)(opername) == 1) ? __builtin_strcmp (opername, "transaction_timestamp") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (opername); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("transaction_timestamp"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("transaction_timestamp"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("transaction_timestamp"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("transaction_timestamp"))[3]); } } __result; }))) : __builtin_strcmp (opername, "transaction_timestamp")))); }) == 0) {

      initStringInfo (&result);
      appendStringInfo (&result, "(CAST (:now AS TIMESTAMP WITH TIME ZONE))");
    }
    else {

      pfree (opername);
      return ((void *)0);
    }

    pfree (opername);
    break;
  case T_CoerceViaIO:



    coerce = (CoerceViaIO *) expr;


    if (coerce->resulttype != 1082 && coerce->resulttype != 1114 && coerce->resulttype != 1184)
      return ((void *)0);


    if (coerce->arg->type != T_Const)
      return ((void *)0);


    constant = (Const *) coerce->arg;
    if (constant->constisnull || (constant->consttype != 2275 && constant->consttype != 25))
      return ((void *)0);


    tuple = SearchSysCache1 (TYPEOID, ((Datum) (constant->consttype)));
    if (!((const void*)(tuple) != ((void *)0))) {
      do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 3647, __func__); elog_finish(20, "cache lookup failed for type %u", constant->consttype); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    }
    typoutput = ((Form_pg_type) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->typoutput;
    ReleaseSysCache (tuple);


    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))) && __builtin_constant_p ("now") && (__s1_len = strlen (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))), __s2_len = strlen ("now"), (!((size_t)(const void *)((((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))) + 1) - (size_t)(const void *)(((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("now") + 1) - (size_t)(const void *)("now") == 1) || __s2_len >= 4)) ? __builtin_strcmp (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue)))), "now") : (__builtin_constant_p (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))) && ((size_t)(const void *)((((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))) + 1) - (size_t)(const void *)(((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))) == 1) && (__s1_len = strlen (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))), __s1_len < 4) ? (__builtin_constant_p ("now") && ((size_t)(const void *)(("now") + 1) - (size_t)(const void *)("now") == 1) ? __builtin_strcmp (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue)))), "now") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("now"); int __result = (((const unsigned char *) (const char *) (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("now") && ((size_t)(const void *)(("now") + 1) - (size_t)(const void *)("now") == 1) && (__s2_len = strlen ("now"), __s2_len < 4) ? (__builtin_constant_p (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))) && ((size_t)(const void *)((((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))) + 1) - (size_t)(const void *)(((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))) == 1) ? __builtin_strcmp (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue)))), "now") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue))))); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("now"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("now"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("now"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("now"))[3]); } } __result; }))) : __builtin_strcmp (((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), constant->constvalue)))), "now")))); }) != 0)
      return ((void *)0);

    initStringInfo (&result);
    switch (coerce->resulttype) {
    case 1082:
      appendStringInfo (&result, "TRUNC(CAST (CAST(:now AS TIMESTAMP WITH TIME ZONE) AS DATE))");
      break;
    case 1114:
      appendStringInfo (&result, "(CAST (CAST (:now AS TIMESTAMP WITH TIME ZONE) AS TIMESTAMP))");
      break;
    case 1184:
      appendStringInfo (&result, "(CAST (:now AS TIMESTAMP WITH TIME ZONE))");
      break;
    case 1083:
      appendStringInfo (&result, "(CAST (CAST (:now AS TIME WITH TIME ZONE) AS TIME))");
      break;
    case 1266:
      appendStringInfo (&result, "(CAST (:now AS TIME WITH TIME ZONE))");
      break;
    }

    break;

  case T_SQLValueFunction:
    sqlvalfunc = (SQLValueFunction *) expr;

    switch (sqlvalfunc->op) {
    case SVFOP_CURRENT_DATE:
      initStringInfo (&result);
      appendStringInfo (&result, "TRUNC(CAST (CAST(:now AS TIMESTAMP WITH TIME ZONE) AS DATE))");
      break;
    case SVFOP_CURRENT_TIMESTAMP:
      initStringInfo (&result);
      appendStringInfo (&result, "(CAST (:now AS TIMESTAMP WITH TIME ZONE))");
      break;
    case SVFOP_LOCALTIMESTAMP:
      initStringInfo (&result);
      appendStringInfo (&result, "(CAST (CAST (:now AS TIMESTAMP WITH TIME ZONE) AS TIMESTAMP))");
      break;
    case SVFOP_CURRENT_TIME:
      initStringInfo (&result);
      appendStringInfo (&result, "(CAST (:now AS TIME WITH TIME ZONE))");
      break;
    case SVFOP_LOCALTIME:
      initStringInfo (&result);
      appendStringInfo (&result, "(CAST (CAST (:now AS TIME WITH TIME ZONE) AS TIME))");
      break;
    default:
      return ((void *)0);
    }

    break;

  default:

    return ((void *)0);
  }

  return result.data;
}






static char *
datumToString (Datum datum, Oid type)
{
  StringInfoData result;
  regproc typoutput;
  HeapTuple tuple;
  char *str, *p;


  tuple = SearchSysCache1 (TYPEOID, ((Datum) (type)));
  if (!((const void*)(tuple) != ((void *)0))) {
    do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 3731, __func__); elog_finish(20, "cache lookup failed for type %u", type); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
  }
  typoutput = ((Form_pg_type) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->typoutput;
  ReleaseSysCache (tuple);


  switch (type) {
  case 25:
  case 18:
  case 1042:
  case 1043:
  case 19:
    str = ((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), datum))));





    if (str[0] == '\0')
      return ((void *)0);


    initStringInfo (&result);
    appendStringInfo (&result, "'");
    for (p = str; *p; ++p) {
      if (*p == '\'')
 appendStringInfo (&result, "'");
      appendStringInfo (&result, "%c", *p);
    }
    appendStringInfo (&result, "'");
    break;
  case 20:
  case 21:
  case 23:
  case 26:
  case 700:
  case 701:
  case 1700:
    str = ((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), datum))));
    initStringInfo (&result);
    appendStringInfo (&result, "%s", str);
    break;
  case 1082:
    str = deparseDate (datum);
    initStringInfo (&result);
    appendStringInfo (&result, "(CAST ('%s' AS DATE))", str);
    break;
  case 1114:
    str = deparseTimestamp (datum, 0);
    initStringInfo (&result);
    appendStringInfo (&result, "(CAST ('%s' AS TIMESTAMP))", str);
    break;
  case 1184:
    str = deparseTimestamp (datum, 1);
    initStringInfo (&result);
    appendStringInfo (&result, "(CAST ('%s' AS TIMESTAMP WITH TIME ZONE))", str);
    break;
  case 1083:
    str = deparseTimestamp (datum, 0);
    initStringInfo (&result);
    appendStringInfo (&result, "(CAST ('%s' AS TIME))", str);
    break;
  case 1266:
    str = deparseTimestamp (datum, 1);
    initStringInfo (&result);
    appendStringInfo (&result, "(CAST ('%s' AS TIME WITH TIME ZONE))", str);
    break;
  case 1186:
    str = deparseInterval (datum);
    if (str == ((void *)0))
      return ((void *)0);
    initStringInfo (&result);
    appendStringInfo (&result, "%s", str);
    break;
  default:
    return ((void *)0);
  }

  return result.data;
}





void
getUsedColumns (Expr * expr, struct db2Table *db2Table, int foreignrelid)
{
  ListCell *cell;
  Var *variable;
  int index;

  if (expr == ((void *)0))
    return;

  switch (expr->type) {
  case T_RestrictInfo:
    getUsedColumns (((RestrictInfo *) expr)->clause, db2Table, foreignrelid);
    break;
  case T_TargetEntry:
    getUsedColumns (((TargetEntry *) expr)->expr, db2Table, foreignrelid);
    break;
  case T_Const:
  case T_Param:
  case T_CaseTestExpr:
  case T_CoerceToDomainValue:
  case T_CurrentOfExpr:

  case T_NextValueExpr:

    break;
  case T_Var:
    variable = (Var *) expr;


    if (variable->varattno < 0)
      break;


    if (variable->varattno == 0) {
      for (index = 0; index < db2Table->ncols; ++index)
 if (db2Table->cols[index]->pgname)
   db2Table->cols[index]->used = 1;
      break;
    }


    index = db2Table->ncols - 1;
    while (index >= 0 && db2Table->cols[index]->pgattnum != variable->varattno)
      --index;

    if (index == -1) {
      do { int __errno_location __attribute__((unused)); if (errstart(19,

 "db2_fdw.c"
# 3863 "db2_fdw.c"
      ,

 3865
# 3863 "db2_fdw.c"
      , __func__, ((void *)0))) errfinish (errcode ((((('0') - '0') & 0x3F) + (((('1') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('0') - '0') & 0x3F) << 24))), errmsg ("column number %d of foreign table \"%s\" does not exist in foreign DB2 table, will be replaced by NULL", variable->varattno, db2Table->pgname)); if (__builtin_constant_p(19) && (19) >= 20) __builtin_unreachable(); } while(0)

                                                                                                                                                           ;
    }
    else {
      db2Table->cols[index]->used = 1;
    }
    break;
  case T_Aggref:
    for ((cell) = list_head(((Aggref *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    for ((cell) = list_head(((Aggref *) expr)->aggorder); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    for ((cell) = list_head(((Aggref *) expr)->aggdistinct); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_WindowFunc:
    for ((cell) = list_head(((WindowFunc *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;





  case T_SubscriptingRef:
    {
    SubscriptingRef *ref = (SubscriptingRef *)expr;

    for ((cell) = list_head(ref->refupperindexpr); (cell) != ((void *)0); (cell) = ((cell)->next))
    {
      getUsedColumns((Expr *)((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    for ((cell) = list_head(ref->reflowerindexpr); (cell) != ((void *)0); (cell) = ((cell)->next))
    {
      getUsedColumns((Expr *)((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    getUsedColumns(ref->refexpr, db2Table, foreignrelid);
    getUsedColumns(ref->refassgnexpr, db2Table, foreignrelid);
    break;
    }

  case T_FuncExpr:
    for ((cell) = list_head(((FuncExpr *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_OpExpr:
    for ((cell) = list_head(((OpExpr *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_DistinctExpr:
    for ((cell) = list_head(((DistinctExpr *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_NullIfExpr:
    for ((cell) = list_head(((NullIfExpr *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_ScalarArrayOpExpr:
    for ((cell) = list_head(((ScalarArrayOpExpr *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_BoolExpr:
    for ((cell) = list_head(((BoolExpr *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_SubPlan:
    for ((cell) = list_head(((SubPlan *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_AlternativeSubPlan:

    getUsedColumns ((Expr *) ((list_head(((AlternativeSubPlan *) expr)->subplans))->data.ptr_value), db2Table, foreignrelid);
    break;
  case T_NamedArgExpr:
    getUsedColumns (((NamedArgExpr *) expr)->arg, db2Table, foreignrelid);
    break;
  case T_FieldSelect:
    getUsedColumns (((FieldSelect *) expr)->arg, db2Table, foreignrelid);
    break;
  case T_RelabelType:
    getUsedColumns (((RelabelType *) expr)->arg, db2Table, foreignrelid);
    break;
  case T_CoerceViaIO:
    getUsedColumns (((CoerceViaIO *) expr)->arg, db2Table, foreignrelid);
    break;
  case T_ArrayCoerceExpr:
    getUsedColumns (((ArrayCoerceExpr *) expr)->arg, db2Table, foreignrelid);
    break;
  case T_ConvertRowtypeExpr:
    getUsedColumns (((ConvertRowtypeExpr *) expr)->arg, db2Table, foreignrelid);
    break;
  case T_CollateExpr:
    getUsedColumns (((CollateExpr *) expr)->arg, db2Table, foreignrelid);
    break;
  case T_CaseExpr:
    for ((cell) = list_head(((CaseExpr *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    getUsedColumns (((CaseExpr *) expr)->arg, db2Table, foreignrelid);
    getUsedColumns (((CaseExpr *) expr)->defresult, db2Table, foreignrelid);
    break;
  case T_CaseWhen:
    getUsedColumns (((CaseWhen *) expr)->expr, db2Table, foreignrelid);
    getUsedColumns (((CaseWhen *) expr)->result, db2Table, foreignrelid);
    break;
  case T_ArrayExpr:
    for ((cell) = list_head(((ArrayExpr *) expr)->elements); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_RowExpr:
    for ((cell) = list_head(((RowExpr *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_RowCompareExpr:
    for ((cell) = list_head(((RowCompareExpr *) expr)->largs); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    for ((cell) = list_head(((RowCompareExpr *) expr)->rargs); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_CoalesceExpr:
    for ((cell) = list_head(((CoalesceExpr *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_MinMaxExpr:
    for ((cell) = list_head(((MinMaxExpr *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_XmlExpr:
    for ((cell) = list_head(((XmlExpr *) expr)->named_args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    for ((cell) = list_head(((XmlExpr *) expr)->args); (cell) != ((void *)0); (cell) = ((cell)->next)) {
      getUsedColumns ((Expr *) ((cell)->data.ptr_value), db2Table, foreignrelid);
    }
    break;
  case T_NullTest:
    getUsedColumns (((NullTest *) expr)->arg, db2Table, foreignrelid);
    break;
  case T_BooleanTest:
    getUsedColumns (((BooleanTest *) expr)->arg, db2Table, foreignrelid);
    break;
  case T_CoerceToDomain:
    getUsedColumns (((CoerceToDomain *) expr)->arg, db2Table, foreignrelid);
    break;
  case T_PlaceHolderVar:
    getUsedColumns (((PlaceHolderVar *) expr)->phexpr, db2Table, foreignrelid);
    break;

  case T_SQLValueFunction:
    break;

  default:






    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 4039, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('M') - '0') & 0x3F) << 24))), errmsg ("Internal db2_fdw error: encountered unknown node type %d.", expr->type)); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
  }
}






void
checkDataType (db2Type db2type, int scale, Oid pgtype, const char *tablename, const char *colname)
{
  db2Debug2("checkDataType: db2type: %d   pgtype: %d",db2type,pgtype);

  if (db2type == SQL_TYPE_BLOB && pgtype == 17)
    return;
  if (db2type == SQL_TYPE_XML && pgtype == 17)
    return;



  if (db2type != SQL_TYPE_OTHER && db2type != SQL_TYPE_BLOB && (pgtype == 25 || pgtype == 1043 || pgtype == 1042))
    return;


  if ((db2type == SQL_TYPE_INTEGER || db2type == SQL_TYPE_SMALL || db2type == SQL_TYPE_BIG || db2type == SQL_TYPE_FLOAT || db2type == SQL_TYPE_DOUBLE || db2type == SQL_TYPE_DECIMAL)
      && (pgtype == 1700 || pgtype == 700 || pgtype == 701))
    return;





  if ((db2type == SQL_TYPE_INTEGER || db2type == SQL_TYPE_SMALL || db2type == SQL_TYPE_BIG)
      && scale <= 0 && (pgtype == 21 || pgtype == 23 || pgtype == 20 || pgtype == 16)
    )
    return;


  if ((db2type == SQL_TYPE_DATE || db2type == SQL_TYPE_STAMP)
      && (pgtype == 1082 || pgtype == 1114 || pgtype == 1184 || pgtype == 1083 || pgtype == 1266))
    return;



  if ((db2type == SQL_TYPE_VARCHAR || db2type == SQL_TYPE_CLOB)
      && pgtype == 114)
    return;


  do { int __errno_location __attribute__((unused)); if (errstart(20,

 "db2_fdw.c"
# 4089 "db2_fdw.c"
  ,

 4091
# 4089 "db2_fdw.c"
  , __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("column \"%s\" of type \"%d\" of foreign DB2 table \"%s\" cannot be converted to \"%d\" ", colname, db2type, tablename, pgtype)); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0)

                                                                                                                                              ;
}







char *
deparseWhereConditions (struct DB2FdwState *fdwState, RelOptInfo * baserel, List ** local_conds, List ** remote_conds)
{
  List *conditions = baserel->baserestrictinfo;
  ListCell *cell;
  char *where;
  char *keyword = "WHERE";
  StringInfoData where_clause;

  initStringInfo (&where_clause);
  for ((cell) = list_head(conditions); (cell) != ((void *)0); (cell) = ((cell)->next)) {

    where = deparseExpr (fdwState->session, baserel, ((RestrictInfo *) ((cell)->data.ptr_value))->clause, fdwState->db2Table, &(fdwState->params)
      );
    if (where != ((void *)0)) {
      *remote_conds = lappend (*remote_conds, ((RestrictInfo *) ((cell)->data.ptr_value))->clause);


      appendStringInfo (&where_clause, " %s %s", keyword, where);
      keyword = "AND";
      pfree (where);
    }
    else
      *local_conds = lappend (*local_conds, ((RestrictInfo *) ((cell)->data.ptr_value))->clause);
  }
  return where_clause.data;
}






char *
guessNlsLang (char *nls_lang)
{
  char *server_encoding, *lc_messages, *language = "AMERICAN_AMERICA", *charset = ((void *)0);
  StringInfoData buf;

  initStringInfo (&buf);
  if (nls_lang == ((void *)0)) {
    server_encoding = pstrdup (GetConfigOption ("server_encoding", 0, 1));


    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("UTF8") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("UTF8"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("UTF8") + 1) - (size_t)(const void *)("UTF8") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "UTF8") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("UTF8") && ((size_t)(const void *)(("UTF8") + 1) - (size_t)(const void *)("UTF8") == 1) ? __builtin_strcmp (server_encoding, "UTF8") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("UTF8"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("UTF8") && ((size_t)(const void *)(("UTF8") + 1) - (size_t)(const void *)("UTF8") == 1) && (__s2_len = strlen ("UTF8"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "UTF8") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("UTF8"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("UTF8"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("UTF8"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("UTF8"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "UTF8")))); }) == 0)
      charset = "AL32UTF8";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("EUC_JP") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("EUC_JP"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("EUC_JP") + 1) - (size_t)(const void *)("EUC_JP") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "EUC_JP") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("EUC_JP") && ((size_t)(const void *)(("EUC_JP") + 1) - (size_t)(const void *)("EUC_JP") == 1) ? __builtin_strcmp (server_encoding, "EUC_JP") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("EUC_JP"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("EUC_JP") && ((size_t)(const void *)(("EUC_JP") + 1) - (size_t)(const void *)("EUC_JP") == 1) && (__s2_len = strlen ("EUC_JP"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "EUC_JP") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("EUC_JP"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("EUC_JP"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("EUC_JP"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("EUC_JP"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "EUC_JP")))); }) == 0)
      charset = "JA16EUC";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("EUC_JIS_2004") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("EUC_JIS_2004"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("EUC_JIS_2004") + 1) - (size_t)(const void *)("EUC_JIS_2004") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "EUC_JIS_2004") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("EUC_JIS_2004") && ((size_t)(const void *)(("EUC_JIS_2004") + 1) - (size_t)(const void *)("EUC_JIS_2004") == 1) ? __builtin_strcmp (server_encoding, "EUC_JIS_2004") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("EUC_JIS_2004"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("EUC_JIS_2004") && ((size_t)(const void *)(("EUC_JIS_2004") + 1) - (size_t)(const void *)("EUC_JIS_2004") == 1) && (__s2_len = strlen ("EUC_JIS_2004"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "EUC_JIS_2004") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("EUC_JIS_2004"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("EUC_JIS_2004"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("EUC_JIS_2004"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("EUC_JIS_2004"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "EUC_JIS_2004")))); }) == 0)
      charset = "JA16SJIS";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("EUC_TW") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("EUC_TW"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("EUC_TW") + 1) - (size_t)(const void *)("EUC_TW") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "EUC_TW") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("EUC_TW") && ((size_t)(const void *)(("EUC_TW") + 1) - (size_t)(const void *)("EUC_TW") == 1) ? __builtin_strcmp (server_encoding, "EUC_TW") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("EUC_TW"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("EUC_TW") && ((size_t)(const void *)(("EUC_TW") + 1) - (size_t)(const void *)("EUC_TW") == 1) && (__s2_len = strlen ("EUC_TW"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "EUC_TW") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("EUC_TW"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("EUC_TW"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("EUC_TW"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("EUC_TW"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "EUC_TW")))); }) == 0)
      charset = "ZHT32EUC";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("ISO_8859_5") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("ISO_8859_5"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("ISO_8859_5") + 1) - (size_t)(const void *)("ISO_8859_5") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "ISO_8859_5") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("ISO_8859_5") && ((size_t)(const void *)(("ISO_8859_5") + 1) - (size_t)(const void *)("ISO_8859_5") == 1) ? __builtin_strcmp (server_encoding, "ISO_8859_5") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("ISO_8859_5"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("ISO_8859_5") && ((size_t)(const void *)(("ISO_8859_5") + 1) - (size_t)(const void *)("ISO_8859_5") == 1) && (__s2_len = strlen ("ISO_8859_5"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "ISO_8859_5") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("ISO_8859_5"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("ISO_8859_5"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("ISO_8859_5"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("ISO_8859_5"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "ISO_8859_5")))); }) == 0)
      charset = "CL8ISO8859P5";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("ISO_8859_6") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("ISO_8859_6"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("ISO_8859_6") + 1) - (size_t)(const void *)("ISO_8859_6") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "ISO_8859_6") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("ISO_8859_6") && ((size_t)(const void *)(("ISO_8859_6") + 1) - (size_t)(const void *)("ISO_8859_6") == 1) ? __builtin_strcmp (server_encoding, "ISO_8859_6") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("ISO_8859_6"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("ISO_8859_6") && ((size_t)(const void *)(("ISO_8859_6") + 1) - (size_t)(const void *)("ISO_8859_6") == 1) && (__s2_len = strlen ("ISO_8859_6"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "ISO_8859_6") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("ISO_8859_6"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("ISO_8859_6"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("ISO_8859_6"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("ISO_8859_6"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "ISO_8859_6")))); }) == 0)
      charset = "AR8ISO8859P6";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("ISO_8859_7") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("ISO_8859_7"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("ISO_8859_7") + 1) - (size_t)(const void *)("ISO_8859_7") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "ISO_8859_7") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("ISO_8859_7") && ((size_t)(const void *)(("ISO_8859_7") + 1) - (size_t)(const void *)("ISO_8859_7") == 1) ? __builtin_strcmp (server_encoding, "ISO_8859_7") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("ISO_8859_7"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("ISO_8859_7") && ((size_t)(const void *)(("ISO_8859_7") + 1) - (size_t)(const void *)("ISO_8859_7") == 1) && (__s2_len = strlen ("ISO_8859_7"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "ISO_8859_7") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("ISO_8859_7"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("ISO_8859_7"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("ISO_8859_7"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("ISO_8859_7"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "ISO_8859_7")))); }) == 0)
      charset = "EL8ISO8859P7";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("ISO_8859_8") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("ISO_8859_8"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("ISO_8859_8") + 1) - (size_t)(const void *)("ISO_8859_8") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "ISO_8859_8") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("ISO_8859_8") && ((size_t)(const void *)(("ISO_8859_8") + 1) - (size_t)(const void *)("ISO_8859_8") == 1) ? __builtin_strcmp (server_encoding, "ISO_8859_8") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("ISO_8859_8"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("ISO_8859_8") && ((size_t)(const void *)(("ISO_8859_8") + 1) - (size_t)(const void *)("ISO_8859_8") == 1) && (__s2_len = strlen ("ISO_8859_8"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "ISO_8859_8") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("ISO_8859_8"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("ISO_8859_8"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("ISO_8859_8"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("ISO_8859_8"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "ISO_8859_8")))); }) == 0)
      charset = "IW8ISO8859P8";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("KOI8R") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("KOI8R"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("KOI8R") + 1) - (size_t)(const void *)("KOI8R") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "KOI8R") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("KOI8R") && ((size_t)(const void *)(("KOI8R") + 1) - (size_t)(const void *)("KOI8R") == 1) ? __builtin_strcmp (server_encoding, "KOI8R") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("KOI8R"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("KOI8R") && ((size_t)(const void *)(("KOI8R") + 1) - (size_t)(const void *)("KOI8R") == 1) && (__s2_len = strlen ("KOI8R"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "KOI8R") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("KOI8R"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("KOI8R"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("KOI8R"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("KOI8R"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "KOI8R")))); }) == 0)
      charset = "CL8KOI8R";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("KOI8U") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("KOI8U"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("KOI8U") + 1) - (size_t)(const void *)("KOI8U") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "KOI8U") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("KOI8U") && ((size_t)(const void *)(("KOI8U") + 1) - (size_t)(const void *)("KOI8U") == 1) ? __builtin_strcmp (server_encoding, "KOI8U") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("KOI8U"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("KOI8U") && ((size_t)(const void *)(("KOI8U") + 1) - (size_t)(const void *)("KOI8U") == 1) && (__s2_len = strlen ("KOI8U"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "KOI8U") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("KOI8U"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("KOI8U"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("KOI8U"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("KOI8U"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "KOI8U")))); }) == 0)
      charset = "CL8KOI8U";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("LATIN1") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("LATIN1"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("LATIN1") + 1) - (size_t)(const void *)("LATIN1") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "LATIN1") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("LATIN1") && ((size_t)(const void *)(("LATIN1") + 1) - (size_t)(const void *)("LATIN1") == 1) ? __builtin_strcmp (server_encoding, "LATIN1") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("LATIN1"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("LATIN1") && ((size_t)(const void *)(("LATIN1") + 1) - (size_t)(const void *)("LATIN1") == 1) && (__s2_len = strlen ("LATIN1"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "LATIN1") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("LATIN1"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("LATIN1"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("LATIN1"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("LATIN1"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "LATIN1")))); }) == 0)
      charset = "WE8ISO8859P1";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("LATIN2") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("LATIN2"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("LATIN2") + 1) - (size_t)(const void *)("LATIN2") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "LATIN2") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("LATIN2") && ((size_t)(const void *)(("LATIN2") + 1) - (size_t)(const void *)("LATIN2") == 1) ? __builtin_strcmp (server_encoding, "LATIN2") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("LATIN2"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("LATIN2") && ((size_t)(const void *)(("LATIN2") + 1) - (size_t)(const void *)("LATIN2") == 1) && (__s2_len = strlen ("LATIN2"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "LATIN2") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("LATIN2"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("LATIN2"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("LATIN2"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("LATIN2"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "LATIN2")))); }) == 0)
      charset = "EE8ISO8859P2";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("LATIN3") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("LATIN3"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("LATIN3") + 1) - (size_t)(const void *)("LATIN3") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "LATIN3") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("LATIN3") && ((size_t)(const void *)(("LATIN3") + 1) - (size_t)(const void *)("LATIN3") == 1) ? __builtin_strcmp (server_encoding, "LATIN3") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("LATIN3"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("LATIN3") && ((size_t)(const void *)(("LATIN3") + 1) - (size_t)(const void *)("LATIN3") == 1) && (__s2_len = strlen ("LATIN3"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "LATIN3") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("LATIN3"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("LATIN3"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("LATIN3"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("LATIN3"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "LATIN3")))); }) == 0)
      charset = "SE8ISO8859P3";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("LATIN4") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("LATIN4"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("LATIN4") + 1) - (size_t)(const void *)("LATIN4") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "LATIN4") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("LATIN4") && ((size_t)(const void *)(("LATIN4") + 1) - (size_t)(const void *)("LATIN4") == 1) ? __builtin_strcmp (server_encoding, "LATIN4") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("LATIN4"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("LATIN4") && ((size_t)(const void *)(("LATIN4") + 1) - (size_t)(const void *)("LATIN4") == 1) && (__s2_len = strlen ("LATIN4"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "LATIN4") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("LATIN4"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("LATIN4"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("LATIN4"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("LATIN4"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "LATIN4")))); }) == 0)
      charset = "NEE8ISO8859P4";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("LATIN5") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("LATIN5"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("LATIN5") + 1) - (size_t)(const void *)("LATIN5") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "LATIN5") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("LATIN5") && ((size_t)(const void *)(("LATIN5") + 1) - (size_t)(const void *)("LATIN5") == 1) ? __builtin_strcmp (server_encoding, "LATIN5") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("LATIN5"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("LATIN5") && ((size_t)(const void *)(("LATIN5") + 1) - (size_t)(const void *)("LATIN5") == 1) && (__s2_len = strlen ("LATIN5"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "LATIN5") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("LATIN5"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("LATIN5"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("LATIN5"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("LATIN5"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "LATIN5")))); }) == 0)
      charset = "WE8ISO8859P9";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("LATIN6") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("LATIN6"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("LATIN6") + 1) - (size_t)(const void *)("LATIN6") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "LATIN6") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("LATIN6") && ((size_t)(const void *)(("LATIN6") + 1) - (size_t)(const void *)("LATIN6") == 1) ? __builtin_strcmp (server_encoding, "LATIN6") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("LATIN6"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("LATIN6") && ((size_t)(const void *)(("LATIN6") + 1) - (size_t)(const void *)("LATIN6") == 1) && (__s2_len = strlen ("LATIN6"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "LATIN6") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("LATIN6"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("LATIN6"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("LATIN6"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("LATIN6"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "LATIN6")))); }) == 0)
      charset = "NE8ISO8859P10";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("LATIN7") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("LATIN7"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("LATIN7") + 1) - (size_t)(const void *)("LATIN7") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "LATIN7") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("LATIN7") && ((size_t)(const void *)(("LATIN7") + 1) - (size_t)(const void *)("LATIN7") == 1) ? __builtin_strcmp (server_encoding, "LATIN7") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("LATIN7"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("LATIN7") && ((size_t)(const void *)(("LATIN7") + 1) - (size_t)(const void *)("LATIN7") == 1) && (__s2_len = strlen ("LATIN7"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "LATIN7") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("LATIN7"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("LATIN7"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("LATIN7"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("LATIN7"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "LATIN7")))); }) == 0)
      charset = "BLT8ISO8859P13";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("LATIN8") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("LATIN8"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("LATIN8") + 1) - (size_t)(const void *)("LATIN8") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "LATIN8") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("LATIN8") && ((size_t)(const void *)(("LATIN8") + 1) - (size_t)(const void *)("LATIN8") == 1) ? __builtin_strcmp (server_encoding, "LATIN8") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("LATIN8"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("LATIN8") && ((size_t)(const void *)(("LATIN8") + 1) - (size_t)(const void *)("LATIN8") == 1) && (__s2_len = strlen ("LATIN8"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "LATIN8") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("LATIN8"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("LATIN8"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("LATIN8"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("LATIN8"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "LATIN8")))); }) == 0)
      charset = "CEL8ISO8859P14";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("LATIN9") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("LATIN9"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("LATIN9") + 1) - (size_t)(const void *)("LATIN9") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "LATIN9") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("LATIN9") && ((size_t)(const void *)(("LATIN9") + 1) - (size_t)(const void *)("LATIN9") == 1) ? __builtin_strcmp (server_encoding, "LATIN9") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("LATIN9"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("LATIN9") && ((size_t)(const void *)(("LATIN9") + 1) - (size_t)(const void *)("LATIN9") == 1) && (__s2_len = strlen ("LATIN9"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "LATIN9") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("LATIN9"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("LATIN9"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("LATIN9"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("LATIN9"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "LATIN9")))); }) == 0)
      charset = "WE8ISO8859P15";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("WIN866") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("WIN866"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("WIN866") + 1) - (size_t)(const void *)("WIN866") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "WIN866") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("WIN866") && ((size_t)(const void *)(("WIN866") + 1) - (size_t)(const void *)("WIN866") == 1) ? __builtin_strcmp (server_encoding, "WIN866") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("WIN866"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("WIN866") && ((size_t)(const void *)(("WIN866") + 1) - (size_t)(const void *)("WIN866") == 1) && (__s2_len = strlen ("WIN866"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "WIN866") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("WIN866"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("WIN866"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("WIN866"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("WIN866"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "WIN866")))); }) == 0)
      charset = "RU8PC866";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("WIN1250") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("WIN1250"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("WIN1250") + 1) - (size_t)(const void *)("WIN1250") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "WIN1250") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("WIN1250") && ((size_t)(const void *)(("WIN1250") + 1) - (size_t)(const void *)("WIN1250") == 1) ? __builtin_strcmp (server_encoding, "WIN1250") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("WIN1250"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("WIN1250") && ((size_t)(const void *)(("WIN1250") + 1) - (size_t)(const void *)("WIN1250") == 1) && (__s2_len = strlen ("WIN1250"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "WIN1250") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("WIN1250"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("WIN1250"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("WIN1250"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("WIN1250"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "WIN1250")))); }) == 0)
      charset = "EE8MSWIN1250";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("WIN1251") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("WIN1251"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("WIN1251") + 1) - (size_t)(const void *)("WIN1251") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "WIN1251") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("WIN1251") && ((size_t)(const void *)(("WIN1251") + 1) - (size_t)(const void *)("WIN1251") == 1) ? __builtin_strcmp (server_encoding, "WIN1251") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("WIN1251"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("WIN1251") && ((size_t)(const void *)(("WIN1251") + 1) - (size_t)(const void *)("WIN1251") == 1) && (__s2_len = strlen ("WIN1251"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "WIN1251") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("WIN1251"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("WIN1251"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("WIN1251"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("WIN1251"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "WIN1251")))); }) == 0)
      charset = "CL8MSWIN1251";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("WIN1252") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("WIN1252"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("WIN1252") + 1) - (size_t)(const void *)("WIN1252") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "WIN1252") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("WIN1252") && ((size_t)(const void *)(("WIN1252") + 1) - (size_t)(const void *)("WIN1252") == 1) ? __builtin_strcmp (server_encoding, "WIN1252") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("WIN1252"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("WIN1252") && ((size_t)(const void *)(("WIN1252") + 1) - (size_t)(const void *)("WIN1252") == 1) && (__s2_len = strlen ("WIN1252"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "WIN1252") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("WIN1252"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("WIN1252"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("WIN1252"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("WIN1252"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "WIN1252")))); }) == 0)
      charset = "WE8MSWIN1252";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("WIN1253") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("WIN1253"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("WIN1253") + 1) - (size_t)(const void *)("WIN1253") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "WIN1253") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("WIN1253") && ((size_t)(const void *)(("WIN1253") + 1) - (size_t)(const void *)("WIN1253") == 1) ? __builtin_strcmp (server_encoding, "WIN1253") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("WIN1253"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("WIN1253") && ((size_t)(const void *)(("WIN1253") + 1) - (size_t)(const void *)("WIN1253") == 1) && (__s2_len = strlen ("WIN1253"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "WIN1253") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("WIN1253"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("WIN1253"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("WIN1253"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("WIN1253"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "WIN1253")))); }) == 0)
      charset = "EL8MSWIN1253";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("WIN1254") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("WIN1254"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("WIN1254") + 1) - (size_t)(const void *)("WIN1254") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "WIN1254") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("WIN1254") && ((size_t)(const void *)(("WIN1254") + 1) - (size_t)(const void *)("WIN1254") == 1) ? __builtin_strcmp (server_encoding, "WIN1254") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("WIN1254"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("WIN1254") && ((size_t)(const void *)(("WIN1254") + 1) - (size_t)(const void *)("WIN1254") == 1) && (__s2_len = strlen ("WIN1254"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "WIN1254") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("WIN1254"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("WIN1254"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("WIN1254"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("WIN1254"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "WIN1254")))); }) == 0)
      charset = "TR8MSWIN1254";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("WIN1255") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("WIN1255"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("WIN1255") + 1) - (size_t)(const void *)("WIN1255") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "WIN1255") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("WIN1255") && ((size_t)(const void *)(("WIN1255") + 1) - (size_t)(const void *)("WIN1255") == 1) ? __builtin_strcmp (server_encoding, "WIN1255") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("WIN1255"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("WIN1255") && ((size_t)(const void *)(("WIN1255") + 1) - (size_t)(const void *)("WIN1255") == 1) && (__s2_len = strlen ("WIN1255"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "WIN1255") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("WIN1255"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("WIN1255"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("WIN1255"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("WIN1255"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "WIN1255")))); }) == 0)
      charset = "IW8MSWIN1255";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("WIN1256") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("WIN1256"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("WIN1256") + 1) - (size_t)(const void *)("WIN1256") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "WIN1256") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("WIN1256") && ((size_t)(const void *)(("WIN1256") + 1) - (size_t)(const void *)("WIN1256") == 1) ? __builtin_strcmp (server_encoding, "WIN1256") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("WIN1256"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("WIN1256") && ((size_t)(const void *)(("WIN1256") + 1) - (size_t)(const void *)("WIN1256") == 1) && (__s2_len = strlen ("WIN1256"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "WIN1256") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("WIN1256"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("WIN1256"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("WIN1256"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("WIN1256"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "WIN1256")))); }) == 0)
      charset = "AR8MSWIN1256";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("WIN1257") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("WIN1257"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("WIN1257") + 1) - (size_t)(const void *)("WIN1257") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "WIN1257") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("WIN1257") && ((size_t)(const void *)(("WIN1257") + 1) - (size_t)(const void *)("WIN1257") == 1) ? __builtin_strcmp (server_encoding, "WIN1257") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("WIN1257"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("WIN1257") && ((size_t)(const void *)(("WIN1257") + 1) - (size_t)(const void *)("WIN1257") == 1) && (__s2_len = strlen ("WIN1257"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "WIN1257") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("WIN1257"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("WIN1257"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("WIN1257"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("WIN1257"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "WIN1257")))); }) == 0)
      charset = "BLT8MSWIN1257";
    else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (server_encoding) && __builtin_constant_p ("WIN1258") && (__s1_len = strlen (server_encoding), __s2_len = strlen ("WIN1258"), (!((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("WIN1258") + 1) - (size_t)(const void *)("WIN1258") == 1) || __s2_len >= 4)) ? __builtin_strcmp (server_encoding, "WIN1258") : (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) && (__s1_len = strlen (server_encoding), __s1_len < 4) ? (__builtin_constant_p ("WIN1258") && ((size_t)(const void *)(("WIN1258") + 1) - (size_t)(const void *)("WIN1258") == 1) ? __builtin_strcmp (server_encoding, "WIN1258") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("WIN1258"); int __result = (((const unsigned char *) (const char *) (server_encoding))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (server_encoding))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (server_encoding))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("WIN1258") && ((size_t)(const void *)(("WIN1258") + 1) - (size_t)(const void *)("WIN1258") == 1) && (__s2_len = strlen ("WIN1258"), __s2_len < 4) ? (__builtin_constant_p (server_encoding) && ((size_t)(const void *)((server_encoding) + 1) - (size_t)(const void *)(server_encoding) == 1) ? __builtin_strcmp (server_encoding, "WIN1258") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (server_encoding); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("WIN1258"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("WIN1258"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("WIN1258"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("WIN1258"))[3]); } } __result; }))) : __builtin_strcmp (server_encoding, "WIN1258")))); }) == 0)
      charset = "VN8MSWIN1258";
    else {

      charset = "US7ASCII";

      do { int __errno_location __attribute__((unused)); if (errstart(19,



 "db2_fdw.c"
# 4206 "db2_fdw.c"
      ,



 4210
# 4206 "db2_fdw.c"
      , __func__, ((void *)0))) errfinish (errcode ((((('0') - '0') & 0x3F) + (((('1') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('0') - '0') & 0x3F) << 24))), errmsg ("no DB2 character set for database encoding \"%s\"", server_encoding), errdetail ("All but ASCII characters will be lost."), errhint ("You can set the option \"%s\" on the foreign data wrapper to force an DB2 character set.", "nls_lang")); if (__builtin_constant_p(19) && (19) >= 20) __builtin_unreachable(); } while(0)



                                                                                                                      ;
    }

    lc_messages = pstrdup (GetConfigOption ("lc_messages", 0, 1));

    if ((__extension__ (__builtin_constant_p (3) && ((__builtin_constant_p (lc_messages) && strlen (lc_messages) < ((size_t) (3))) || (__builtin_constant_p ("de_") && strlen ("de_") < ((size_t) (3)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lc_messages) && __builtin_constant_p ("de_") && (__s1_len = strlen (lc_messages), __s2_len = strlen ("de_"), (!((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("de_") + 1) - (size_t)(const void *)("de_") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lc_messages, "de_") : (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) && (__s1_len = strlen (lc_messages), __s1_len < 4) ? (__builtin_constant_p ("de_") && ((size_t)(const void *)(("de_") + 1) - (size_t)(const void *)("de_") == 1) ? __builtin_strcmp (lc_messages, "de_") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("de_"); int __result = (((const unsigned char *) (const char *) (lc_messages))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lc_messages))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("de_") && ((size_t)(const void *)(("de_") + 1) - (size_t)(const void *)("de_") == 1) && (__s2_len = strlen ("de_"), __s2_len < 4) ? (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) ? __builtin_strcmp (lc_messages, "de_") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lc_messages); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("de_"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("de_"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("de_"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("de_"))[3]); } } __result; }))) : __builtin_strcmp (lc_messages, "de_")))); }) : strncmp (lc_messages, "de_", 3))) == 0 || pg_strncasecmp (lc_messages, "german", 6) == 0)
      language = "GERMAN_GERMANY";
    if ((__extension__ (__builtin_constant_p (3) && ((__builtin_constant_p (lc_messages) && strlen (lc_messages) < ((size_t) (3))) || (__builtin_constant_p ("es_") && strlen ("es_") < ((size_t) (3)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lc_messages) && __builtin_constant_p ("es_") && (__s1_len = strlen (lc_messages), __s2_len = strlen ("es_"), (!((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("es_") + 1) - (size_t)(const void *)("es_") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lc_messages, "es_") : (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) && (__s1_len = strlen (lc_messages), __s1_len < 4) ? (__builtin_constant_p ("es_") && ((size_t)(const void *)(("es_") + 1) - (size_t)(const void *)("es_") == 1) ? __builtin_strcmp (lc_messages, "es_") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("es_"); int __result = (((const unsigned char *) (const char *) (lc_messages))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lc_messages))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("es_") && ((size_t)(const void *)(("es_") + 1) - (size_t)(const void *)("es_") == 1) && (__s2_len = strlen ("es_"), __s2_len < 4) ? (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) ? __builtin_strcmp (lc_messages, "es_") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lc_messages); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("es_"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("es_"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("es_"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("es_"))[3]); } } __result; }))) : __builtin_strcmp (lc_messages, "es_")))); }) : strncmp (lc_messages, "es_", 3))) == 0 || pg_strncasecmp (lc_messages, "spanish", 7) == 0)
      language = "SPANISH_SPAIN";
    if ((__extension__ (__builtin_constant_p (3) && ((__builtin_constant_p (lc_messages) && strlen (lc_messages) < ((size_t) (3))) || (__builtin_constant_p ("fr_") && strlen ("fr_") < ((size_t) (3)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lc_messages) && __builtin_constant_p ("fr_") && (__s1_len = strlen (lc_messages), __s2_len = strlen ("fr_"), (!((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("fr_") + 1) - (size_t)(const void *)("fr_") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lc_messages, "fr_") : (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) && (__s1_len = strlen (lc_messages), __s1_len < 4) ? (__builtin_constant_p ("fr_") && ((size_t)(const void *)(("fr_") + 1) - (size_t)(const void *)("fr_") == 1) ? __builtin_strcmp (lc_messages, "fr_") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("fr_"); int __result = (((const unsigned char *) (const char *) (lc_messages))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lc_messages))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("fr_") && ((size_t)(const void *)(("fr_") + 1) - (size_t)(const void *)("fr_") == 1) && (__s2_len = strlen ("fr_"), __s2_len < 4) ? (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) ? __builtin_strcmp (lc_messages, "fr_") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lc_messages); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("fr_"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("fr_"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("fr_"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("fr_"))[3]); } } __result; }))) : __builtin_strcmp (lc_messages, "fr_")))); }) : strncmp (lc_messages, "fr_", 3))) == 0 || pg_strncasecmp (lc_messages, "french", 6) == 0)
      language = "FRENCH_FRANCE";
    if ((__extension__ (__builtin_constant_p (3) && ((__builtin_constant_p (lc_messages) && strlen (lc_messages) < ((size_t) (3))) || (__builtin_constant_p ("in_") && strlen ("in_") < ((size_t) (3)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lc_messages) && __builtin_constant_p ("in_") && (__s1_len = strlen (lc_messages), __s2_len = strlen ("in_"), (!((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("in_") + 1) - (size_t)(const void *)("in_") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lc_messages, "in_") : (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) && (__s1_len = strlen (lc_messages), __s1_len < 4) ? (__builtin_constant_p ("in_") && ((size_t)(const void *)(("in_") + 1) - (size_t)(const void *)("in_") == 1) ? __builtin_strcmp (lc_messages, "in_") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("in_"); int __result = (((const unsigned char *) (const char *) (lc_messages))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lc_messages))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("in_") && ((size_t)(const void *)(("in_") + 1) - (size_t)(const void *)("in_") == 1) && (__s2_len = strlen ("in_"), __s2_len < 4) ? (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) ? __builtin_strcmp (lc_messages, "in_") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lc_messages); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("in_"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("in_"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("in_"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("in_"))[3]); } } __result; }))) : __builtin_strcmp (lc_messages, "in_")))); }) : strncmp (lc_messages, "in_", 3))) == 0 || pg_strncasecmp (lc_messages, "indonesian", 10) == 0)
      language = "INDONESIAN_INDONESIA";
    if ((__extension__ (__builtin_constant_p (3) && ((__builtin_constant_p (lc_messages) && strlen (lc_messages) < ((size_t) (3))) || (__builtin_constant_p ("it_") && strlen ("it_") < ((size_t) (3)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lc_messages) && __builtin_constant_p ("it_") && (__s1_len = strlen (lc_messages), __s2_len = strlen ("it_"), (!((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("it_") + 1) - (size_t)(const void *)("it_") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lc_messages, "it_") : (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) && (__s1_len = strlen (lc_messages), __s1_len < 4) ? (__builtin_constant_p ("it_") && ((size_t)(const void *)(("it_") + 1) - (size_t)(const void *)("it_") == 1) ? __builtin_strcmp (lc_messages, "it_") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("it_"); int __result = (((const unsigned char *) (const char *) (lc_messages))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lc_messages))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("it_") && ((size_t)(const void *)(("it_") + 1) - (size_t)(const void *)("it_") == 1) && (__s2_len = strlen ("it_"), __s2_len < 4) ? (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) ? __builtin_strcmp (lc_messages, "it_") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lc_messages); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("it_"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("it_"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("it_"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("it_"))[3]); } } __result; }))) : __builtin_strcmp (lc_messages, "it_")))); }) : strncmp (lc_messages, "it_", 3))) == 0 || pg_strncasecmp (lc_messages, "italian", 7) == 0)
      language = "ITALIAN_ITALY";
    if ((__extension__ (__builtin_constant_p (3) && ((__builtin_constant_p (lc_messages) && strlen (lc_messages) < ((size_t) (3))) || (__builtin_constant_p ("ja_") && strlen ("ja_") < ((size_t) (3)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lc_messages) && __builtin_constant_p ("ja_") && (__s1_len = strlen (lc_messages), __s2_len = strlen ("ja_"), (!((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("ja_") + 1) - (size_t)(const void *)("ja_") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lc_messages, "ja_") : (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) && (__s1_len = strlen (lc_messages), __s1_len < 4) ? (__builtin_constant_p ("ja_") && ((size_t)(const void *)(("ja_") + 1) - (size_t)(const void *)("ja_") == 1) ? __builtin_strcmp (lc_messages, "ja_") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("ja_"); int __result = (((const unsigned char *) (const char *) (lc_messages))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lc_messages))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("ja_") && ((size_t)(const void *)(("ja_") + 1) - (size_t)(const void *)("ja_") == 1) && (__s2_len = strlen ("ja_"), __s2_len < 4) ? (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) ? __builtin_strcmp (lc_messages, "ja_") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lc_messages); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("ja_"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("ja_"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("ja_"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("ja_"))[3]); } } __result; }))) : __builtin_strcmp (lc_messages, "ja_")))); }) : strncmp (lc_messages, "ja_", 3))) == 0 || pg_strncasecmp (lc_messages, "japanese", 8) == 0)
      language = "JAPANESE_JAPAN";
    if ((__extension__ (__builtin_constant_p (3) && ((__builtin_constant_p (lc_messages) && strlen (lc_messages) < ((size_t) (3))) || (__builtin_constant_p ("pt_") && strlen ("pt_") < ((size_t) (3)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lc_messages) && __builtin_constant_p ("pt_") && (__s1_len = strlen (lc_messages), __s2_len = strlen ("pt_"), (!((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("pt_") + 1) - (size_t)(const void *)("pt_") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lc_messages, "pt_") : (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) && (__s1_len = strlen (lc_messages), __s1_len < 4) ? (__builtin_constant_p ("pt_") && ((size_t)(const void *)(("pt_") + 1) - (size_t)(const void *)("pt_") == 1) ? __builtin_strcmp (lc_messages, "pt_") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("pt_"); int __result = (((const unsigned char *) (const char *) (lc_messages))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lc_messages))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("pt_") && ((size_t)(const void *)(("pt_") + 1) - (size_t)(const void *)("pt_") == 1) && (__s2_len = strlen ("pt_"), __s2_len < 4) ? (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) ? __builtin_strcmp (lc_messages, "pt_") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lc_messages); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("pt_"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("pt_"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("pt_"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("pt_"))[3]); } } __result; }))) : __builtin_strcmp (lc_messages, "pt_")))); }) : strncmp (lc_messages, "pt_", 3))) == 0 || pg_strncasecmp (lc_messages, "portuguese", 10) == 0)
      language = "BRAZILIAN PORTUGUESE_BRAZIL";
    if ((__extension__ (__builtin_constant_p (3) && ((__builtin_constant_p (lc_messages) && strlen (lc_messages) < ((size_t) (3))) || (__builtin_constant_p ("ru_") && strlen ("ru_") < ((size_t) (3)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lc_messages) && __builtin_constant_p ("ru_") && (__s1_len = strlen (lc_messages), __s2_len = strlen ("ru_"), (!((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("ru_") + 1) - (size_t)(const void *)("ru_") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lc_messages, "ru_") : (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) && (__s1_len = strlen (lc_messages), __s1_len < 4) ? (__builtin_constant_p ("ru_") && ((size_t)(const void *)(("ru_") + 1) - (size_t)(const void *)("ru_") == 1) ? __builtin_strcmp (lc_messages, "ru_") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("ru_"); int __result = (((const unsigned char *) (const char *) (lc_messages))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lc_messages))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("ru_") && ((size_t)(const void *)(("ru_") + 1) - (size_t)(const void *)("ru_") == 1) && (__s2_len = strlen ("ru_"), __s2_len < 4) ? (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) ? __builtin_strcmp (lc_messages, "ru_") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lc_messages); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("ru_"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("ru_"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("ru_"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("ru_"))[3]); } } __result; }))) : __builtin_strcmp (lc_messages, "ru_")))); }) : strncmp (lc_messages, "ru_", 3))) == 0 || pg_strncasecmp (lc_messages, "russian", 7) == 0)
      language = "RUSSIAN_RUSSIA";
    if ((__extension__ (__builtin_constant_p (3) && ((__builtin_constant_p (lc_messages) && strlen (lc_messages) < ((size_t) (3))) || (__builtin_constant_p ("tr_") && strlen ("tr_") < ((size_t) (3)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lc_messages) && __builtin_constant_p ("tr_") && (__s1_len = strlen (lc_messages), __s2_len = strlen ("tr_"), (!((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("tr_") + 1) - (size_t)(const void *)("tr_") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lc_messages, "tr_") : (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) && (__s1_len = strlen (lc_messages), __s1_len < 4) ? (__builtin_constant_p ("tr_") && ((size_t)(const void *)(("tr_") + 1) - (size_t)(const void *)("tr_") == 1) ? __builtin_strcmp (lc_messages, "tr_") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("tr_"); int __result = (((const unsigned char *) (const char *) (lc_messages))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lc_messages))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("tr_") && ((size_t)(const void *)(("tr_") + 1) - (size_t)(const void *)("tr_") == 1) && (__s2_len = strlen ("tr_"), __s2_len < 4) ? (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) ? __builtin_strcmp (lc_messages, "tr_") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lc_messages); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("tr_"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("tr_"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("tr_"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("tr_"))[3]); } } __result; }))) : __builtin_strcmp (lc_messages, "tr_")))); }) : strncmp (lc_messages, "tr_", 3))) == 0 || pg_strncasecmp (lc_messages, "turkish", 7) == 0)
      language = "TURKISH_TURKEY";
    if ((__extension__ (__builtin_constant_p (5) && ((__builtin_constant_p (lc_messages) && strlen (lc_messages) < ((size_t) (5))) || (__builtin_constant_p ("zh_CN") && strlen ("zh_CN") < ((size_t) (5)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lc_messages) && __builtin_constant_p ("zh_CN") && (__s1_len = strlen (lc_messages), __s2_len = strlen ("zh_CN"), (!((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("zh_CN") + 1) - (size_t)(const void *)("zh_CN") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lc_messages, "zh_CN") : (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) && (__s1_len = strlen (lc_messages), __s1_len < 4) ? (__builtin_constant_p ("zh_CN") && ((size_t)(const void *)(("zh_CN") + 1) - (size_t)(const void *)("zh_CN") == 1) ? __builtin_strcmp (lc_messages, "zh_CN") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("zh_CN"); int __result = (((const unsigned char *) (const char *) (lc_messages))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lc_messages))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("zh_CN") && ((size_t)(const void *)(("zh_CN") + 1) - (size_t)(const void *)("zh_CN") == 1) && (__s2_len = strlen ("zh_CN"), __s2_len < 4) ? (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) ? __builtin_strcmp (lc_messages, "zh_CN") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lc_messages); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("zh_CN"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("zh_CN"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("zh_CN"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("zh_CN"))[3]); } } __result; }))) : __builtin_strcmp (lc_messages, "zh_CN")))); }) : strncmp (lc_messages, "zh_CN", 5))) == 0 || pg_strncasecmp (lc_messages, "chinese-simplified", 18) == 0)
      language = "SIMPLIFIED CHINESE_CHINA";
    if ((__extension__ (__builtin_constant_p (5) && ((__builtin_constant_p (lc_messages) && strlen (lc_messages) < ((size_t) (5))) || (__builtin_constant_p ("zh_TW") && strlen ("zh_TW") < ((size_t) (5)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lc_messages) && __builtin_constant_p ("zh_TW") && (__s1_len = strlen (lc_messages), __s2_len = strlen ("zh_TW"), (!((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("zh_TW") + 1) - (size_t)(const void *)("zh_TW") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lc_messages, "zh_TW") : (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) && (__s1_len = strlen (lc_messages), __s1_len < 4) ? (__builtin_constant_p ("zh_TW") && ((size_t)(const void *)(("zh_TW") + 1) - (size_t)(const void *)("zh_TW") == 1) ? __builtin_strcmp (lc_messages, "zh_TW") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("zh_TW"); int __result = (((const unsigned char *) (const char *) (lc_messages))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lc_messages))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lc_messages))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("zh_TW") && ((size_t)(const void *)(("zh_TW") + 1) - (size_t)(const void *)("zh_TW") == 1) && (__s2_len = strlen ("zh_TW"), __s2_len < 4) ? (__builtin_constant_p (lc_messages) && ((size_t)(const void *)((lc_messages) + 1) - (size_t)(const void *)(lc_messages) == 1) ? __builtin_strcmp (lc_messages, "zh_TW") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lc_messages); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("zh_TW"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("zh_TW"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("zh_TW"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("zh_TW"))[3]); } } __result; }))) : __builtin_strcmp (lc_messages, "zh_TW")))); }) : strncmp (lc_messages, "zh_TW", 5))) == 0 || pg_strncasecmp (lc_messages, "chinese-traditional", 19) == 0)
      language = "TRADITIONAL CHINESE_TAIWAN";

    appendStringInfo (&buf, "NLS_LANG=%s.%s", language, charset);
  }
  else {
    appendStringInfo (&buf, "NLS_LANG=%s", nls_lang);
  }

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 4244, __func__); elog_finish(14, "db2_fdw: set %s", buf.data); if (__builtin_constant_p(14) && (14) >= 20) __builtin_unreachable(); } while(0);

  return buf.data;
}
# 4258 "db2_fdw.c"
List * serializePlanData (struct DB2FdwState * fdwState)
{
  List *result = ((List *) ((void *)0));
  int i, len = 0;
  const struct paramDesc *param;


  result = lappend (result, serializeString (fdwState->dbserver));

  result = lappend (result, serializeString (fdwState->user));

  result = lappend (result, serializeString (fdwState->password));

  result = lappend (result, serializeString (fdwState->nls_lang));

  result = lappend (result, serializeString (fdwState->query));

  result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)((int) fdwState->prefetch))), 0, 1));

  result = lappend (result, serializeString (fdwState->db2Table->name));

  result = lappend (result, serializeString (fdwState->db2Table->pgname));

  result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)(fdwState->db2Table->ncols))), 0, 1));

  result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)(fdwState->db2Table->npgcols))), 0, 1));

  for (i = 0; i < fdwState->db2Table->ncols; ++i) {
    result = lappend (result, serializeString (fdwState->db2Table->cols[i]->name));
    result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)(fdwState->db2Table->cols[i]->db2type))), 0, 1));
    result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)(fdwState->db2Table->cols[i]->scale))), 0, 1));
    result = lappend (result, serializeString (fdwState->db2Table->cols[i]->pgname));
    result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)(fdwState->db2Table->cols[i]->pgattnum))), 0, 1));
    result = lappend (result, makeConst(26, -1, ((Oid) 0), 4, ((Datum) (fdwState->db2Table->cols[i]->pgtype)), 0, 1));
    result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)(fdwState->db2Table->cols[i]->pgtypmod))), 0, 1));
    result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)(fdwState->db2Table->cols[i]->used))), 0, 1));
    result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)(fdwState->db2Table->cols[i]->pkey))), 0, 1));
    result = lappend (result, serializeLong (fdwState->db2Table->cols[i]->val_size));

  }


  for (param = fdwState->paramList; param; param = param->next)
    ++len;

  result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)(len))), 0, 1));

  for (param = fdwState->paramList; param; param = param->next) {
    result = lappend (result, serializeString (param->name));
    result = lappend (result, makeConst(26, -1, ((Oid) 0), 4, ((Datum) (param->type)), 0, 1));
    result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)((int) param->bindType))), 0, 1));
    result = lappend (result, makeConst(23, -1, ((Oid) 0), 4, ((Datum) ((int32)((int) param->colnum))), 0, 1));

  }


  return result;
}






Const * serializeString (const char *s)
{
  if (s == ((void *)0))
    return makeNullConst (25, -1, ((Oid) 0));
  else
    return makeConst (25, -1, ((Oid) 0), -1, ((Datum) (cstring_to_text (s))), 0, 0);
}






Const * serializeLong (long i)
{
  if (sizeof (long) <= 4)
    return makeConst (23, -1, ((Oid) 0), 4, ((Datum) ((int32) i)), 0, 1);
  else
    return makeConst (23, -1, ((Oid) 0), 8, ((Datum) ((int64) i)), 0,

        1



      );
}






struct DB2FdwState *
deserializePlanData (List * list)
{
  struct DB2FdwState *state = palloc (sizeof (struct DB2FdwState));
  ListCell *cell = list_head (list);
  int i, len;
  struct paramDesc *param;


  state->session = ((void *)0);

  state->startup_cost = 0;
  state->total_cost = 0;

  state->rowcount = 0;
  state->columnindex = 0;
  state->params = ((void *)0);
  state->temp_cxt = ((void *)0);
  state->order_clause = ((void *)0);


  state->dbserver = deserializeString (((cell)->data.ptr_value));
  cell = ((cell)->next);


  state->user = deserializeString (((cell)->data.ptr_value));
  cell = ((cell)->next);


  state->password = deserializeString (((cell)->data.ptr_value));
  cell = ((cell)->next);


  state->nls_lang = deserializeString (((cell)->data.ptr_value));
  cell = ((cell)->next);


  state->query = deserializeString (((cell)->data.ptr_value));
  cell = ((cell)->next);


  state->prefetch = (unsigned int) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
  cell = ((cell)->next);


  state->db2Table = (struct db2Table *) palloc (sizeof (struct db2Table));
  state->db2Table->name = deserializeString (((cell)->data.ptr_value));
  cell = ((cell)->next);
  state->db2Table->pgname = deserializeString (((cell)->data.ptr_value));
  cell = ((cell)->next);
  state->db2Table->ncols = (int) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
  cell = ((cell)->next);
  state->db2Table->npgcols = (int) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
  cell = ((cell)->next);
  state->db2Table->cols = (struct db2Column **) palloc (sizeof (struct db2Column *) * state->db2Table->ncols);


  for (i = 0; i < state->db2Table->ncols; ++i) {
    state->db2Table->cols[i] = (struct db2Column *) palloc (sizeof (struct db2Column));
    state->db2Table->cols[i]->name = deserializeString (((cell)->data.ptr_value));
    cell = ((cell)->next);
    state->db2Table->cols[i]->db2type = (db2Type) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
    cell = ((cell)->next);
    state->db2Table->cols[i]->scale = (int) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
    cell = ((cell)->next);
    state->db2Table->cols[i]->pgname = deserializeString (((cell)->data.ptr_value));
    cell = ((cell)->next);
    state->db2Table->cols[i]->pgattnum = (int) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
    cell = ((cell)->next);
    state->db2Table->cols[i]->pgtype = ((Oid) (((Const *) ((cell)->data.ptr_value))->constvalue));
    cell = ((cell)->next);
    state->db2Table->cols[i]->pgtypmod = (int) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
    cell = ((cell)->next);
    state->db2Table->cols[i]->used = (int) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
    cell = ((cell)->next);
    state->db2Table->cols[i]->pkey = (int) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
    cell = ((cell)->next);
    state->db2Table->cols[i]->val_size = deserializeLong (((cell)->data.ptr_value));
    cell = ((cell)->next);

    state->db2Table->cols[i]->val = (char *) palloc (state->db2Table->cols[i]->val_size + 1);
    state->db2Table->cols[i]->val_len = 0;
    state->db2Table->cols[i]->val_len4 = 0;
    state->db2Table->cols[i]->val_null = 1;
  }


  len = (int) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
  cell = ((cell)->next);


  state->paramList = ((void *)0);
  for (i = 0; i < len; ++i) {
    param = (struct paramDesc *) palloc (sizeof (struct paramDesc));
    param->name = deserializeString (((cell)->data.ptr_value));
    cell = ((cell)->next);
    param->type = ((Oid) (((Const *) ((cell)->data.ptr_value))->constvalue));
    cell = ((cell)->next);
    param->bindType = (db2BindType) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
    cell = ((cell)->next);
    if (param->bindType == BIND_OUTPUT)
      param->value = (void *) 42;
    else
      param->value = ((void *)0);
    param->node = ((void *)0);
    param->bindh = ((void *)0);
    param->colnum = (int) ((int32) (((Const *) ((cell)->data.ptr_value))->constvalue));
    cell = ((cell)->next);
    param->next = state->paramList;
    state->paramList = param;
  }

  return state;
}






char *
deserializeString (Const * constant)
{
  if (constant->constisnull)
    return ((void *)0);
  else
    return text_to_cstring (((text *) pg_detoast_datum((struct varlena *) ((Pointer) (constant->constvalue)))));
}






long
deserializeLong (Const * constant)
{
  if (sizeof (long) <= 4)
    return (long) ((int32) (constant->constvalue));
  else
    return (long) ((int64) (constant->constvalue));
}






_Bool
optionIsTrue (const char *value)
{
  if (pg_strcasecmp (value, "on") == 0 || pg_strcasecmp (value, "yes") == 0 || pg_strcasecmp (value, "true") == 0)
    return 1;
  else
    return 0;
}






Expr *
find_em_expr_for_rel (EquivalenceClass * ec, RelOptInfo * rel)
{
  ListCell *lc_em;

  for ((lc_em) = list_head(ec->ec_members); (lc_em) != ((void *)0); (lc_em) = ((lc_em)->next)) {
    EquivalenceMember *em = ((lc_em)->data.ptr_value);

    if (bms_equal (em->em_relids, rel->relids)) {





      return em->em_expr;
    }
  }


  return ((void *)0);
}






char *
deparseDate (Datum datum)
{
  struct pg_tm datetime_tm;
  StringInfoData s;

  if ((((((DateADT) ((int32) (datum)))) == ((DateADT) (-0x7FFFFFFF-1))) || ((((DateADT) ((int32) (datum)))) == ((DateADT) (0x7FFFFFFF)))))
    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 4550, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('2') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("infinite date value cannot be stored in DB2")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);


  (void) j2date (((DateADT) ((int32) (datum))) + 2451545, &(datetime_tm.tm_year), &(datetime_tm.tm_mon), &(datetime_tm.tm_mday));

  if (datetime_tm.tm_year < 0)
    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 4556, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('2') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("BC date value cannot be stored in DB2")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);

  initStringInfo (&s);
  appendStringInfo (&s, "%04d-%02d-%02d 00:00:00",
      datetime_tm.tm_year > 0 ? datetime_tm.tm_year : -datetime_tm.tm_year + 1, datetime_tm.tm_mon, datetime_tm.tm_mday);

  return s.data;
}





char *
deparseTimestamp (Datum datum, _Bool hasTimezone)
{
  struct pg_tm datetime_tm;
  int32 tzoffset;
  fsec_t datetime_fsec;
  StringInfoData s;


  if ((((((TimestampTz) ((int64) (datum)))) == (-(0x7FFFFFFFFFFFFFFFL) - 1)) || ((((TimestampTz) ((int64) (datum)))) == (0x7FFFFFFFFFFFFFFFL))))
    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 4579, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('2') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("infinite timestamp value cannot be stored in DB2")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);


  tzoffset = 0;
  (void) timestamp2tm (((TimestampTz) ((int64) (datum))), hasTimezone ? &tzoffset : ((void *)0), &datetime_tm, &datetime_fsec, ((void *)0), ((void *)0));

  if (datetime_tm.tm_year < 0)
    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 4586, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('2') - '0') & 0x3F) << 18) + (((('4') - '0') & 0x3F) << 24))), errmsg ("BC date value cannot be stored in DB2")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);

  initStringInfo (&s);
  if (hasTimezone)
    appendStringInfo (&s, "%04d-%02d-%02d %02d:%02d:%02d.%06d%+03d:%02d",
        datetime_tm.tm_year > 0 ? datetime_tm.tm_year : -datetime_tm.tm_year + 1,
        datetime_tm.tm_mon, datetime_tm.tm_mday, datetime_tm.tm_hour,
        datetime_tm.tm_min, datetime_tm.tm_sec, (int32) datetime_fsec,
        -tzoffset / 3600, ((tzoffset > 0) ? tzoffset % 3600 : -tzoffset % 3600) / 60);
  else
    appendStringInfo (&s, "%04d-%02d-%02d %02d:%02d:%02d.%06d",
        datetime_tm.tm_year > 0 ? datetime_tm.tm_year : -datetime_tm.tm_year + 1,
        datetime_tm.tm_mon, datetime_tm.tm_mday, datetime_tm.tm_hour,
        datetime_tm.tm_min, datetime_tm.tm_sec, (int32) datetime_fsec);

  return s.data;
}





char *
deparseInterval (Datum datum)
{
  struct pg_tm tm;
  fsec_t fsec;
  StringInfoData s;
  char *sign;

  if (interval2tm (*((Interval *) ((Pointer) (datum))), &tm, &fsec) != 0) {
    do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 4617, __func__); elog_finish(20, "could not convert interval to tm"); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
  }


  if (tm.tm_year != 0 || tm.tm_mon != 0)
    return ((void *)0);


  if (tm.tm_mday < 0 || tm.tm_hour < 0 || tm.tm_min < 0 || tm.tm_sec < 0 || fsec < 0) {
    sign = "-";

    if (tm.tm_mday > 0 || tm.tm_hour > 0 || tm.tm_min > 0 || tm.tm_sec > 0 || fsec > 0)
      return ((void *)0);
    tm.tm_mday = -tm.tm_mday;
    tm.tm_hour = -tm.tm_hour;
    tm.tm_min = -tm.tm_min;
    tm.tm_sec = -tm.tm_sec;
    fsec = -fsec;
  }
  else
    sign = "";

  initStringInfo (&s);
  appendStringInfo (&s, "INTERVAL '%s%d %02d:%02d:%02d.%06d' DAY(9) TO SECOND(6)", sign, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, fsec);

  return s.data;
}







struct DB2FdwState *
copyPlanData (struct DB2FdwState *orig)
{
  int i;
  struct DB2FdwState *copy = palloc (sizeof (struct DB2FdwState));

  copy->dbserver = pstrdup (orig->dbserver);
  copy->user = pstrdup (orig->user);
  copy->password = pstrdup (orig->password);
  copy->nls_lang = pstrdup (orig->nls_lang);
  copy->session = ((void *)0);
  copy->query = ((void *)0);
  copy->paramList = ((void *)0);
  copy->db2Table = (struct db2Table *) palloc (sizeof (struct db2Table));
  copy->db2Table->name = pstrdup (orig->db2Table->name);
  copy->db2Table->pgname = pstrdup (orig->db2Table->pgname);
  copy->db2Table->ncols = orig->db2Table->ncols;
  copy->db2Table->npgcols = orig->db2Table->npgcols;
  copy->db2Table->cols = (struct db2Column **) palloc (sizeof (struct db2Column *) * orig->db2Table->ncols);
  for (i = 0; i < orig->db2Table->ncols; ++i) {
    copy->db2Table->cols[i] = (struct db2Column *) palloc (sizeof (struct db2Column));
    copy->db2Table->cols[i]->name = pstrdup (orig->db2Table->cols[i]->name);
    copy->db2Table->cols[i]->db2type = orig->db2Table->cols[i]->db2type;
    copy->db2Table->cols[i]->scale = orig->db2Table->cols[i]->scale;
    if (orig->db2Table->cols[i]->pgname == ((void *)0))
      copy->db2Table->cols[i]->pgname = ((void *)0);
    else
      copy->db2Table->cols[i]->pgname = pstrdup (orig->db2Table->cols[i]->pgname);
    copy->db2Table->cols[i]->pgattnum = orig->db2Table->cols[i]->pgattnum;
    copy->db2Table->cols[i]->pgtype = orig->db2Table->cols[i]->pgtype;
    copy->db2Table->cols[i]->pgtypmod = orig->db2Table->cols[i]->pgtypmod;
    copy->db2Table->cols[i]->used = 0;
    copy->db2Table->cols[i]->pkey = orig->db2Table->cols[i]->pkey;
    copy->db2Table->cols[i]->val = ((void *)0);
    copy->db2Table->cols[i]->val_size = orig->db2Table->cols[i]->val_size;
    copy->db2Table->cols[i]->val_len = 0;
    copy->db2Table->cols[i]->val_len4 = 0;
    copy->db2Table->cols[i]->val_null = 0;
  }
  copy->startup_cost = 0.0;
  copy->total_cost = 0.0;
  copy->rowcount = 0;
  copy->columnindex = 0;
  copy->temp_cxt = ((void *)0);
  copy->order_clause = ((void *)0);

  return copy;
}





void
subtransactionCallback (SubXactEvent event, SubTransactionId mySubid, SubTransactionId parentSubid, void *arg)
{

  if (event == SUBXACT_EVENT_ABORT_SUB || event == SUBXACT_EVENT_PRE_COMMIT_SUB)
    db2EndSubtransaction (arg, GetCurrentTransactionNestLevel (), event == SUBXACT_EVENT_PRE_COMMIT_SUB);
}






void
addParam (struct paramDesc **paramList, char *name, Oid pgtype, db2Type db2type, int colnum)
{
  struct paramDesc *param;

  param = palloc (sizeof (struct paramDesc));
  param->name = pstrdup (name);
  param->type = pgtype;
  switch (db2type) {
  case SQL_TYPE_INTEGER:
  case SQL_TYPE_BIG:
  case SQL_TYPE_SMALL:
  case SQL_TYPE_FLOAT:
    param->bindType = BIND_NUMBER;
    break;
  case SQL_TYPE_CLOB:
    param->bindType = BIND_LONG;
    break;
  case SQL_TYPE_BLOB:
    param->bindType = BIND_LONGRAW;
    break;
  default:
    param->bindType = BIND_STRING;
  }
  param->value = ((void *)0);
  param->node = ((void *)0);
  param->bindh = ((void *)0);
  param->colnum = colnum;
  param->next = *paramList;
  *paramList = param;
}






void
setModifyParameters (struct paramDesc *paramList, TupleTableSlot * newslot, TupleTableSlot * oldslot, struct db2Table *db2Table, db2Session * session)
{
  struct paramDesc *param;
  Datum datum;
  _Bool isnull;
  int32 value_len;
  char *p, *q;
  Oid pgtype;

  for (param = paramList; param != ((void *)0); param = param->next) {

    if (param->bindType == BIND_OUTPUT)
      continue;

    if (param->name[1] == 'k') {

      datum = ExecGetJunkAttribute (oldslot, db2Table->cols[param->colnum]->pkey, &isnull);
    }
    else {

      datum = slot_getattr (newslot, db2Table->cols[param->colnum]->pgattnum, &isnull);
    }

    switch (param->bindType) {
    case BIND_STRING:
    case BIND_NUMBER:
      if (isnull) {
 param->value = ((void *)0);
 break;
      }

      pgtype = db2Table->cols[param->colnum]->pgtype;


      if (pgtype == 1082) {
 param->value = deparseDate (datum);
 break;
      } else if (pgtype == 1114 || pgtype == 1184) {
 param->value = deparseTimestamp (datum, (pgtype == 1184));
 break;
      } else if (pgtype == 1083 || pgtype == 1266) {
 param->value = deparseTimestamp (datum, (pgtype == 1266));
 break;
      }


      param->value = ((char *) ((Pointer) (OidFunctionCall1Coll(output_funcs[param->colnum], ((Oid) 0), datum))));


      switch (db2Table->cols[param->colnum]->pgtype) {
      case 2950:

 for (p = q = param->value; *p != '\0'; ++p, ++q) {
   if (*p == '-')
     ++p;
   *q = *p;
 }
 *q = '\0';
 break;
      case 16:

 if (param->value[0] == 't')
   param->value[0] = '1';
 else
   param->value[0] = '0';
 param->value[1] = '\0';
 break;
      default:

 break;
      }
      break;
    case BIND_LONG:
    case BIND_LONGRAW:
      if (isnull) {
 param->value = ((void *)0);
 break;
      }


      datum = (Datum) pg_detoast_datum((struct varlena *) ((Pointer) (datum)));

      value_len = ((((varattrib_4b *) (datum))->va_4byte.va_header >> 2) & 0x3FFFFFFF) - ((int32) sizeof(int32));


      param->value = palloc (value_len + 4);
      memcpy (param->value, (const char *) &value_len, 4);
      memcpy (param->value + 4, (((varattrib_4b *) (datum))->va_4byte.va_data), value_len);
      break;
    case BIND_OUTPUT:

      break;
    }
  }
}






void
transactionCallback (XactEvent event, void *arg)
{
  switch (event) {
  case XACT_EVENT_PRE_COMMIT:
  case XACT_EVENT_PARALLEL_PRE_COMMIT:

    db2EndTransaction (arg, 1, 0);
    break;
  case XACT_EVENT_PRE_PREPARE:
    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 4866, __func__, ((void *)0))) errfinish (errcode ((((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('L') - '0') & 0x3F) << 24))), errmsg ("cannot prepare a transaction that used remote tables")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
    break;
  case XACT_EVENT_COMMIT:
  case XACT_EVENT_PREPARE:
  case XACT_EVENT_PARALLEL_COMMIT:





    db2EndTransaction (arg, 1, 1);
    break;
  case XACT_EVENT_ABORT:
  case XACT_EVENT_PARALLEL_ABORT:

    db2EndTransaction (arg, 0, 1);
    break;
  }

  dml_in_transaction = 0;
}






void
exitHook (int code, Datum arg)
{
  db2Shutdown ();
}






void
db2Die (int postgres_signal_arg)
{




  db2Cancel ();
# 4920 "db2_fdw.c"
  die (postgres_signal_arg);
}






char *
setSelectParameters (struct paramDesc *paramList, ExprContext * econtext)
{
  struct paramDesc *param;
  Datum datum;
  HeapTuple tuple;
  TimestampTz tstamp;
  _Bool is_null;
  _Bool first_param = 1;

  MemoryContext oldcontext;

  StringInfoData info;
  initStringInfo (&info);



  oldcontext = MemoryContextSwitchTo (econtext->ecxt_per_tuple_memory);



  for (param = paramList; param; param = param->next) {
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (param->name) && __builtin_constant_p (":now") && (__s1_len = strlen (param->name), __s2_len = strlen (":now"), (!((size_t)(const void *)((param->name) + 1) - (size_t)(const void *)(param->name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((":now") + 1) - (size_t)(const void *)(":now") == 1) || __s2_len >= 4)) ? __builtin_strcmp (param->name, ":now") : (__builtin_constant_p (param->name) && ((size_t)(const void *)((param->name) + 1) - (size_t)(const void *)(param->name) == 1) && (__s1_len = strlen (param->name), __s1_len < 4) ? (__builtin_constant_p (":now") && ((size_t)(const void *)((":now") + 1) - (size_t)(const void *)(":now") == 1) ? __builtin_strcmp (param->name, ":now") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (":now"); int __result = (((const unsigned char *) (const char *) (param->name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (param->name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (param->name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (param->name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (":now") && ((size_t)(const void *)((":now") + 1) - (size_t)(const void *)(":now") == 1) && (__s2_len = strlen (":now"), __s2_len < 4) ? (__builtin_constant_p (param->name) && ((size_t)(const void *)((param->name) + 1) - (size_t)(const void *)(param->name) == 1) ? __builtin_strcmp (param->name, ":now") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (param->name); register int __result = __s1[0] - ((const unsigned char *) (const char *) (":now"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (":now"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (":now"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (":now"))[3]); } } __result; }))) : __builtin_strcmp (param->name, ":now")))); }) == 0) {

      tstamp = GetCurrentTransactionStartTimestamp ();

      datum = ((Datum) (tstamp));
      is_null = 0;
    }
    else {







      datum = ExecEvalExpr ((ExprState *) (param->node), econtext, &is_null);

    }

    if (is_null) {
      param->value = ((void *)0);
    }
    else {
      if (param->type == 1082)
 param->value = deparseDate (datum);
      else if (param->type == 1114 || param->type == 1184)
 param->value = deparseTimestamp (datum, (param->type == 1184));
      else if (param->type == 1083 || param->type == 1266)
 param->value = deparseTimestamp (datum, (param->type == 1266));
      else {
 regproc typoutput;


 tuple = SearchSysCache1 (TYPEOID, ((Datum) (param->type)));
 if (!((const void*)(tuple) != ((void *)0))) {
   do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 4985, __func__); elog_finish(20, "cache lookup failed for type %u", param->type); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
 }
 typoutput = ((Form_pg_type) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->typoutput;
 ReleaseSysCache (tuple);


 param->value = ((char *) ((Pointer) (OidFunctionCall1Coll(typoutput, ((Oid) 0), datum))));
      }
    }


    if (first_param) {
      first_param = 0;
      appendStringInfo (&info, ", parameters %s=\"%s\"", param->name, (param->value ? param->value : "(null)"));
    }
    else {
      appendStringInfo (&info, ", %s=\"%s\"", param->name, (param->value ? param->value : "(null)"));
    }
  }



  MemoryContextSwitchTo (oldcontext);


  return info.data;
}







void
convertTuple (struct DB2FdwState *fdw_state, Datum * values, _Bool * nulls, _Bool trunc_lob)
{
  char *value = ((void *)0);
  long value_len = 0;
  int j, index = -1;
  ErrorContextCallback errcb;
  Oid pgtype;


  errcb.callback = errorContextCallback;
  errcb.arg = (void *) fdw_state;


  for (j = 0; j < fdw_state->db2Table->npgcols; ++j) {

    if ((index + 1 < fdw_state->db2Table->ncols)
 && (fdw_state->db2Table->cols[index + 1]->pgattnum > j + 1)) {
      nulls[j] = 1;
      values[j] = ((Datum) (((void *)0)));
      continue;
    }
    else
      ++index;







    if (index >= fdw_state->db2Table->ncols || fdw_state->db2Table->cols[index]->used == 0 || fdw_state->db2Table->cols[index]->val_null == -1) {
      nulls[j] = 1;
      values[j] = ((Datum) (((void *)0)));
      continue;
    }


    nulls[j] = 0;
    pgtype = fdw_state->db2Table->cols[index]->pgtype;


    if (fdw_state->db2Table->cols[index]->db2type == SQL_TYPE_BLOB || fdw_state->db2Table->cols[index]->db2type == SQL_TYPE_CLOB) {

      db2GetLob (fdw_state->session,
   (void *) fdw_state->db2Table->cols[index]->val, fdw_state->db2Table->cols[index]->db2type, &value, &value_len, trunc_lob ? (1024 + 1) : 0);
    }
    else if (fdw_state->db2Table->cols[index]->db2type == SQL_TYPE_BIG) {

      value_len = *((int32 *) fdw_state->db2Table->cols[index]->val);

      value = fdw_state->db2Table->cols[index]->val + 4;

      value[value_len] = '\0';
    }
    else {

      value = fdw_state->db2Table->cols[index]->val;
      value_len = fdw_state->db2Table->cols[index]->val_len;
    }


    if (pgtype == 17) {

      bytea *result = (bytea *) palloc (value_len + ((int32) sizeof(int32)));
      memcpy ((((varattrib_4b *) (result))->va_4byte.va_data), value, value_len);
      (((varattrib_4b *) (result))->va_4byte.va_header = (((uint32) (value_len + ((int32) sizeof(int32)))) << 2));

      values[j] = ((Datum) (result));
    }
    else {
      regproc typinput;
      HeapTuple tuple;
      Datum dat;


      tuple = SearchSysCache1 (TYPEOID, ((Datum) (pgtype)));
      if (!((const void*)(tuple) != ((void *)0))) {
 do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 5097, __func__); elog_finish(20, "cache lookup failed for type %u", pgtype); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
      }
      typinput = ((Form_pg_type) ((char *) ((tuple)->t_data) + (tuple)->t_data->t_hoff))->typinput;
      ReleaseSysCache (tuple);

      dat = ((Datum) (value));


      errcb.previous = error_context_stack;
      error_context_stack = &errcb;
      fdw_state->columnindex = index;


      if (pgtype == 1042 || pgtype == 1043 || pgtype == 25)
 (void) pg_verify_mbstr (GetDatabaseEncoding (), value, value_len, 0);


      switch (pgtype) {
      case 1042:
      case 1043:
      case 1114:
      case 1184:
      case 1083:
      case 1266:
      case 1186:
      case 1700:

 values[j] = OidFunctionCall3Coll(typinput, ((Oid) 0), dat, ((Datum) (((Oid) 0))), ((Datum) (fdw_state->db2Table->cols[index]->pgtypmod)));
 break;
      default:

 values[j] = OidFunctionCall1Coll(typinput, ((Oid) 0), dat);
      }


      error_context_stack = errcb.previous;
    }


    if (fdw_state->db2Table->cols[index]->db2type == SQL_TYPE_BLOB || fdw_state->db2Table->cols[index]->db2type == SQL_TYPE_CLOB)
      pfree (value);
  }
}






void
errorContextCallback (void *arg)
{
  struct DB2FdwState *fdw_state = (struct DB2FdwState *) arg;

  set_errcontext_domain(((void *)0)), errcontext_msg ("converting column \"%s\" for foreign table scan of \"%s\", row %lu",
       quote_identifier (fdw_state->db2Table->cols[fdw_state->columnindex]->pgname), quote_identifier (fdw_state->db2Table->pgname), fdw_state->rowcount);
}






char *
fold_case (char *name, fold_t foldcase)
{
  if (foldcase == CASE_KEEP)
    return pstrdup (name);

  if (foldcase == CASE_LOWER)
    return str_tolower (name, strlen (name), 100);

  if (foldcase == CASE_SMART) {
    char *upstr = str_toupper (name, strlen (name), 100);


    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (upstr) && __builtin_constant_p (name) && (__s1_len = strlen (upstr), __s2_len = strlen (name), (!((size_t)(const void *)((upstr) + 1) - (size_t)(const void *)(upstr) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) || __s2_len >= 4)) ? __builtin_strcmp (upstr, name) : (__builtin_constant_p (upstr) && ((size_t)(const void *)((upstr) + 1) - (size_t)(const void *)(upstr) == 1) && (__s1_len = strlen (upstr), __s1_len < 4) ? (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) ? __builtin_strcmp (upstr, name) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (name); int __result = (((const unsigned char *) (const char *) (upstr))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (upstr))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (upstr))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (upstr))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) && (__s2_len = strlen (name), __s2_len < 4) ? (__builtin_constant_p (upstr) && ((size_t)(const void *)((upstr) + 1) - (size_t)(const void *)(upstr) == 1) ? __builtin_strcmp (upstr, name) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (upstr); register int __result = __s1[0] - ((const unsigned char *) (const char *) (name))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (name))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (name))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (name))[3]); } } __result; }))) : __builtin_strcmp (upstr, name)))); }) == 0)
      return str_tolower (name, strlen (name), 100);
    else
      return pstrdup (name);
  }

  do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 5179, __func__); elog_finish(20, "impossible case folding type %d", foldcase); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);

  return ((void *)0);
}






char *
db2GetShareFileName (const char *relativename)
{
  char share_path[1024], *result;

  get_share_path (my_exec_path, share_path);

  result = palloc (1024);
  pg_snprintf (result, 1024, "%s/%s", share_path, relativename);

  return result;
}





void
db2RegisterCallback (void *arg)
{
  RegisterXactCallback (transactionCallback, arg);

  RegisterSubXactCallback (subtransactionCallback, arg);

}





void
db2UnregisterCallback (void *arg)
{
  UnregisterXactCallback (transactionCallback, arg);

  UnregisterSubXactCallback (subtransactionCallback, arg);

}





void *
db2Alloc (size_t size)
{
  return palloc (size);
}





void *
db2Realloc (void *p, size_t size)
{
  return repalloc (p, size);
}





void
db2Free (void *p)
{
  pfree (p);
}





void
db2SetHandlers ()
{
  pqsignal (15, db2Die);
}
# 5280 "db2_fdw.c"
void db2Error_d (db2error sqlstate, const char *message, const char *detail, ...)
{
  char cBuffer [4000];
  va_list arg_marker;


  do { if (InterruptPending) ProcessInterrupts(); } while(0);
  __builtin_va_start(arg_marker,detail);
  pg_vsprintf (cBuffer, detail, arg_marker);
  do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 5289, __func__, ((void *)0))) errfinish (errcode ((sqlstate==FDW_UNABLE_TO_ESTABLISH_CONNECTION ? (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('N') - '0') & 0x3F) << 24)) : (sqlstate==FDW_UNABLE_TO_CREATE_REPLY ? (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('M') - '0') & 0x3F) << 24)) : (sqlstate==FDW_TABLE_NOT_FOUND ? (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('R') - '0') & 0x3F) << 24)) : (sqlstate==FDW_UNABLE_TO_CREATE_EXECUTION ? (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('L') - '0') & 0x3F) << 24)) : (sqlstate==FDW_OUT_OF_MEMORY ? (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('1') - '0') & 0x3F) << 24)) : (sqlstate==FDW_SERIALIZATION_FAILURE ? (((('4') - '0') & 0x3F) + (((('0') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('1') - '0') & 0x3F) << 24)) : (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('0') - '0') & 0x3F) << 24))))))))), errmsg ("%s", message), errdetail ("%s", cBuffer)); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
  __builtin_va_end(arg_marker);
}





void
db2Error (db2error sqlstate, const char *message)
{

  if (strstr (message, "%m")) {
    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 5302, __func__, ((void *)0))) errfinish (errcode_for_file_access (), errmsg (message, "")); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
  }
  else {
    do { int __errno_location __attribute__((unused)); if (errstart(20, "db2_fdw.c", 5305, __func__, ((void *)0))) errfinish (errcode ((sqlstate==FDW_UNABLE_TO_ESTABLISH_CONNECTION ? (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('N') - '0') & 0x3F) << 24)) : (sqlstate==FDW_UNABLE_TO_CREATE_REPLY ? (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('M') - '0') & 0x3F) << 24)) : (sqlstate==FDW_TABLE_NOT_FOUND ? (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('R') - '0') & 0x3F) << 24)) : (sqlstate==FDW_UNABLE_TO_CREATE_EXECUTION ? (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('L') - '0') & 0x3F) << 24)) : (sqlstate==FDW_OUT_OF_MEMORY ? (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('1') - '0') & 0x3F) << 24)) : (sqlstate==FDW_SERIALIZATION_FAILURE ? (((('4') - '0') & 0x3F) + (((('0') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('1') - '0') & 0x3F) << 24)) : (((('H') - '0') & 0x3F) + (((('V') - '0') & 0x3F) << 6) + (((('0') - '0') & 0x3F) << 12) + (((('0') - '0') & 0x3F) << 18) + (((('0') - '0') & 0x3F) << 24))))))))), errmsg ("%s", message)); if (__builtin_constant_p(20) && (20) >= 20) __builtin_unreachable(); } while(0);
  }
}






void db2Debug2 (const char *message, ...)
{
char cBuffer [4000];
va_list arg_marker;
__builtin_va_start(arg_marker,message);
pg_vsprintf (cBuffer, message, arg_marker);
do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 5320, __func__); elog_finish(13, "%s", cBuffer); if (__builtin_constant_p(13) && (13) >= 20) __builtin_unreachable(); } while(0);
__builtin_va_end(arg_marker);
}

void db2Debug3 (const char *message, ...)
{
char cBuffer [4000];
va_list arg_marker;
__builtin_va_start(arg_marker,message);
pg_vsprintf (cBuffer, message, arg_marker);
do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 5330, __func__); elog_finish(12, "%s", cBuffer); if (__builtin_constant_p(12) && (12) >= 20) __builtin_unreachable(); } while(0);
__builtin_va_end(arg_marker);
}
void db2Debug4 (const char *message, ...)
{
char cBuffer [4000];
va_list arg_marker;
__builtin_va_start(arg_marker,message);
pg_vsprintf (cBuffer, message, arg_marker);
do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 5339, __func__); elog_finish(11, "%s", cBuffer); if (__builtin_constant_p(11) && (11) >= 20) __builtin_unreachable(); } while(0);
__builtin_va_end(arg_marker);
}
void db2Debug5 (const char *message, ...)
{
char cBuffer [4000];
va_list arg_marker;
__builtin_va_start(arg_marker,message);
pg_vsprintf (cBuffer, message, arg_marker);
do { int __errno_location __attribute__((unused)); elog_start("db2_fdw.c", 5348, __func__); elog_finish(10, "%s", cBuffer); if (__builtin_constant_p(10) && (10) >= 20) __builtin_unreachable(); } while(0);
__builtin_va_end(arg_marker);
}
